# Statements

----

**This file is automatically generated from java files. Do Not Edit It.**

----

## Table of Contents
<wiki:toc max_depth="2" />
[=](#=), [benchmark](#benchmark), [break](#break), [camera](#camera), [capture](#capture), [default](#default), [diffuse](#diffuse), [enter](#enter), [equation](#equation), [exit](#exit), [graphics](#graphics), [light](#light), [migrate](#migrate), [overlay](#overlay), [parameter](#parameter), [release](#release), [solve](#solve), [trace](#trace), [user_init](#user_init), [user_panel](#user_panel), [Variable_container](#variable_container), 


## Statements by kinds

  * **Behavior**
    * [user_init](#user_init),  [user_panel](#user_panel),  
  * **Layer**
    * [camera](#camera),  [graphics](#graphics),  [light](#light),  [overlay](#overlay),  
  * **Parameter**
    * [parameter](#parameter),  
  * **Sequence of statements or action**
    * [benchmark](#benchmark),  [capture](#capture),  [default](#default),  [enter](#enter),  [equation](#equation),  [exit](#exit),  [migrate](#migrate),  [release](#release),  [trace](#trace),  
  * **Single statement**
    * [=](#=),  [break](#break),  [diffuse](#diffuse),  [solve](#solve),  
  * **Variable (container)**
    * [Variable_container](#variable_container),  


## Statements by embedment

  * **Behavior**
    * [benchmark](#benchmark), [capture](#capture), [diffuse](#diffuse), [migrate](#migrate), [release](#release), [solve](#solve), [trace](#trace), 
  * **Experiment**
    * [parameter](#parameter), [user_init](#user_init), [user_panel](#user_panel), [Variable_container](#variable_container), 
  * **Layer**
    * [benchmark](#benchmark), [trace](#trace), 
  * **Model**
    * [equation](#equation), [user_init](#user_init), [user_panel](#user_panel), [Variable_container](#variable_container), 
  * **Sequence of statements or action**
    * [benchmark](#benchmark), [break](#break), [capture](#capture), [diffuse](#diffuse), [migrate](#migrate), [release](#release), [solve](#solve), [trace](#trace), 
  * **Species**
    * [equation](#equation), [user_init](#user_init), [user_panel](#user_panel), [Variable_container](#variable_container), 
  * **display**
    * [camera](#camera), [graphics](#graphics), [light](#light), [overlay](#overlay), 
  * **equation**
    * [=](#=), 
  * **fsm**
    * [user_panel](#user_panel), 
  * **state**
    * [enter](#enter), [exit](#exit), 
  * **switch**
    * [default](#default), 
  * **user_first**
    * [user_panel](#user_panel), 
  * **user_init**
    * [user_panel](#user_panel), 
  * **user_last**
    * [user_panel](#user_panel), 
  * **user_only**
    * [user_panel](#user_panel), 


## General syntax

A statement represents either a declaration or an imperative command. It consists in a keyword, followed by specific facets, some of them mandatory (in bold), some of them optional. One of the facet names can be omitted (the one denoted as omissible). It has to be the first one.

```
statement_keyword expression1 facet2: expression2 ... ;
or
statement_keyword facet1: expression1 facet2: expression2 ...;
```

If the statement encloses other statements, it is called a **sequence statement**, and its sub-statements (either sequence statements or single statements) are declared between curly brackets, as in:

```
statement_keyword1 expression1 facet2: expression2... { // a sequence statement
     statement_keyword2 expression1 facet2: expression2...;  // a single statement
     statement_keyword3 expression1 facet2: expression2...;
}
```
	

----

[//]: # (keyword|statement_=)
### = 
#### Facets 
  
  * **`right`** (float), (omissible) : the right part of the equation (it is mandatory that it can be evaluated as a float  
  * **`left`** (any type): the left part of the equation (it should be a variable or a call to the diff() or diff2() operators) 
 	
#### Definition

Allows to implement an equation in the form function(n, t) = expression. The left function is only here as a placeholder for enabling a simpler syntax and grabbing the variable as its left member.

#### Usages

* The syntax of the = statement is a bit different from the other statements. It has to be used as follows (in an equation):

```
float t;
float S;
float I;
equation SI { 
   diff(S,t) = (- 0.3 * S * I / 100);
   diff(I,t) = (0.3 * S * I / 100);
} 
```

    
* See also: [equation](#equation), [solve](#solve), 

#### Embedments
* The `=` statement is of type: **Single statement**
* The `=` statement can be embedded into: equation, 
* The `=` statement embeds statements: 

----

[//]: # (keyword|statement_benchmark)
### benchmark 
#### Facets 

  * `message` (any type), (omissible) : A message to display alongside the results. Should concisely describe the contents of the benchmark
  * `repeat` (int): An int expression describing how many executions of the block must be handled. The output in this case will return the min, max and average durations 
 	
#### Definition

Displays in the console the duration in ms of the execution of the statements included in the block. It is possible to indicate, with the 'repeat' facet, how many times the sequence should be run

#### Usages


#### Embedments
* The `benchmark` statement is of type: **Sequence of statements or action**
* The `benchmark` statement can be embedded into: Behavior, Sequence of statements or action, Layer, 
* The `benchmark` statement embeds statements: 

----

[//]: # (keyword|statement_break)
### break 
#### Facets 
 
 	
#### Definition

`break` allows to interrupt the current sequence of statements.

#### Usages


#### Embedments
* The `break` statement is of type: **Single statement**
* The `break` statement can be embedded into: Sequence of statements or action, 
* The `break` statement embeds statements: 

----

[//]: # (keyword|statement_camera)
### camera 
#### Facets 
  
  * **`name`** (string), (omissible) : The name of the camera
  * `location` (point): The location of the camera in the world
  * `look_at` (point): The location that the camera is looking
  * `up_vector` (point): The up-vector of the camera. 
 	
#### Definition

`camera` allows the modeler to define a camera. The display will then be able to choose among the camera defined (either within this statement or globally in GAMA) in a dynamic way.

#### Usages
    
* See also: [display](#display), [agents](#agents), [chart](#chart), [event](#event), [graphics](#graphics), [display_grid](#display_grid), [image](#image), [display_population](#display_population), 

#### Embedments
* The `camera` statement is of type: **Layer**
* The `camera` statement can be embedded into: display, 
* The `camera` statement embeds statements: 

----

[//]: # (keyword|statement_capture)
### capture 
#### Facets 
  
  * **`target`** (any type in [agent, container]), (omissible) : an expression that is evaluated as an agent or a list of the agent to be captured
  * `as` (species): the species that the captured agent(s) will become, this is a micro-species of the calling agent's species
  * `returns` (a new identifier): a list of the newly captured agent(s) 
 	
#### Definition

Allows an agent to capture other agent(s) as its micro-agent(s).

#### Usages

* The preliminary for an agent A to capture an agent B as its micro-agent is that the A's species must defined a micro-species which is a sub-species of B's species (cf. [Species161#Nesting_species Nesting species]).

```
species A {
...
}
species B {
...
   species C parent: A {
   ...
   }
...
}
```


* To capture all "A" agents as "C" agents, we can ask an "B" agent to execute the following statement:

```
capture list(B) as: C;
```


* Deprecated writing:

```
capture target: list (B) as: C;
```

    
* See also: [release](#release), 

#### Embedments
* The `capture` statement is of type: **Sequence of statements or action**
* The `capture` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `capture` statement embeds statements: 

----

[//]: # (keyword|statement_default)
### default 
#### Facets 

  * `value` (any type), (omissible) : The value or values this statement tries to match 
 	
#### Definition

Used in a switch match structure, the block prefixed by default is executed only if no other block has matched (otherwise it is not).

#### Usages
    
* See also: [switch](#switch), [match](#match), 

#### Embedments
* The `default` statement is of type: **Sequence of statements or action**
* The `default` statement can be embedded into: switch, 
* The `default` statement embeds statements: 

----

[//]: # (keyword|statement_diffuse)
### diffuse 
#### Facets 
  
  * **`var`** (an identifier), (omissible) : the variable to be diffused  
  * **`on`** (any type in [container, species]): the list of agents (in general cells of a grid), on which the diffusion will occur
  * `avoid_mask` (boolean): if true, the value will not be diffused in the masked cells, but will be restitute to the neighboring cells, multiplied by the proportion value (no signal lost). If false, the value will be diffused in the masked cells, but masked cells won't diffuse the value afterward (lost of signal). (default value : false)
  * `cycle_length` (int): the number of diffusion operation applied in one simulation step
  * `mask` (matrix): a matrix masking the diffusion (matrix created from a image for example). The cells corresponding to the values smaller than "-1" in the mask matrix will not diffuse, and the other will diffuse.
  * `mat_diffu` (matrix): the diffusion matrix (can have any size)
  * `matrix` (matrix): the diffusion matrix ("kernel" or "filter" in image processing). Can have any size, as long as dimensions are odd values.
  * `method` (an identifier), takes values in: {convolution, dot_product}: the diffusion method
  * `min_value` (float): if a value is smaller than this value, it will not be diffused. By default, this value is equal to 0.0. This value cannot be smaller than 0.
  * `propagation` (a label), takes values in: {diffusion, gradient}: represents both the way the signal is propagated and the way to treat multiple propagation of the same signal occurring at once from different places. If propagation equals 'diffusion', the intensity of a signal is shared between its neighbors with respect to 'proportion', 'variation' and the number of neighbors of the environment places (4, 6 or 8). I.e., for a given signal S propagated from place P, the value transmitted to its N neighbors is : S' = (S / N / proportion) - variation. The intensity of S is then diminished by S `*` proportion on P. In a diffusion, the different signals of the same name see their intensities added to each other on each place. If propagation equals 'gradient', the original intensity is not modified, and each neighbors receives the intensity : S / proportion - variation. If multiple propagation occur at once, only the maximum intensity is kept on each place. If 'propagation' is not defined, it is assumed that it is equal to 'diffusion'.
  * `proportion` (float): a diffusion rate
  * `radius` (int): a diffusion radius (in number of cells from the center)
  * `variation` (float): an absolute value to decrease at each neighbors 
 	
#### Definition

This statements allows a value to diffuse among a species on agents (generally on a grid) depending on a given diffusion matrix.

#### Usages

* A basic example of diffusion of the variable phero defined in the species cells, given a diffusion matrix math_diff is:

```
matrix<float> math_diff <- matrix([[1/9,1/9,1/9],[1/9,1/9,1/9],[1/9,1/9,1/9]]);
diffuse var: phero on: cells mat_diffu: math_diff;
```


* The diffusion can be masked by obstacles, created from a bitmap image:

```
diffuse var: phero on: cells mat_diffu: math_diff mask: mymask;
```


* A convenient way to have an uniform diffusion in a given radius is (which is equivalent to the above diffusion):

```
diffuse var: phero on: cells proportion: 1/9 radius: 1;
```



#### Embedments
* The `diffuse` statement is of type: **Single statement**
* The `diffuse` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `diffuse` statement embeds statements: 

----

[//]: # (keyword|statement_enter)
### enter 
#### Facets 
 
 	
#### Definition

In an FSM architecture, `enter` introduces a sequence of statements to execute upon entering a state.

#### Usages

* In the following example, at the step it enters into the state s_init, the message 'Enter in s_init' is displayed followed by the display of the state name:

```
	state s_init {
		enter { write "Enter in" + state; }
			write "Enter in" + state;
		}
		write state;
	}
```

    
* See also: [state](#state), [exit](#exit), [transition](#transition), 

#### Embedments
* The `enter` statement is of type: **Sequence of statements or action**
* The `enter` statement can be embedded into: state, 
* The `enter` statement embeds statements: 

----

[//]: # (keyword|statement_equation)
### equation 
#### Facets 
  
  * **`name`** (an identifier), (omissible) : the equation identifier
  * `params` (list): the list of parameters used in predefined equation systems
  * `simultaneously` (list): a list of species containing a system of equations (all systems will be solved simultaneously)
  * `type` (an identifier), takes values in: {SI, SIS, SIR, SIRS, SEIR, LV}: the choice of one among classical models (SI, SIS, SIR, SIRS, SEIR, LV)
  * `vars` (list): the list of variables used in predefined equation systems 
 	
#### Definition

The equation statement is used to create an equation system from several single equations.

#### Usages

* The basic syntax to define an equation system is:

```
float t;
float S;
float I;
equation SI { 
   diff(S,t) = (- 0.3 * S * I / 100);
   diff(I,t) = (0.3 * S * I / 100);
} 
```


* If the type: facet is used, a predefined equation system is defined using variables vars: and parameters params: in the right order. All possible predefined equation systems are the following ones (see [EquationPresentation161 EquationPresentation161] for precise definition of each classical equation system): 

```
equation eqSI type: SI vars: [S,I,t] params: [N,beta];
equation eqSIS type: SIS vars: [S,I,t] params: [N,beta,gamma];
equation eqSIR type:SIR vars:[S,I,R,t] params:[N,beta,gamma];
equation eqSIRS type: SIRS vars: [S,I,R,t] params: [N,beta,gamma,omega,mu];
equation eqSEIR type: SEIR vars: [S,E,I,R,t] params: [N,beta,gamma,sigma,mu];
equation eqLV type: LV vars: [x,y,t] params: [alpha,beta,delta,gamma] ;
```


* If the simultaneously: facet is used, system of all the agents will be solved simultaneously.    
* See also: [=](#=), [solve](#solve), 

#### Embedments
* The `equation` statement is of type: **Sequence of statements or action**
* The `equation` statement can be embedded into: Species, Model, 
* The `equation` statement embeds statements: [=](#=),  

----

[//]: # (keyword|statement_exit)
### exit 
#### Facets 
 
 	
#### Definition

In an FSM architecture, `exit` introduces a sequence of statements to execute right before exiting the state.

#### Usages

* In the following example, at the state it leaves the state s_init, he will display the message 'EXIT from s_init':

```
	state s_init initial: true {
		write state;
		transition to: s1 when: (cycle > 2) {
			write "transition s_init -> s1";
		}
		exit {
			write "EXIT from "+state;
		}
	}
```

    
* See also: [enter](#enter), [state](#state), [transition](#transition), 

#### Embedments
* The `exit` statement is of type: **Sequence of statements or action**
* The `exit` statement can be embedded into: state, 
* The `exit` statement embeds statements: 

----

[//]: # (keyword|statement_graphics)
### graphics 
#### Facets 

  * `name` (a label), (omissible) : the human readable title of the graphics
  * `fading` (boolean): Used in conjunction with 'trace:', allows to apply a fading effect to the previous traces. Default is false
  * `position` (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.
  * `refresh` (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, usefull in case of agents that do not move)
  * `size` (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates > 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in 'position', an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions
  * `trace` (any type in [boolean, int]): Allows to aggregate the visualization at each timestep on the display. Default is false. If set to an int value, only the last n-th steps will be visualized. If set to true, no limit of timesteps is applied.
  * `transparency` (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency) 
 	
#### Definition

`graphics` allows the modeler to freely draw shapes/geometries/texts without having to define a species. It works exactly like a species [Aspect161 aspect]: the draw statement can be used in the same way.

#### Usages

* The general syntax is:

```
display my_display {
   graphics "my new layer" {
      draw circle(5) at: {10,10} color: #red;
      draw "test" at: {10,10} size: 20 color: #black;
   }
}
```

    
* See also: [display](#display), [agents](#agents), [chart](#chart), [event](#event), [graphics](#graphics), [display_grid](#display_grid), [image](#image), [overlay](#overlay), [display_population](#display_population), 

#### Embedments
* The `graphics` statement is of type: **Layer**
* The `graphics` statement can be embedded into: display, 
* The `graphics` statement embeds statements: 

----

[//]: # (keyword|statement_light)
### light 
#### Facets 
  
  * **`id`** (int), (omissible) : a number from 1 to 7 to specify which light we are using
  * `active` (boolean): a boolean expression telling if you want this light to be switch on or not. (default value : true)
  * `color` (any type in [int, rgb]): an int / rgb / rgba value to specify the color and the intensity of the light. (default value : (127,127,127,255) ).
  * `direction` (point): the direction of the light (only for direction and spot light). (default value : {0.5,0.5,-1})
  * `draw_light` (boolean): draw or not the light. (default value : false).
  * `linear_attenuation` (float): the linear attenuation of the positionnal light. (default value : 0)
  * `position` (point): the position of the light (only for point and spot light). (default value : {0,0,1})
  * `quadratic_attenuation` (float): the linear attenuation of the positionnal light. (default value : 0)
  * `spot_angle` (float): the angle of the spot light in degree (only for spot light). (default value : 45)
  * `type` (a label): the type of light to create. A value among {point, direction, spot}. (default value : direction)
  * `update` (boolean): specify if the light has to be updated. (default value : true). 
 	
#### Definition

`light` allows to define diffusion lights in your 3D display.

#### Usages

* The general syntax is:

```
light 1 type:point position:{20,20,20} color:255, linear_attenuation:0.01 quadratic_attenuation:0.0001 draw_light:true update:false
light 2 type:spot position:{20,20,20} direction:{0,0,-1} color:255 spot_angle:25 linear_attenuation:0.01 quadratic_attenuation:0.0001 draw_light:true update:false
light 3 type:point direction:{1,1,-1} color:255 draw_light:true update:false
```

    
* See also: [display](#display), 

#### Embedments
* The `light` statement is of type: **Layer**
* The `light` statement can be embedded into: display, 
* The `light` statement embeds statements: 

----

[//]: # (keyword|statement_migrate)
### migrate 
#### Facets 
  
  * **`source`** (any type in [agent, species, container, an identifier]), (omissible) : can be an agent, a list of agents, a agent's population to be migrated  
  * **`target`** (species): target species/population that source agent(s) migrate to.
  * `returns` (a new identifier): the list of returned agents in a new local variable 
 	
#### Definition

This command permits agents to migrate from one population/species to another population/species and stay in the same host after the migration. Species of source agents and target species respect the following constraints: (i) they are "peer" species (sharing the same direct macro-species), (ii) they have sub-species vs. parent-species relationship.

#### Usages

* It can be used in a 3-levels model, in case where individual agents can be captured into group meso agents and groups into clouds macro agents. migrate is used to allows agents captured by groups to migrate into clouds. See the model 'Balls, Groups and Clouds.gaml' in the library.

```
migrate ball_in_group target: ball_in_cloud;
```

    
* See also: [capture](#capture), [release](#release), 

#### Embedments
* The `migrate` statement is of type: **Sequence of statements or action**
* The `migrate` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `migrate` statement embeds statements: 

----

[//]: # (keyword|statement_overlay)
### overlay 
#### Facets 

  * `background` (rgb): the background color of the overlay displayed inside the view (the bottom overlay remains black)
  * `border` (rgb): Color to apply to the border of the rectangular shape of the overlay. Nil by default
  * `center` (any type): an expression that will be evaluated and displayed in the center section of the bottom overlay
  * `color` (any type in [list, rgb]): the color(s) used to display the expressions given in the 'left', 'center' and 'right' facets
  * `left` (any type): an expression that will be evaluated and displayed in the left section of the bottom overlay
  * `position` (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.
  * `right` (any type): an expression that will be evaluated and displayed in the right section of the bottom overlay
  * `rounded` (boolean): Whether or not the rectangular shape of the overlay should be rounded. True by default
  * `size` (point): extent of the layer in the view from its position. Coordinates in [0,1[ are treated as percentages of the total surface of the view, while coordinates > 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Unlike  'position', no elevation can be provided with the z coordinate
  * `transparency` (float): the transparency rate of the overlay (between 0 and 1, 1 means no transparency) when it is displayed inside the view. The bottom overlay will remain at 0.75 
 	
#### Definition

`overlay` allows the modeler to display a line to the already existing bottom overlay, where the results of 'left', 'center' and 'right' facets, when they are defined, are displayed with the corresponding color if defined.

#### Usages

* To display information in the bottom overlay, the syntax is:

```
overlay "Cycle: " + (cycle) center: "Duration: " + total_duration + "ms" right: "Model time: " + as_date(time,"") color: [#yellow, #orange, #yellow];
```

    
* See also: [display](#display), [agents](#agents), [chart](#chart), [event](#event), [graphics](#graphics), [display_grid](#display_grid), [image](#image), [display_population](#display_population), 

#### Embedments
* The `overlay` statement is of type: **Layer**
* The `overlay` statement can be embedded into: display, 
* The `overlay` statement embeds statements: 

----

[//]: # (keyword|statement_parameter)
### parameter 
#### Facets 
  
  * **`var`** (an identifier): the name of the variable (that should be declared in the global)
  * `name` (a label), (omissible) : The message displayed in the interface
  * `among` (list): the list of possible values
  * `category` (a label): a category label, used to group parameters in the interface
  * `init` (any type): the init value
  * `max` (any type): the maximum value
  * `min` (any type): the minimum value
  * `on_change` (any type): Provides a block of statements that will be executed whenever the value of the parameter changes
  * `slider` (boolean): Whether or not to display a slider for entering an int or float value. Default is true when max and min values are defined, false otherwise. If no max or min value is defined, setting this facet to true will have no effect
  * `step` (float): the increment step (mainly used in batch mode to express the variation step between simulation)
  * `type` (a datatype identifier): the variable type
  * `unit` (a label): the variable unit 
 	
#### Definition

The parameter statement specifies which global attributes (i) will change through the successive simulations (in batch experiments), (ii) can be modified by user via the interface (in gui experiments). In GUI experiments, parameters are displayed depending on their type.

#### Usages

* In gui experiment, the general syntax is the following:

```
parameter title var: global_var category: cat;
```


* In batch experiment, the two following syntaxes can be used to describe the possible values of a parameter:

```
parameter 'Value of toto:' var: toto among: [1, 3, 7, 15, 100]; 
parameter 'Value of titi:' var: titi min: 1 max: 100 step: 2; 
```



#### Embedments
* The `parameter` statement is of type: **Parameter**
* The `parameter` statement can be embedded into: Experiment, 
* The `parameter` statement embeds statements: 

----

[//]: # (keyword|statement_release)
### release 
#### Facets 
  
  * **`target`** (any type in [agent, list, 27]), (omissible) : an expression that is evaluated as an agent/a list of the agents to be released or an agent saved as a map
  * `as` (species): an expression that is evaluated as a species in which the micro-agent will be released
  * `in` (agent): an expression that is evaluated as an agent that will be the macro-agent in which micro-agent will be released, i.e. their new host
  * `returns` (a new identifier): a new variable containing a list of the newly released agent(s) 
 	
#### Definition

Allows an agent to release its micro-agent(s). The preliminary for an agent to release its micro-agents is that species of these micro-agents are sub-species of other species (cf. [Species161#Nesting_species Nesting species]). The released agents won't be micro-agents of the calling agent anymore. Being released from a macro-agent, the micro-agents will change their species and host (macro-agent).

#### Usages

* We consider the following species. Agents of "C" species can be released from a "B" agent to become agents of "A" species. Agents of "D" species cannot be released from the "A" agent because species "D" has no parent species.

```
species A {
...
}
species B {
...
   species C parent: A {
   ...
   }
   species D {
   ...
   }
...
}
```


* To release all "C" agents from a "B" agent, agent "C" has to execute the following statement. The "C" agent will change to "A" agent. The won't consider "B" agent as their macro-agent (host) anymore. Their host (macro-agent) will the be the host (macro-agent) of the "B" agent.

```
release list(C);
```


* The modeler can specify the new host and the new species of the released agents:

```
release list (C) as: new_species in: new host;
```

    
* See also: [capture](#capture), 

#### Embedments
* The `release` statement is of type: **Sequence of statements or action**
* The `release` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `release` statement embeds statements: 

----

[//]: # (keyword|statement_solve)
### solve 
#### Facets 
  
  * **`equation`** (an identifier), (omissible) : the equation system identifier to be numerically solved
  * `cycle_length` (int): length of simulation cycle which will be synchronize with step of integrator (default value: 1)
  * `discretizing_step` (int): number of discrete between 2 steps of simulation (default value: 0)
  * `integrated_times` (list): time interval inside integration process
  * `integrated_values` (list): list of variables's value inside integration process
  * `max_step` (float): maximal step, (used with dp853 method only), (sign is irrelevant, regardless of integration direction, forward or backward), the last step can be smaller than this value
  * `method` (an identifier), takes values in: {Euler, ThreeEighthes, Midpoint, Gill, Luther, rk4, dp853, AdamsBashforth, AdamsMoulton, DormandPrince54, GraggBulirschStoer, HighamHall54}: integrate method (can be only "Euler", "ThreeEighthes", "Midpoint", "Gill", "Luther", "rk4" or "dp853", "AdamsBashforth", "AdamsMoulton", "DormandPrince54", "GraggBulirschStoer",  "HighamHall54") (default value: "rk4")
  * `min_step` (float): minimal step, (used with dp853 method only), (sign is irrelevant, regardless of integration direction, forward or backward), the last step can be smaller than this value
  * `scalAbsoluteTolerance` (float): allowed absolute error (used with dp853 method only)
  * `scalRelativeTolerance` (float): allowed relative error (used with dp853 method only)
  * `step` (float): integration step, use with most integrator methods (default value: 1)
  * `time_final` (float): target time for the integration (can be set to a value smaller than t0 for backward integration)
  * `time_initial` (float): initial time 
 	
#### Definition

Solves all equations which matched the given name, with all systems of agents that should solved simultaneously.

#### Usages

* Other examples of use: 
```
solve SIR method: "rk4" step:0.001;
``` 
  

#### Embedments
* The `solve` statement is of type: **Single statement**
* The `solve` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `solve` statement embeds statements: 

----

[//]: # (keyword|statement_trace)
### trace 
#### Facets 
 
 	
#### Definition

All the statements executed in the trace statement are displayed in the console.

#### Usages


#### Embedments
* The `trace` statement is of type: **Sequence of statements or action**
* The `trace` statement can be embedded into: Behavior, Sequence of statements or action, Layer, 
* The `trace` statement embeds statements: 

----

[//]: # (keyword|statement_user_init)
### user_init 
#### Facets 
  
  * **`name`** (an identifier), (omissible) : The name of the panel
  * `initial` (boolean): Whether or not this panel will be the initial one 
 	
#### Definition

Used in the user control architecture, user_init is executed only once when the agent is created. It opens a special panel (if it contains user_commands statements). It is the equivalent to the init block in the basic agent architecture.

#### Usages
    
* See also: [user_command](#user_command), [user_init](#user_init), [user_input](#user_input), 

#### Embedments
* The `user_init` statement is of type: **Behavior**
* The `user_init` statement can be embedded into: Species, Experiment, Model, 
* The `user_init` statement embeds statements: [user_panel](#user_panel),  

----

[//]: # (keyword|statement_user_panel)
### user_panel 
#### Facets 
  
  * **`name`** (an identifier), (omissible) : The name of the panel
  * `initial` (boolean): Whether or not this panel will be the initial one 
 	
#### Definition

It is the basic behavior of the user control architecture (it is similar to state for the FSM architecture). This user_panel translates, in the interface, in a semi-modal view that awaits the user to choose action buttons, change attributes of the controlled agent, etc. Each user_panel, like a state in FSM, can have a enter and exit sections, but it is only defined in terms of a set of user_commands which describe the different action buttons present in the panel.

#### Usages

* The general syntax is for example:

```
user_panel default initial: true {
	user_input 'Number' returns: number type: int <- 10;
	ask (number among list(cells)){ do die; }
	transition to: "Advanced Control" when: every (10);
}

user_panel "Advanced Control" {
	user_input "Location" returns: loc type: point <- {0,0};
	create cells number: 10 with: [location::loc];
}
```

    
* See also: [user_command](#user_command), [user_init](#user_init), [user_input](#user_input), 

#### Embedments
* The `user_panel` statement is of type: **Behavior**
* The `user_panel` statement can be embedded into: fsm, user_first, user_last, user_init, user_only, Species, Experiment, Model, 
* The `user_panel` statement embeds statements: 

----

[//]: # (keyword|statement_Variable_container)
### Variable_container 
#### Facets 
  
  * **`name`** (a new identifier), (omissible) : The name of the attribute
  * `category` (a label): Soon to be deprecated. Declare the parameter in an experiment instead
  * `const` (boolean): Indicates whether this attribute can be subsequently modified or not
  * `fill_with` (any type): 
  * `function` (any type): Used to specify an expression that will be evaluated each time the attribute is accessed. This facet is incompatible with both 'init:' and 'update:'
  * `index` (a datatype identifier): The type of the key used to retrieve the contents of this attribute
  * `init` (any type): The initial value of the attribute
  * `of` (a datatype identifier): The type of the contents of this container attribute
  * `on_change` (any type): Provides a block of statements that will be executed whenever the value of the attribute changes
  * `parameter` (a label): Soon to be deprecated. Declare the parameter in an experiment instead
  * `size` (any type in [int, point]): 
  * `type` (a datatype identifier): The type of the attribute
  * `update` (any type): An expression that will be evaluated each cycle to compute a new value for the attribute
  * `value` (any type):  
 	
#### Definition

Allows to declare an attribute of a species or an experiment

#### Usages


#### Embedments
* The `Variable_container` statement is of type: **Variable (container)**
* The `Variable_container` statement can be embedded into: Species, Experiment, Model, 
* The `Variable_container` statement embeds statements: 