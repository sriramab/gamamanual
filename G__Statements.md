# Statements
---- 	
**This file is automatically generated from java files. Do Not Edit It.**

----

## Table of Contents
<wiki:toc max_depth="2" />
[=](#=), [assert](#assert), [chart](#chart), [diffusion](#diffusion), [equation](#equation), [plan](#plan), [run](#run), [setup](#setup), [solve](#solve), [test](#test), 


## Statements by kinds

* **Behavior**
  * [plan](#plan),  [test](#test),  
* **Layer**
  * [chart](#chart),  
* **Sequence of statements or action**
  * [equation](#equation),  [run](#run),  [setup](#setup),  
* **Single statement**
  * [=](#=),  [assert](#assert),  [diffusion](#diffusion),  [solve](#solve),  


## Statements by embedment

* **Behavior**
  * [diffusion](#diffusion), [run](#run), [solve](#solve), 
* **Experiment**
  * [setup](#setup), [test](#test), 
* **Model**
  * [equation](#equation), [run](#run), [setup](#setup), [test](#test), 
* **Sequence of statements or action**
  * [diffusion](#diffusion), [solve](#solve), 
* **Single statement**
  * [run](#run), 
* **Species**
  * [equation](#equation), [plan](#plan), [run](#run), [setup](#setup), [test](#test), 
* **display**
  * [chart](#chart), 
* **equation**
  * [=](#=), 
* **test**
  * [assert](#assert), 


## General syntax

A statement represents either a declaration or an imperative command. It consists in a keyword, followed by specific facets, some of them mandatory (in bold), some of them optional. One of the facet names can be ommitted (the one denoted as omissible). It has to be the first one.

```
statement_keyword expression1 facet2: expression2 ... ;
or
statement_keyword facet1: expression1 facet2: expression2 ...;
```

If the statement encloses other statements, it is called a **sequence statement**, and its sub-statements (either sequence statements or single statements) are declared between curly brackets, as in:

```
statement_keyword1 expression1 facet2: expression2... { // a sequence statement
     statement_keyword2 expression1 facet2: expression2...;  // a single statement
     statement_keyword3 expression1 facet2: expression2...;
}
```

[Top of the page](#table-of-contents)

	
<br/>
----
### = 
#### Facets 
		  
  * **`right`** (float), (omissible) : the right part of the equation (it is mandatory that it can be evaluate to a float  
  * **`left`** (any type): the left part of the equation (it should be a variable or a call to the diff() or diff2() operators)

#### Embedments
* The `=` statement is of type: **Single statement**
* The `=` statement can be embedded into: equation, 
* The `=` statement embeds statements:  
 	
#### Definition

Allows to implement an equation in the form function(n, t) = expression. The left function is only here as a placeholder for enabling a simpler syntax and grabbing the variable as its left member.

### Usages

* The syntax of the = statement is a bit different from the other statements. It hase to be used as follows (in an equation):
```float t;
float S;
float I;
equation SI { 
   diff(S,t) = (- 0.3 * S * I / 100);
   diff(I,t) = (0.3 * S * I / 100);
} 
 ```
    
* See also: [equation](#equation), [solve](#solve), 

[Top of the page](#table-of-contents)
	
<br/>
----
### assert 
#### Facets 
		  
  * **`value`** (any type), (omissible) : the value that is evaluated and compared to other facets
  * `equals` (any type): an expresion, assert tests whether the value is equals to this expression
  * `is_not` (any type): an expression, assert tests whether the value is not equals to this expression
  * `raises` (an identifier): "error" or "warning", used in testing what raises the evaluation of the value: expresion

#### Embedments
* The `assert` statement is of type: **Single statement**
* The `assert` statement can be embedded into: test, 
* The `assert` statement embeds statements:  
 	
#### Definition

Allows to check whether the evaluation of a given expression fulfils a given condition. If it is not fulfilled, an exception is raised.

### Usages

* if the equals: facet is used, the equality between the evaluation of expressions in the value: and in the equals: facets is tested
```assert (2+2) equals: 4;
 ```

* if the is_not: facet is used, the inequality between the evaluation of expressions in the value: and in the equals: facets is tested
```assert self is_not: nil;
 ```

* if the raises: facet is used with either "warning" or "error", the statement tests whether the evaluation of the value: expression raises an error (resp. a warning)
```int z <- 0;
assert (3/z) raises: "error";
 ```
    
* See also: [test](#test), [setup](#setup), 

[Top of the page](#table-of-contents)
	
<br/>
----
### chart 
#### Facets 
		  
  * **`name`** (a label), (omissible) : the identifier of the chart layer
  * `axes` (rgb): the axis color
  * `background` (rgb): the background color
  * `color` (rgb): 
  * `gap` (float): 
  * `label_font` (string): 
  * `label_font_size` (int): 
  * `label_font_style` (an identifier), takes values in: {plain, bold, italic}: the style used to display labels
  * `legend_font` (string): 
  * `legend_font_size` (int): 
  * `legend_font_style` (an identifier), takes values in: {plain, bold, italic}: the style used to display legend
  * `position` (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greter than 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.
  * `size` (point): the layer resize factor: {1,1} refers to the original size whereas {0.5,0.5} divides by 2 the height and the width of the layer. In case of a 3D layer, a 3D point can be used (note that {1,1} is equivalent to {1,1,0}, so a resize of a layer containing 3D objects with a 2D points will remove the elevation)
  * `style` (an identifier), takes values in: {exploded, 3d, stack, bar}: 
  * `tick_font` (string): 
  * `tick_font_size` (int): 
  * `tick_font_style` (an identifier), takes values in: {plain, bold, italic}: the style used to display ticks
  * `timexseries` (list): for series charts, change the default time serie (simulation cycle) for an other value.
  * `title_font` (string): 
  * `title_font_size` (int): 
  * `title_font_style` (an identifier), takes values in: {plain, bold, italic}: the style used to display titles
  * `transparency` (float): the style of the chart
  * `type` (an identifier), takes values in: {xy, scatter, histogram, series, pie, box_whisker}: the type of chart. It could be histogram, series, xy, pie or box whisker. The difference between series and xy is that the former adds an implicit x-axis that refers to the numbers of cycles, while the latter considers the first declaration of data to be its x-axis.
  * `x_range` (any type in [float, int, point]): range of the x-axis. Can be a number (which will set the axis total range) or a point (which will set the min and max of the axis).
  * `x_tick_unit` (float): the tick unit for the y-axis (distance between horyzontal lines and values on the left of the axis).
  * `y_range` (any type in [float, int, point]): range of the y-axis. Can be a number (which will set the axis total range) or a point (which will set the min and max of the axis).
  * `y_tick_unit` (float): the tick unit for the x-axis (distance between vertical lines and values bellow the axis).

#### Embedments
* The `chart` statement is of type: **Layer**
* The `chart` statement can be embedded into: display, 
* The `chart` statement embeds statements:  
 	
#### Definition

`chart` allows modeler to display a chart: this enables to display specific values of the model at each iteration. GAMA can display various chart types: time series (series), pie charts (pie) and histograms (histogram).

### Usages

* The general syntax is:
```display chart_display {
   chart "chart name" type: series [additional options] {
      [Set of data, datalists statements]
   }
}
 ```
    
* See also: [display](#display), [agents](#agents), [event](#event), [graphics](#graphics), [display_grid](#display_grid), [image](#image), [overlay](#overlay), [quadtree](#quadtree), [display_population](#display_population), [text](#text), 

[Top of the page](#table-of-contents)
	
<br/>
----
### diffusion 
#### Facets 
		  
  * **`var`** (an identifier), (omissible) : the variable to be diffused  
  * **`on`** (an identifier): the species (in general a grid), on which the diffusion will occur
  * `cycle_length` (int): the number of diffusion operation applied in one simulation step
  * `mask` (matrix): a matrix masking the diffusion (matrix created from a image for example)
  * `mat_diffu` (matrix): the diffusion matrix (can have any size)
  * `method` (an identifier), takes values in: {convolution, dot_product}: the diffusion method
  * `proportion` (float): a diffusion rate
  * `radius` (int): a diffusion radius

#### Embedments
* The `diffusion` statement is of type: **Single statement**
* The `diffusion` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `diffusion` statement embeds statements:  
 	
#### Definition

This statements allows a value to diffuse among a species on agents (generally on a grid) depending on a given diffusion matrix.

### Usages

* A basic example of diffusion of the variable phero defined in the species cells, given a diffusion matrix math_diff is:
```matrix<float> math_diff <- matrix([[1/9,1/9,1/9],[1/9,1/9,1/9],[1/9,1/9,1/9]]);
diffusion var: phero on: cells mat_diffu: math_diff;
 ```

* The diffusion can be masked by obstacles, created from a bitmap image:
```diffusion var: phero on: cells mat_diffu: math_diff mask: mymask;
 ```

* A convenient way to have an uniform diffusion in a given radius is (which is equivalent to the above diffusion):
```diffusion var: phero on: cells proportion: 1/9 radius: 1;
 ```


[Top of the page](#table-of-contents)
	
<br/>
----
### equation 
#### Facets 
		  
  * **`name`** (an identifier), (omissible) : the equation identifier
  * `params` (list): the list of pramameters used in predefined equation systems
  * `simultaneously` (list): a list of agents containing a system of equations (all systems will be solved simultaneously)
  * `type` (an identifier), takes values in: {SI, SIS, SIR, SIRS, SEIR, LV}: the choice of one among classical models (SI, SIS, SIR, SIRS, SEIR, LV)
  * `vars` (list): the list of variables used in predefined equation systems

#### Embedments
* The `equation` statement is of type: **Sequence of statements or action**
* The `equation` statement can be embedded into: Species, Model, 
* The `equation` statement embeds statements: [#= =],   
 	
#### Definition

The equation statement is used to create an equation system from several single equations.

### Usages

* The basic syntax to define an equation system is:
```float t;
float S;
float I;
equation SI { 
   diff(S,t) = (- 0.3 * S * I / 100);
   diff(I,t) = (0.3 * S * I / 100);
} 
 ```

* If the type: facet is used, a predefined equation system is defined using variables vars: and parameters params: in the right order. All possible predefined equation systems are the following ones (see [EquationPresentation161 EquationPresentation161] for precise definition of each classical equation system): 
```equation eqSI type: SI vars: [S,I,t] params: [N,beta];
equation eqSIS type: SIS vars: [S,I,t] params: [N,beta,gamma];
equation eqSIR type:SIR vars:[S,I,R,t] params:[N,beta,gamma];
equation eqSIRS type: SIRS vars: [S,I,R,t] params: [N,beta,gamma,omega,mu];
equation eqSEIR type: SEIR vars: [S,E,I,R,t] params: [N,beta,gamma,sigma,mu];
equation eqLV type: LV vars: [x,y,t] params: [alpha,beta,delta,gamma] ;
 ```

* If the simultaneously: facet is used, system of all the agents will be solved simultaneously.    
* See also: [=](#=), [solve](#solve), 

[Top of the page](#table-of-contents)
	
<br/>
----
### plan 
#### Facets 
		
  * `name` (an identifier), (omissible) : 
  * `finished_when` (boolean): 
  * `instantaneous` (boolean): 
  * `intention` (any type): 
  * `priority` (float): 
  * `when` (boolean): 

#### Embedments
* The `plan` statement is of type: **Behavior**
* The `plan` statement can be embedded into: Species, 
* The `plan` statement embeds statements: 

[Top of the page](#table-of-contents)
	
<br/>
----
### run 
#### Facets 
		  
  * **`experiment`** (string), (omissible) :   
  * **`of`** (string): 
  * `core` (int): 
  * `end_cycle` (int): 
  * `out` (string): 
  * `with_output` (map): 
  * `with_param` (map): 

#### Embedments
* The `run` statement is of type: **Sequence of statements or action**
* The `run` statement can be embedded into: Behavior, Single statement, Species, Model, 
* The `run` statement embeds statements: 

[Top of the page](#table-of-contents)
	
<br/>
----
### setup 
#### Facets 
		

#### Embedments
* The `setup` statement is of type: **Sequence of statements or action**
* The `setup` statement can be embedded into: Species, Experiment, Model, 
* The `setup` statement embeds statements:  
 	
#### Definition

The setup statement is used to define the set of instructions that will be executed before every [#test test].

### Usages

* As every test should be independant from the others, the setup will mainly contain initialization of variables that will be used in each test.
```species Tester {
    int val_to_test;

    setup {
        val_to_test <- 0;
    }

    test t1 {
       // [set of instructions, including asserts]
    }
}
 ```
    
* See also: [test](#test), [assert](#assert), 

[Top of the page](#table-of-contents)
	
<br/>
----
### solve 
#### Facets 
		  
  * **`equation`** (an identifier), (omissible) : the equation system identifier to be numerically solved
  * `cycle_length` (int): length of simulation cycle which will be synchronize with step of integrator (default value: 1)
  * `discretizing_step` (int): number of discret beside 2 step of simulation (default value: 0)
  * `integrated_times` (list): time interval inside integration process
  * `integrated_values` (list): list of variables's value inside integration process
  * `max_step` (float): maximal step, (used with dp853 method only), (sign is irrelevant, regardless of integration direction, forward or backward), the last step can be smaller than this value
  * `method` (an identifier), takes values in: {rk4, dp853}: integrate method (can be only "rk4" or "dp853") (default value: "rk4")
  * `min_step` (float): minimal step, (used with dp853 method only), (sign is irrelevant, regardless of integration direction, forward or backward), the last step can be smaller than this value
  * `scalAbsoluteTolerance` (float): allowed absolute error (used with dp853 method only)
  * `scalRelativeTolerance` (float): allowed relative error (used with dp853 method only)
  * `step` (float): integration step, use with most integrator methods (default value: 1)
  * `time_final` (float): target time for the integration (can be set to a value smaller than t0 for backward integration)
  * `time_initial` (float): initial time

#### Embedments
* The `solve` statement is of type: **Single statement**
* The `solve` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `solve` statement embeds statements:  
 	
#### Definition

Solves all equations which matched the given name, with all systems of agents that should solved simultaneously.

### Usages

* Other examples of use: 
```
solve SIR method: "rk4" step:0.001;
``` 
  

[Top of the page](#table-of-contents)
	
<br/>
----
### test 
#### Facets 
		
  * `name` (an identifier), (omissible) : identifier of the test

#### Embedments
* The `test` statement is of type: **Behavior**
* The `test` statement can be embedded into: Species, Experiment, Model, 
* The `test` statement embeds statements: [#assert assert],   
 	
#### Definition

The test statement allows modeler to define a set of assertions that will be tested. Before the execution of the embeded set of instructions, if a setup is defined in the species, model or experiment, it is executed. In a test, if one assertion fails, the evaluation of other assertions continue (if GAMA is configured in the preferences that the program does not stop at the first exception).

### Usages

* An example of use:
```species Tester {
    // set of attributes that will be used in test

    setup {
        // [set of instructions... in particular initializations]
    }

    test t1 {
       // [set of instructions, including asserts]
    }
}
 ```
    
* See also: [setup](#setup), [assert](#assert), 

[Top of the page](#table-of-contents)
	