# Statements
 	
---- 	
**This file is automatically generated from java files. Do Not Edit It.**

----

## Table of Contents
<wiki:toc max_depth="2" />
[](#), [](#), [](#), [=](#=), [action](#action), [add](#add), [agents](#agents), [annealing](#annealing), [ask](#ask), [aspect](#aspect), [assert](#assert), [break](#break), [capture](#capture), [chart](#chart), [create](#create), [data](#data), [datalist](#datalist), [default](#default), [diffusion](#diffusion), [display](#display), [display_grid](#display_grid), [display_population](#display_population), [do](#do), [draw](#draw), [else](#else), [enter](#enter), [equation](#equation), [error](#error), [event](#event), [exhaustive](#exhaustive), [exit](#exit), [experiment](#experiment), [export](#export), [genetic](#genetic), [graphics](#graphics), [hill_climbing](#hill_climbing), [if](#if), [image](#image), [inspect](#inspect), [let](#let), [loop](#loop), [match](#match), [migrate](#migrate), [monitor](#monitor), [output](#output), [output_file](#output_file), [overlay](#overlay), [parameter](#parameter), [permanent](#permanent), [plan](#plan), [put](#put), [quadtree](#quadtree), [reactive_tabu](#reactive_tabu), [reflex](#reflex), [release](#release), [remove](#remove), [return](#return), [run](#run), [save](#save), [save_batch](#save_batch), [set](#set), [setup](#setup), [signal](#signal), [simulate](#simulate), [solve](#solve), [species](#species), [state](#state), [status](#status), [switch](#switch), [tabu](#tabu), [task](#task), [test](#test), [text](#text), [trace](#trace), [transition](#transition), [user_command](#user_command), [user_init](#user_init), [user_input](#user_input), [user_panel](#user_panel), [using](#using), [warn](#warn), [write](#write), 


## Statements by kinds

* **Batch method**
  * [annealing](#annealing),  [exhaustive](#exhaustive),  [genetic](#genetic),  [hill_climbing](#hill_climbing),  [reactive_tabu](#reactive_tabu),  [save_batch](#save_batch),  [tabu](#tabu),  
* **Behavior**
  * [aspect](#aspect),  [plan](#plan),  [reflex](#reflex),  [state](#state),  [task](#task),  [test](#test),  [user_init](#user_init),  [user_panel](#user_panel),  
* **Experiment**
  * [experiment](#experiment),  
* **Layer**
  * [agents](#agents),  [chart](#chart),  [display_grid](#display_grid),  [display_population](#display_population),  [event](#event),  [graphics](#graphics),  [image](#image),  [overlay](#overlay),  [quadtree](#quadtree),  [text](#text),  
* **Output**
  * [display](#display),  [inspect](#inspect),  [monitor](#monitor),  [output](#output),  [output_file](#output_file),  [permanent](#permanent),  
* **Parameter**
  * [parameter](#parameter),  
* **Sequence of statements or action**
  * [action](#action),  [ask](#ask),  [capture](#capture),  [create](#create),  [default](#default),  [else](#else),  [enter](#enter),  [equation](#equation),  [exit](#exit),  [if](#if),  [loop](#loop),  [match](#match),  [migrate](#migrate),  [release](#release),  [run](#run),  [setup](#setup),  [switch](#switch),  [trace](#trace),  [transition](#transition),  [user_command](#user_command),  [using](#using),  
* **Single statement**
  * [=](#=),  [add](#add),  [assert](#assert),  [break](#break),  [data](#data),  [datalist](#datalist),  [diffusion](#diffusion),  [do](#do),  [draw](#draw),  [error](#error),  [export](#export),  [let](#let),  [put](#put),  [remove](#remove),  [return](#return),  [save](#save),  [set](#set),  [simulate](#simulate),  [solve](#solve),  [status](#status),  [user_input](#user_input),  [warn](#warn),  [write](#write),  
* **Species**
  * [species](#species),  
* **Variable (container)**
  * [](#),  
* **Variable (number)**
  * [](#),  
* **Variable (regular)**
  * [](#),  
* **Variable (signal)**
  * [signal](#signal),  


## Statements by embedment

* **Behavior**
  * [add](#add), [ask](#ask), [capture](#capture), [create](#create), [diffusion](#diffusion), [do](#do), [error](#error), [if](#if), [let](#let), [loop](#loop), [migrate](#migrate), [put](#put), [release](#release), [remove](#remove), [return](#return), [run](#run), [save](#save), [set](#set), [simulate](#simulate), [solve](#solve), [status](#status), [switch](#switch), [trace](#trace), [transition](#transition), [using](#using), [warn](#warn), [write](#write), 
* **Environment**
  * [species](#species), 
* **Experiment**
  * [](#), [](#), [](#), [action](#action), [annealing](#annealing), [exhaustive](#exhaustive), [export](#export), [genetic](#genetic), [hill_climbing](#hill_climbing), [output](#output), [parameter](#parameter), [permanent](#permanent), [reactive_tabu](#reactive_tabu), [reflex](#reflex), [save_batch](#save_batch), [setup](#setup), [simulate](#simulate), [state](#state), [tabu](#tabu), [task](#task), [test](#test), [user_command](#user_command), [user_init](#user_init), [user_panel](#user_panel), 
* **Layer**
  * [draw](#draw), [error](#error), [if](#if), [let](#let), [loop](#loop), [status](#status), [switch](#switch), [trace](#trace), [warn](#warn), [write](#write), 
* **Model**
  * [](#), [](#), [](#), [action](#action), [aspect](#aspect), [equation](#equation), [experiment](#experiment), [output](#output), [reflex](#reflex), [run](#run), [setup](#setup), [species](#species), [state](#state), [task](#task), [test](#test), [user_command](#user_command), [user_init](#user_init), [user_panel](#user_panel), 
* **Sequence of statements or action**
  * [add](#add), [ask](#ask), [break](#break), [capture](#capture), [create](#create), [data](#data), [datalist](#datalist), [diffusion](#diffusion), [do](#do), [draw](#draw), [error](#error), [if](#if), [let](#let), [loop](#loop), [migrate](#migrate), [put](#put), [release](#release), [remove](#remove), [return](#return), [save](#save), [set](#set), [simulate](#simulate), [solve](#solve), [status](#status), [switch](#switch), [trace](#trace), [transition](#transition), [using](#using), [warn](#warn), [write](#write), 
* **Single statement**
  * [run](#run), 
* **Species**
  * [](#), [](#), [](#), [action](#action), [aspect](#aspect), [equation](#equation), [plan](#plan), [reflex](#reflex), [run](#run), [setup](#setup), [signal](#signal), [simulate](#simulate), [species](#species), [state](#state), [task](#task), [test](#test), [user_command](#user_command), [user_init](#user_init), [user_panel](#user_panel), 
* **action**
  * [return](#return), 
* **aspect**
  * [draw](#draw), 
* **chart**
  * [add](#add), [ask](#ask), [data](#data), [datalist](#datalist), [do](#do), [put](#put), [remove](#remove), [set](#set), [simulate](#simulate), [using](#using), 
* **display**
  * [agents](#agents), [chart](#chart), [display_grid](#display_grid), [display_population](#display_population), [event](#event), [graphics](#graphics), [image](#image), [overlay](#overlay), [quadtree](#quadtree), [text](#text), 
* **display_population**
  * [display_population](#display_population), 
* **equation**
  * [=](#=), 
* **fsm**
  * [state](#state), [user_panel](#user_panel), 
* **if**
  * [else](#else), 
* **output**
  * [display](#display), [inspect](#inspect), [monitor](#monitor), [output_file](#output_file), 
* **permanent**
  * [display](#display), [inspect](#inspect), [monitor](#monitor), [output_file](#output_file), 
* **probabilistic_tasks**
  * [task](#task), 
* **sorted_tasks**
  * [task](#task), 
* **state**
  * [enter](#enter), [exit](#exit), 
* **switch**
  * [default](#default), [match](#match), 
* **test**
  * [assert](#assert), 
* **user_command**
  * [user_input](#user_input), 
* **user_first**
  * [user_panel](#user_panel), 
* **user_init**
  * [user_panel](#user_panel), 
* **user_last**
  * [user_panel](#user_panel), 
* **user_only**
  * [user_panel](#user_panel), 
* **user_panel**
  * [user_command](#user_command), 
* **weighted_tasks**
  * [task](#task), 


## General syntax

A statement represents either a declaration or an imperative command. It consists in a keyword, followed by specific facets, some of them mandatory (in bold), some of them optional. One of the facet names can be ommitted (the one denoted as omissible). It has to be the first one.

```
statement_keyword expression1 facet2: expression2 ... ;
or
statement_keyword facet1: expression1 facet2: expression2 ...;
```

If the statement encloses other statements, it is called a **sequence statement**, and its sub-statements (either sequence statements or single statements) are declared between curly brackets, as in:

```
statement_keyword1 expression1 facet2: expression2... { // a sequence statement
     statement_keyword2 expression1 facet2: expression2...;  // a single statement
     statement_keyword3 expression1 facet2: expression2...;
}
```

[Top of the page](#table-of-contents)

	

----
###  
#### Facets 
		  
  * **`name`** (a new identifier), (omissible) : The name of the attribute
  * `among` (list): A list of constant values among which the attribute can take its value
  * `category` (a label): Soon to be deprecated. Declare the parameter in an experiment instead
  * `const` (boolean): Indicates whether this attribute can be subsequently modified or not
  * `function` (any type in [int, float]): Used to specify an expression that will be evaluated each time the attribute is accessed. This facet is incompatible with both 'init:' and 'update:'
  * `init` (any type in [int, float]): The initial value of the attribute
  * `max` (any type in [int, float]): The maximum value this attribute can take.
  * `min` (any type in [int, float]): The minimum value this attribute can take
  * `parameter` (a label): Soon to be deprecated. Declare the parameter in an experiment instead
  * `step` (int): 
  * `type` (a datatype identifier): The type of the attribute, either 'int' or 'float'
  * `update` (any type in [int, float]): An expression that will be evaluated each cycle to compute a new value for the attribute
  * `value` (any type in [int, float]): 

#### Embedments
* The `` statement is of type: **Variable (number)**
* The `` statement can be embedded into: Species, Experiment, Model, 
* The `` statement embeds statements: 

[Top of the page](#table-of-contents)
	

----
###  
#### Facets 
		  
  * **`name`** (a new identifier), (omissible) : The name of the attribute
  * `among` (list): A list of constant values among which the attribute can take its value
  * `category` (a label): Soon to be deprecated. Declare the parameter in an experiment instead
  * `const` (boolean): Indicates whether this attribute can be subsequently modified or not
  * `function` (any type): Used to specify an expression that will be evaluated each time the attribute is accessed. This facet is incompatible with both 'init:' and 'update:'
  * `index` (a datatype identifier): 
  * `init` (any type): The initial value of the attribute
  * `of` (a datatype identifier): 
  * `parameter` (a label): Soon to be deprecated. Declare the parameter in an experiment instead
  * `type` (a datatype identifier): 
  * `update` (any type): An expression that will be evaluated each cycle to compute a new value for the attribute
  * `value` (any type): 

#### Embedments
* The `` statement is of type: **Variable (regular)**
* The `` statement can be embedded into: Species, Experiment, Model, 
* The `` statement embeds statements: 

[Top of the page](#table-of-contents)
	

----
###  
#### Facets 
		  
  * **`name`** (a new identifier), (omissible) : The name of the attribute
  * `category` (a label): Soon to be deprecated. Declare the parameter in an experiment instead
  * `const` (boolean): Indicates whether this attribute can be subsequently modified or not
  * `fill_with` (any type): 
  * `function` (any type): Used to specify an expression that will be evaluated each time the attribute is accessed. This facet is incompatible with both 'init:' and 'update:'
  * `index` (a datatype identifier): 
  * `init` (any type): The initial value of the attribute
  * `of` (a datatype identifier): 
  * `parameter` (a label): Soon to be deprecated. Declare the parameter in an experiment instead
  * `size` (any type in [int, point]): 
  * `type` (a datatype identifier): 
  * `update` (any type): An expression that will be evaluated each cycle to compute a new value for the attribute
  * `value` (any type): 

#### Embedments
* The `` statement is of type: **Variable (container)**
* The `` statement can be embedded into: Species, Experiment, Model, 
* The `` statement embeds statements: 

[Top of the page](#table-of-contents)
	

----
### = 
#### Facets 
		  
  * **`right`** (float), (omissible) : the right part of the equation (it is mandatory that it can be evaluate to a float  
  * **`left`** (any type): the left part of the equation (it should be a variable or a call to the diff() or diff2() operators)

#### Embedments
* The `=` statement is of type: **Single statement**
* The `=` statement can be embedded into: equation, 
* The `=` statement embeds statements:  
 	
#### Definition

Allows to implement an equation in the form function(n, t) = expression. The left function is only here as a placeholder for enabling a simpler syntax and grabbing the variable as its left member.

### Usages

* The syntax of the = statement is a bit different from the other statements. It hase to be used as follows (in an equation):
```float t;
float S;
float I;
equation SI { 
   diff(S,t) = (- 0.3 * S * I / 100);
   diff(I,t) = (0.3 * S * I / 100);
} 
 ```
    
* See also: [equation](#equation), [solve](#solve), 

[Top of the page](#table-of-contents)
	

----
### action 
#### Facets 
		  
  * **`name`** (an identifier), (omissible) : identifier of the action
  * `index` (a datatype identifier): if the action returns a map, the type of its keys
  * `of` (a datatype identifier): if the action returns a container, the type of its elements
  * `type` (a datatype identifier): the action returned type
  * `virtual` (boolean): whether the action is virtual (defined without a set of instructions) (false by default)

#### Embedments
* The `action` statement is of type: **Sequence of statements or action**
* The `action` statement can be embedded into: Species, Experiment, Model, 
* The `action` statement embeds statements: [#return return],   
 	
#### Definition

Allows to define in a species, model or experiment a new action that can be called elsewhere.

### Usages

* The simplest syntax to define an action that does not take any parameter and does not return anything is:
```action simple_action {
   // [set of statements]
}
 ```

* If the action needs some parameters, they can be specified betwee, braquets after the identifier of the action:
```action action_parameters(int i, string s){
   // [set of statements using i and s]
}
 ```

* If the action returns any value, the returned type should be used instead of the "action" keyword. A return statement inside the body of the action statement is mandatory.
```int action_return_val(int i, string s){
   // [set of statements using i and s]
   return i + i;
}
 ```

* If virtual: is true, then the action is abstract, which means that the action is defined without body. A species containing at least one abstract action is abstract. Agents of this species cannot be created. The common use of an abstract action is to define an action that can be used by all its sub-species, which should redefine all abstract actions and implements its body.
```species parent_species {
   int virtual_action(int i, string s);
}

species children parent: parent_species {
   int virtual_action(int i, string s) {
      return i + i;
   }
}
 ```
    
* See also: [do](#do), 

[Top of the page](#table-of-contents)
	

----
### add 
#### Facets 
		  
  * **`to`** (any type in [container, species, agent, geometry]): an expression that evaluates to a container
  * `item` (any type), (omissible) : any expression to add in the container
  * `all` (any type): Allows to either pass a container so as to add all its element, or 'true', if the item to add is already a container.
  * `at` (any type): position in the container of added element
  * `edge` (any type): a pair that will be added to a graph as an edge (if nodes do not exist, they are also added). Soon to be deprecated, please use 'add edge(..)' instead
  * `node` (any type): an expression that will be added to a graph as a node. Soon to be deprecated, please use 'add node(...)' instead
  * `vertex` (any type): 
  * `weight` (float): 

#### Embedments
* The `add` statement is of type: **Single statement**
* The `add` statement can be embedded into: chart, Behavior, Sequence of statements or action, 
* The `add` statement embeds statements:  
 	
#### Definition

Allows to add, i.e. to insert, a new element in a container (a list, matrix, map, ...).Incorrect use: The addition of a new element at a position out of the bounds of the container will produce a warning and let the container unmodified. If all: is specified, it has no effect if its argument is not a container, or if its argument is 'true' and the item to add is not a container. In that latter case

### Usages

* The new element can be added either at the end of the container or at a particular position.
```add expr to: expr_container;    // Add at the end
add expr at: expr to: expr_container;   // Add at position expr
 ```

* Case of a list, the expression in the facet at: should be an integer.
```list<int> workingList <- [];
add 0 at: 0 to: workingList ; 	// workingList equals [0]
add 10 at: 0 to: workingList ; 	// workingList equals [10,0]
add 20 at: 2 to: workingList ; 	// workingList equals [10,0,20]
add 50 to: workingList; 	// workingList equals [10,0,20,50]
add [60,70] all: true to: workingList; 	// workingList equals [10,0,20,50,60,70]
 ```

* Case of a map: As a map is basically a list of pairs key::value, we can also use the add statement on it. It is important to note that the behavior of the statement is slightly different, in particular in the use of the at facet, which denotes the key of the pair.
```map<string,string> workingMap <- [];
add "val1" at: "x" to: workingMap; 	// workingMap equals ["x"::"val1"]
 ```

* If the at facet is ommitted, a pair expr_item::expr_item will be added to the map. An important exception is the case where the expr_item is a pair: in this case the pair is added.
```add "val2" to: workingMap; 	// workingMap equals ["x"::"val1", "val2"::"val2"]
add "5"::"val4" to: workingMap;  	// workingMap equals ["x"::"val1", "val2"::"val2", "5"::"val4"]
 ```

* Notice that, as the key should be unique, the addition of an item at an existing position (i.e. existing key) will only modify the value associated with the given key.
```add "val3" at: "x" to: workingMap; 	// workingMap equals ["x"::"val3", "val2"::"val2", "5"::"val4"]
 ```

* On a map, the all facet will add all value of a container  in the map (so as pair val_cont::val_cont)
```add ["val4","val5"] all: true at: "x" to: workingMap; 	// workingMap equals ["x"::"val3", "val2"::"val2", "5"::"val4","val4"::"val4","val5"::"val5"]
 ```

* In case of a graph, we can use the facets `node`, `edge` and `weight` to add a node, an edge or weights to the graph. However, these facets are now considered as deprecated, and it is advised to use the various edge(), node(), edges(), nodes() operators, which can build the correct objects to add to the graph 
```graph g <- as_edge_graph([{1,5}::{12,45}]);
add edge: {1,5}::{2,3} to: g;
list var <- g.vertices; 	// var equals [{1,5},{12,45},{2,3}]
list var <- g.edges; 	// var equals [polyline({1.0,5.0}::{12.0,45.0}),polyline({1.0,5.0}::{2.0,3.0})]
add node: {5,5} to: g;
list var <- g.vertices; 	// var equals [{1.0,5.0},{12.0,45.0},{2.0,3.0},{5.0,5.0}]
list var <- g.edges; 	// var equals [polyline({1.0,5.0}::{12.0,45.0}),polyline({1.0,5.0}::{2.0,3.0})]
 ```

* Case of a matrix: this statement can not be used on matrix. Please refer to the statement put.    
* See also: [put](#put), [remove](#remove), 

[Top of the page](#table-of-contents)
	

----
### agents 
#### Facets 
		  
  * **`name`** (a label), (omissible) : identifier of the layer  
  * **`value`** (container): the set of agents to display
  * `aspect` (an identifier): the name of the aspect that should be used to display the species
  * `fading` (boolean): Used in conjunction with 'trace:', allows to apply a fading effect to the previous traces. Default is false
  * `focus` (agent): the agent on with will be focus the camera (it is dynamically computed)
  * `position` (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greter than 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.
  * `refresh` (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, useful in case of agents that do not move)
  * `selectable` (boolean): Indicates whether the agents present on this layer are selectable by the user. Default is true
  * `size` (point): the layer resize factor: {1,1} refers to the original size whereas {0.5,0.5} divides by 2 the height and the width of the layer. In case of a 3D layer, a 3D point can be used (note that {1,1} is equivalent to {1,1,0}, so a resize of a layer containing 3D objects with a 2D points will remove the elevation)
  * `trace` (any type in [boolean, int]): Allows to aggregate the visualization of agents at each timestep on the display. Default is false. If set to an int value, only the last n-th steps will be visualized. If set to true, no limit of timesteps is applied.
  * `transparency` (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency)

#### Embedments
* The `agents` statement is of type: **Layer**
* The `agents` statement can be embedded into: display, 
* The `agents` statement embeds statements:  
 	
#### Definition

`agents` allows the modeler to display only the agents that fulfill a given condition.

### Usages

* The general syntax is:
```display my_display {
   agents layer_name value: expression [additional options];
}
 ```

* For instance, in a segregation model, `agents` will only display unhappy agents:
```display Segregation {
   agents agentDisappear value: people as list where (each.is_happy = false) aspect: with_group_color;
}
 ```
    
* See also: [display](#display), [chart](#chart), [event](#event), [graphics](#graphics), [display_grid](#display_grid), [image](#image), [overlay](#overlay), [quadtree](#quadtree), [display_population](#display_population), [text](#text), 

[Top of the page](#table-of-contents)
	

----
### annealing 
#### Facets 
		  
  * **`name`** (an identifier), (omissible) : 
  * `aggregation` (a label), takes values in: {min, max}: the agregation method
  * `maximize` (float): the value the algorithm tries to maximize
  * `minimize` (float): the value the algorithm tries to minimize
  * `nb_iter_cst_temp` (int): number of iterations per level of temperature
  * `temp_decrease` (float): temperature decrease coefficient
  * `temp_end` (float): final temperature
  * `temp_init` (float): initial temperature

#### Embedments
* The `annealing` statement is of type: **Batch method**
* The `annealing` statement can be embedded into: Experiment, 
* The `annealing` statement embeds statements:  
 	
#### Definition

This algorithm is an implementation of the Simulated Annealing algorithm. See the wikipedia article and [batch161 the batch dedicated page].

### Usages

* As other batch methods, the basic syntax of the annealing statement uses `method annealing` instead of the expected `annealing name: id` : 
```method annealing [facet: value];
 ```

* For example: 
```method annealing temp_init: 100  temp_end: 1 temp_decrease: 0.5 nb_iter_cst_temp: 5 maximize: food_gathered;
 ```


[Top of the page](#table-of-contents)
	

----
### ask 
#### Facets 
		  
  * **`target`** (any type in [container, agent]), (omissible) : an expression that evaluates to an agent or a list of agents
  * `as` (species): an expression that evaluates to a species

#### Embedments
* The `ask` statement is of type: **Sequence of statements or action**
* The `ask` statement can be embedded into: chart, Behavior, Sequence of statements or action, 
* The `ask` statement embeds statements:  
 	
#### Definition

Allows an agent, the sender agent (that can be the [Sections161#global world agent]), to ask another (or other) agent(s) to perform a set of statements. If the value of the target facet is nil or empty, the statement is ignored.

### Usages

* Ask  a set of receiver agents, stored in a container, to perform a block of statements. The block is evaluated in the context of the agents' species
```ask ${receiver_agents} {
     ${cursor}
}
 ```

* Ask  one agent to perform a block of statements. The block is evaluated in the context of the agent's species
```ask ${one_agent} {
     ${cursor}
}
 ```

* If the species of the receiver agent(s) cannot be determined, it is possible to force it using the `as` facet. An error is thrown if an agent is not a direct or undirect instance of this species
```ask${receiver_agent(s)} as: ${a_species_expression} {
     ${cursor}
}
 ```

* To ask a set of agents to do something only if they belong to a given species, the `of_species` operator can be used. If none of the agents belong to the species, nothing happens
```ask ${receiver_agents} of_species ${species_name} {
     ${cursor}
}
 ```

* Any statement can be declared in the block statements. All the statements will be evaluated in the context of the receiver agent(s), as if they were defined in their species, which means that an expression like `self` will represent the receiver agent and not the sender. If the sender needs to refer to itself, some of its own attributes (or temporary variables) within the block statements, it has to use the keyword `myself`.
```species animal {
    float energy <- rnd (1000) min: 0.0 {
    reflex when: energy > 500 { // executed when the energy is above the given threshold
         list<animal> others <- (animal at_distance 5); // find all the neighbouring animals in a radius of 5 meters
         float shared_energy  <- (energy - 500) / length (others); // compute the amount of energy to share with each of them
         ask others { // no need to cast, since others has already been filtered to only include animals
              if (energy < 500) { // refers to the energy of each animal in others
                   energy <- energy + myself.shared_energy; // increases the energy of each animal
                   myself.energy <- myself.energy - myself.shared_energy; // decreases the energy of the sender
              }
         }
    }
}
 ```

* If the species of the receiver agent cannot be determined, it is possible to force it by casting the agent. Nothing happens if the agent cannot be casted to this species

[Top of the page](#table-of-contents)
	

----
### aspect 
#### Facets 
		
  * `name` (an identifier), (omissible) : identifier of the aspect (it can be used in a display to identify which aspect should be used for the given species)

#### Embedments
* The `aspect` statement is of type: **Behavior**
* The `aspect` statement can be embedded into: Species, Model, 
* The `aspect` statement embeds statements: [#draw draw],   
 	
#### Definition

Aspect statement is used to define a way to draw the current agent. Several aspects can be defined in one species. It can use attributes to customize each agent's aspect. The aspect is evaluate for each agent each time it has to be displayed.

### Usages

* An example of use of the aspect statement:
```species one_species {
	int a <- rnd(10);
	aspect aspect1 {
		if(a mod 2 = 0) { draw circle(a);}
		else {draw square(a);}
		draw text: "a= " + a color: #black size: 5;
	}
}
 ```


[Top of the page](#table-of-contents)
	

----
### assert 
#### Facets 
		  
  * **`value`** (any type), (omissible) : the value that is evaluated and compared to other facets
  * `equals` (any type): an expresion, assert tests whether the value is equals to this expression
  * `is_not` (any type): an expression, assert tests whether the value is not equals to this expression
  * `raises` (an identifier): "error" or "warning", used in testing what raises the evaluation of the value: expresion

#### Embedments
* The `assert` statement is of type: **Single statement**
* The `assert` statement can be embedded into: test, 
* The `assert` statement embeds statements:  
 	
#### Definition

Allows to check whether the evaluation of a given expression fulfils a given condition. If it is not fulfilled, an exception is raised.

### Usages

* if the equals: facet is used, the equality between the evaluation of expressions in the value: and in the equals: facets is tested
```assert (2+2) equals: 4;
 ```

* if the is_not: facet is used, the inequality between the evaluation of expressions in the value: and in the equals: facets is tested
```assert self is_not: nil;
 ```

* if the raises: facet is used with either "warning" or "error", the statement tests whether the evaluation of the value: expression raises an error (resp. a warning)
```int z <- 0;
assert (3/z) raises: "error";
 ```
    
* See also: [test](#test), [setup](#setup), 

[Top of the page](#table-of-contents)
	

----
### break 
#### Facets 
		

#### Embedments
* The `break` statement is of type: **Single statement**
* The `break` statement can be embedded into: Sequence of statements or action, 
* The `break` statement embeds statements:  
 	
#### Definition

`break` allows to interrupt the current sequence of statements.

### Usages


[Top of the page](#table-of-contents)
	

----
### capture 
#### Facets 
		  
  * **`target`** (any type in [agent, container]), (omissible) : an expression that is evaluated as an agent or a list of the agent to be captured
  * `as` (species): the species that the captured agent(s) will become, this is a micro-species of the calling agent's species
  * `returns` (a new identifier): a list of the newly captured agent(s)

#### Embedments
* The `capture` statement is of type: **Sequence of statements or action**
* The `capture` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `capture` statement embeds statements:  
 	
#### Definition

Allows an agent to capture other agent(s) as its micro-agent(s).

### Usages

* The preliminary for an agent A to capture an agent B as its micro-agent is that the A's species must defined a micro-species which is a sub-species of B's species (cf. [Species161#Nesting_species Nesting species]).
```species A {
...
}
species B {
...
   species C parent: A {
   ...
   }
...
}
 ```

* To capture all "A" agents as "C" agents, we can ask an "B" agent to execute the following statement:
```capture list(B) as: C;
 ```

* Deprecated writing:
```capture target: list (B) as: C;
 ```
    
* See also: [release](#release), 

[Top of the page](#table-of-contents)
	

----
### chart 
#### Facets 
		  
  * **`name`** (a label), (omissible) : the identifier of the chart layer
  * `axes` (rgb): the axis color
  * `background` (rgb): the background color
  * `color` (rgb): 
  * `gap` (float): 
  * `label_font` (string): 
  * `label_font_size` (int): 
  * `label_font_style` (an identifier), takes values in: {plain, bold, italic}: the style used to display labels
  * `legend_font` (string): 
  * `legend_font_size` (int): 
  * `legend_font_style` (an identifier), takes values in: {plain, bold, italic}: the style used to display legend
  * `position` (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greter than 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.
  * `size` (point): the layer resize factor: {1,1} refers to the original size whereas {0.5,0.5} divides by 2 the height and the width of the layer. In case of a 3D layer, a 3D point can be used (note that {1,1} is equivalent to {1,1,0}, so a resize of a layer containing 3D objects with a 2D points will remove the elevation)
  * `style` (an identifier), takes values in: {exploded, 3d, stack, bar}: 
  * `tick_font` (string): 
  * `tick_font_size` (int): 
  * `tick_font_style` (an identifier), takes values in: {plain, bold, italic}: the style used to display ticks
  * `timexseries` (list): for series charts, change the default time serie (simulation cycle) for an other value.
  * `title_font` (string): 
  * `title_font_size` (int): 
  * `title_font_style` (an identifier), takes values in: {plain, bold, italic}: the style used to display titles
  * `transparency` (float): the style of the chart
  * `type` (an identifier), takes values in: {xy, scatter, histogram, series, pie, box_whisker}: the type of chart. It could be histogram, series, xy, pie or box whisker. The difference between series and xy is that the former adds an implicit x-axis that refers to the numbers of cycles, while the latter considers the first declaration of data to be its x-axis.
  * `x_range` (any type in [float, int, point]): range of the x-axis. Can be a number (which will set the axis total range) or a point (which will set the min and max of the axis).
  * `x_tick_unit` (float): the tick unit for the y-axis (distance between horyzontal lines and values on the left of the axis).
  * `y_range` (any type in [float, int, point]): range of the y-axis. Can be a number (which will set the axis total range) or a point (which will set the min and max of the axis).
  * `y_tick_unit` (float): the tick unit for the x-axis (distance between vertical lines and values bellow the axis).

#### Embedments
* The `chart` statement is of type: **Layer**
* The `chart` statement can be embedded into: display, 
* The `chart` statement embeds statements: [#add add],  [#ask ask],  [#data data],  [#datalist datalist],  [#do do],  [#put put],  [#remove remove],  [#set set],  [#simulate simulate],  [#using using],   
 	
#### Definition

`chart` allows modeler to display a chart: this enables to display specific values of the model at each iteration. GAMA can display various chart types: time series (series), pie charts (pie) and histograms (histogram).

### Usages

* The general syntax is:
```display chart_display {
   chart "chart name" type: series [additional options] {
      [Set of data, datalists statements]
   }
}
 ```
    
* See also: [display](#display), [agents](#agents), [event](#event), [graphics](#graphics), [display_grid](#display_grid), [image](#image), [overlay](#overlay), [quadtree](#quadtree), [display_population](#display_population), [text](#text), 

[Top of the page](#table-of-contents)
	

----
### create 
#### Facets 
		
  * `species` (species), (omissible) : an expression that evaluates to a species, the species of created agents
  * `as` (species): 
  * `from` (any type): an expression that evaluates to a localized entity, a list of localized entities, a string (the path of a shapefile, a .csv, a .asc or a OSM file) or a container returned by a request to a database
  * `header` (boolean): an expression that evaluates to a boolean, when creating agents from csv file, specify whether the file header is loaded
  * `number` (int): an expression that evaluates to an int, the number of created agents
  * `returns` (a new identifier): a new temporary variable name containing the list of created agents (a lsit even if only one agent has been created)
  * `with` (map): an expression that evaluates to a map, for each pair the key is a species attribute and the value the assigned value

#### Embedments
* The `create` statement is of type: **Sequence of statements or action**
* The `create` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `create` statement embeds statements:  
 	
#### Definition

Allows an agent to create `number` agents of species `species`, to create agents of species `species` from a shapefile or to create agents of species `species` from one or several localized entities (discretization of the localized entity geometries).

### Usages

* Its simple syntax to create `an_int` agents of species `a_species` is:
```create a_species number: an_int;
create species_of(self) number: 5 returns: list5Agents;
5
 ```

* In GAML modelers can create agents of species `a_species  (with two attributes `type` and `nature` with types corresponding to the types of the shapefile attributes) from a shapefile `the_shapefile` while reading attributes 'TYPE_OCC' and 'NATURE' of the shapefile. One agent will be created by object contained in the shapefile:
```create a_species from: the_shapefile with: [type:: 'TYPE_OCC', nature::'NATURE'];
 ```

* In order to create agents from a .csv file, facet `header` can be used to specified whether we can use columns header:
```create toto from: "toto.csv" header: true with:[att1::read("NAME"), att2::read("TYPE")];
or
create toto from: "toto.csv" with:[att1::read(0), att2::read(1)]; //with read(int), the index of the column
 ```

* Similarly to the creation from shapefile, modelers can create agents from a set of geometries. In this case, one agent per geometry will be created (with the geometry as shape)
```create species_of(self) from: [square(4),circle(4)]; 	// 2 agents have been created, with shapes respectively square(4) and circle(4)
 ```

* Created agents are initialized following the rules of their species. If one wants to refer to them after the statement is executed, the returns keyword has to be defined: the agents created will then be referred to by the temporary variable it declares. For instance, the following statement creates 0 to 4 agents of the same species as the sender, and puts them in the temporary variable children for later use.
```create species (self) number: rnd (4) returns: children;
ask children {
        // ...
}
 ```

* If one wants to specify a special initialization sequence for the agents created, create provides the same possibilities as ask. This extended syntax is:
```create a_species number: an_int {
     [statements]
}
 ```

* The same rules as in ask apply. The only difference is that, for the agents created, the assignments of variables will bypass the initialization defined in species. For instance:
```create species(self) number: rnd (4) returns: children {
     set location <- myself.location + {rnd (2), rnd (2)}; // tells the children to be initially located close to me
     set parent <- myself; // tells the children that their parent is me (provided the variable parent is declared in this species) 
}
 ```

* Desprecated uses: 
```// Simple syntax
create species: a_species number: an_int;

 ```

* If `number` equals 0 or species is not a species, the statement is ignored.

[Top of the page](#table-of-contents)
	

----
### data 
#### Facets 
		  
  * **`value`** (any type in [float, point, list]): 
  * `legend` (string), (omissible) : 
  * `color` (rgb): 
  * `fill` (boolean): 
  * `line_visible` (boolean): 
  * `marker` (boolean): 
  * `marker_shape` (an identifier), takes values in: {marker_empty, marker_sqaure, marker_square, marker_up_triangle, marker_diamond, marker_hor_rectangle, marker_down_triangle, marker_hor_ellipse, marker_right_triangle, marker_vert_rectangle, marker_left_triangle}: 
  * `name` (an identifier): 
  * `style` (an identifier), takes values in: {line, whisker, area, bar, dot, step, spline, stack, 3d, ring, exploded}: 

#### Embedments
* The `data` statement is of type: **Single statement**
* The `data` statement can be embedded into: chart, Sequence of statements or action, 
* The `data` statement embeds statements: 

[Top of the page](#table-of-contents)
	

----
### datalist 
#### Facets 
		  
  * **`value`** (list): the values to display. Has to be a List of List. Each element can be a number (series/histogram) or a list with two values (XY chart)
  * `legend` (list), (omissible) : the name of the series: a list of strings (can be a variable with dynamic names)
  * `categoriesnames` (list): the name of categories (can be a variable with dynamic names)
  * `color` (list): list of colors
  * `fill` (boolean): 
  * `inverse_series_categories` (boolean): reverse the order of series/categories ([[1,2],[3,4],[5,6]] --> [[1,3,5],[2,4,6]]. May be useful when it is easier to construct one list over the other.
  * `line_visible` (boolean): 
  * `marker` (boolean): 
  * `style` (an identifier), takes values in: {line, whisker, area, bar, dot, step, spline, stack, 3d, ring, exploded}: series style

#### Embedments
* The `datalist` statement is of type: **Single statement**
* The `datalist` statement can be embedded into: chart, Sequence of statements or action, 
* The `datalist` statement embeds statements: 

[Top of the page](#table-of-contents)
	

----
### default 
#### Facets 
		
  * `value` (any type), (omissible) : 

#### Embedments
* The `default` statement is of type: **Sequence of statements or action**
* The `default` statement can be embedded into: switch, 
* The `default` statement embeds statements:  
 	
#### Definition

Used in a switch match structure, the block prefixed by default is executed only if no other block has matched (otherwise it is not).

### Usages
    
* See also: [switch](#switch), [match](#match), 

[Top of the page](#table-of-contents)
	

----
### diffusion 
#### Facets 
		  
  * **`var`** (an identifier), (omissible) : the variable to be diffused  
  * **`on`** (an identifier): the species (in general a grid), on which the diffusion will occur
  * `cycle_length` (int): the number of diffusion operation applied in one simulation step
  * `mask` (matrix): a matrix masking the diffusion (matrix created from a image for example)
  * `mat_diffu` (matrix): the diffusion matrix (can have any size)
  * `method` (an identifier), takes values in: {convolution, dot_product}: the diffusion method
  * `proportion` (float): a diffusion rate
  * `radius` (int): a diffusion radius

#### Embedments
* The `diffusion` statement is of type: **Single statement**
* The `diffusion` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `diffusion` statement embeds statements:  
 	
#### Definition

This statements allows a value to diffuse among a species on agents (generally on a grid) depending on a given diffusion matrix.

### Usages

* A basic example of diffusion of the variable phero defined in the species cells, given a diffusion matrix math_diff is:
```matrix<float> math_diff <- matrix([[1/9,1/9,1/9],[1/9,1/9,1/9],[1/9,1/9,1/9]]);
diffusion var: phero on: cells mat_diffu: math_diff;
 ```

* The diffusion can be masked by obstacles, created from a bitmap image:
```diffusion var: phero on: cells mat_diffu: math_diff mask: mymask;
 ```

* A convenient way to have an uniform diffusion in a given radius is (which is equivalent to the above diffusion):
```diffusion var: phero on: cells proportion: 1/9 radius: 1;
 ```


[Top of the page](#table-of-contents)
	

----
### display 
#### Facets 
		  
  * **`name`** (a label), (omissible) : the identifier of the display
  * `ambient_light` (any type in [int, rgb]): Allows to define the value of the ambient light either using an int (ambient_light:(125)) or a rgb color ((ambient_light:rgb(255,255,255)). default is rgb(125,125,125)
  * `autosave` (any type in [boolean, point]): Allows to save this display on disk. A value of true/false will save it at a resolution of 500x500. A point can be passed to personalize these dimensions
  * `background` (rgb): Allows to fill the background of the display with a specific color
  * `camera_look_pos` (point): Allows to define the direction of the camera
  * `camera_pos` (any type in [point, agent]): Allows to define the position of the camera
  * `camera_up_vector` (point): Allows to define the orientation of the camera
  * `diffuse_light` (any type in [int, rgb]): Allows to define the value of the diffuse light either using an int (diffuse_light:(125)) or a rgb color ((diffuse_light:rgb(255,255,255)). default is rgb(125,125,125)
  * `diffuse_light_pos` (point): Allows to define the position of the diffuse light either using an point (diffuse_light_pos:{x,y,z}). default is {world.shape.width/2,world.shape.height/2,world.shape.width`*`2}
  * `draw_diffuse_light` (boolean): Allows to enable/disable the drawing of the diffuse light. Default is false
  * `draw_env` (boolean): Allows to enable/disable the drawing of the world shape and the ordinate axes. Default can be configured in Preferences
  * `focus` (geometry): the geometry (or agent) on which the displau will (dynamically) focus
  * `light` (boolean): Allows to enable/disable the light. Default is true
  * `orthographic_projection` (boolean): Allows to enable/disable the orthographic projection. Default can be configured in Preferences
  * `output3D` (any type in [boolean, point]): 
  * `polygonmode` (boolean): 
  * `refresh` (boolean): Indicates the condition under which this output should be refreshed (default is true)
  * `refresh_every` (int): Allows to refresh the display every n time steps (default is 1)
  * `scale` (any type in [boolean, float]): Allows to display a scale bar in the overlay. Accepts true/false or an unit name
  * `show_fps` (boolean): Allows to enable/disable the drawing of the number of frames per second
  * `tesselation` (boolean): 
  * `trace` (any type in [boolean, int]): Allows to aggregate the visualization of agents at each timestep on the display. Default is false. If set to an int value, only the last n-th steps will be visualized. If set to true, no limit of timesteps is applied. This facet can also be applied to individual layers
  * `type` (a label): Allows to use either Java2D (for planar models) or OpenGL (for 3D models) as the rendering subsystem
  * `z_fighting` (boolean): Allows to alleviate a problem where agents at the same z would overlap each other in random ways

#### Embedments
* The `display` statement is of type: **Output**
* The `display` statement can be embedded into: output, permanent, 
* The `display` statement embeds statements: [#agents agents],  [#chart chart],  [#display_grid display_grid],  [#display_population display_population],  [#event event],  [#graphics graphics],  [#image image],  [#overlay overlay],  [#quadtree quadtree],  [#text text],   
 	
#### Definition

A display refers to a independent and mobile part of the interface that can display species, images, texts or charts.

### Usages

* The general syntax is:
```display my_display [additional options] { ... }
 ```

* Each display can include different layers (like in a GIS).
```display gridWithElevationTriangulated type: opengl ambient_light: 100 {
	grid cell elevation: true triangulation: true;
	species people aspect: base;
}
 ```


[Top of the page](#table-of-contents)
	

----
### display_grid 
#### Facets 
		  
  * **`species`** (species), (omissible) : the species of the agents in the grid
  * `dem` (matrix): 
  * `draw_as_dem` (boolean): 
  * `elevation` (any type in [matrix, float, int, boolean]): Allows to specify the elevation of each cell, if any. Can be a matrix of float (provided it has the same size than the grid), an int or float variable of the grid species, or simply true (in which case, the variable called 'grid_value' is used to compute the elevation of each cell)
  * `grayscale` (boolean): if true, givse a grey value to each polygon depending on its elevation (false by default)
  * `lines` (rgb): the color to draw lines (borders of cells)
  * `position` (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greter than 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.
  * `refresh` (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, usefull in case of agents that do not move)
  * `selectable` (boolean): Indicates whether the agents present on this layer are selectable by the user. Default is true
  * `size` (point): the layer resize factor: {1,1} refers to the original size whereas {0.5,0.5} divides by 2 the height and the width of the layer. In case of a 3D layer, a 3D point can be used (note that {1,1} is equivalent to {1,1,0}, so a resize of a layer containing 3D objects with a 2D points will remove the elevation)
  * `text` (boolean): specify whether the attribute used to compute the elevation is displayed on each cells (false by default)
  * `texture` (any type in [boolean, file]): the file object containing the texture image to be applied on the grid
  * `transparency` (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency)
  * `triangulation` (boolean): specifies whther the cells will be triangulated: if it is false, they will be displayed as horizontal squares at a given elevation, whereas if it is true, cells will be triangulated and linked to neighbors in order to have a continuous surface (false by default)

#### Embedments
* The `display_grid` statement is of type: **Layer**
* The `display_grid` statement can be embedded into: display, 
* The `display_grid` statement embeds statements:  
 	
#### Definition

`display_grid` is used using the `grid` keyword. It allows the modeler to display in an optimized way all cell agents of a grid (i.e. all agents of a species having a grid topology).

### Usages

* The general syntax is:
```display my_display {
   grid ant_grid lines: #black position: { 0.5, 0 } size: {0.5,0.5};
}
 ```

* To display a grid as a DEM:
```display my_display {
    grid cell texture: texture_file text: false triangulation: true elevation: true;
}
 ```
    
* See also: [display](#display), [agents](#agents), [chart](#chart), [event](#event), [graphics](#graphics), [image](#image), [overlay](#overlay), [quadtree](#quadtree), [display_population](#display_population), [text](#text), 

[Top of the page](#table-of-contents)
	

----
### display_population 
#### Facets 
		  
  * **`species`** (species), (omissible) : the species to be displayed
  * `aspect` (an identifier): the name of the aspect that should be used to display the species
  * `fading` (boolean): Used in conjunction with 'trace:', allows to apply a fading effect to the previous traces. Default is false
  * `position` (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greter than 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.
  * `refresh` (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, usefull in case of agents that do not move)
  * `selectable` (boolean): Indicates whether the agents present on this layer are selectable by the user. Default is true
  * `size` (point): the layer resize factor: {1,1} refers to the original size whereas {0.5,0.5} divides by 2 the height and the width of the layer. In case of a 3D layer, a 3D point can be used (note that {1,1} is equivalent to {1,1,0}, so a resize of a layer containing 3D objects with a 2D points will remove the elevation)
  * `trace` (any type in [boolean, int]): Allows to aggregate the visualization of agents at each timestep on the display. Default is false. If set to an int value, only the last n-th steps will be visualized. If set to true, no limit of timesteps is applied.
  * `transparency` (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency)

#### Embedments
* The `display_population` statement is of type: **Layer**
* The `display_population` statement can be embedded into: display, display_population, 
* The `display_population` statement embeds statements: [#display_population display_population],   
 	
#### Definition

The `display_population` statement is used using the `species keyword`. It allows modeler to display all the agent of a given species in the current display. In particular, modeler can choose the aspect used to display them.

### Usages

* The general syntax is:
```display my_display {
   species species_name [additional options];
}
 ```

* Species can be superposed on the same plan (be careful with the order, the last one will be above all the others):
```display my_display {
   species agent1 aspect: base;
   species agent2 aspect: base;
   species agent3 aspect: base;
}
 ```

* Each species layer can be placed at a different z value using the opengl display. position:{0,0,0} means the layer will be placed on the ground and position:{0,0,1} means it will be placed at an height equal to the maximum size of the environment.
```display my_display type: opengl{
   species agent1 aspect: base ;
   species agent2 aspect: base position:{0,0,0.5};
   species agent3 aspect: base position:{0,0,1};
}
 ```
    
* See also: [display](#display), [agents](#agents), [chart](#chart), [event](#event), [graphics](#graphics), [display_grid](#display_grid), [image](#image), [overlay](#overlay), [quadtree](#quadtree), [text](#text), 

[Top of the page](#table-of-contents)
	

----
### do 
#### Facets 
		  
  * **`action`** (an identifier), (omissible) : the name of an action or a primitive
  * `internal_function` (any type): 
  * `returns` (a new identifier): create a new variable and assign to it the result of the action
  * `with` (map): a map expression containing the parameters of the action

#### Embedments
* The `do` statement is of type: **Single statement**
* The `do` statement can be embedded into: chart, Behavior, Sequence of statements or action, 
* The `do` statement embeds statements:  
 	
#### Definition

Allows the agent to execute an action or a primitive.  For a list of primitives available in every species, see this [BuiltIn161 page]; for the list of primitives defined by the different skills, see this [Skills161 page]. Finally, see this [Species161 page] to know how to declare custom actions.

### Usages

* The simple syntax (when the action does not expect any argument and the result is not to be kept) is:
```do name_of_action_or_primitive;
 ```

* In case the action expects one or more arguments to be passed, they are defined by using facets (enclosed tags or a map are now deprecated):
```do name_of_action_or_primitive arg1: expression1 arg2: expression2;
 ```

* In case the result of the action needs to be made available to the agent, the action can be called with the agent calling the action (`self` when the agent itself calls the action) instead of `do`; the result should be assigned to a temporary variable:
```type_returned_by_action result <- self name_of_action_or_primitive [];
 ```

* In case of an action expecting arguments and returning a value, the following syntax is used:
```type_returned_by_action result <- self name_of_action_or_primitive [arg1::expression1, arg2::expression2];
 ```

* Deprecated uses: following uses of the `do` statement (still accepted) are now deprecated:
```// Simple syntax: 
do action: name_of_action_or_primitive;

// In case the result of the action needs to be made available to the agent, the `returns` keyword can be defined; the result will then be referred to by the temporary variable declared in this attribute:
do name_of_action_or_primitive returns: result;
do name_of_action_or_primitive arg1: expression1 arg2: expression2 returns: result;
type_returned_by_action result <- name_of_action_or_primitive(self, [arg1::expression1, arg2::expression2]);

// In case the result of the action needs to be made available to the agent
let result <- name_of_action_or_primitive(self, []);

// In case the action expects one or more arguments to be passed, they can also be defined by using enclosed `arg` statements, or the `with` facet with a map of parameters:
do name_of_action_or_primitive with: [arg1::expression1, arg2::expression2];

or

do name_of_action_or_primitive {
     arg arg1 value: expression1;
     arg arg2 value: expression2;
     ...
}
 ```


[Top of the page](#table-of-contents)
	

----
### draw 
#### Facets 
		
  * `geometry` (any type), (omissible) : any type of data (it can be geometry, image, text)
  * `at` (point): location where the shape/text/icon is drawn
  * `begin_arrow` (any type in [int, float]): the size of the arrow, located at the beginning of the drawn geometry
  * `bitmap` (boolean): 
  * `border` (any type in [rgb, boolean]): if used with a color, represents the color of the geometry border. If set to false, expresses that no border should be drawn. If not set, the borders will be drawn using the color of the geometry.
  * `color` (rgb): the color to use to display the text/icon/geometry
  * `depth` (float): (only if the display type is opengl) Add a depth to the geometry previously defined (a line becomes a plan, a circle becomes a cylinder, a square becomes a cube, a polygon becomes a polyhedron with height equal to the depth value). Note: This only works if a the agent has not a point geometry
  * `empty` (boolean): a condition specifying whether the geometry is empty or full
  * `end_arrow` (any type in [int, float]): the size of the arrow, located at the end of the drawn geometry
  * `font` (any type in [19, string]): the font used to draw the text
  * `image` (string): path of the icon to draw (JPEG, PNG, GIF)
  * `rotate` (any type in [float, int]): orientation of the shape/text/icon
  * `rotate3D` (pair): orientation of the shape/text/icon
  * `rounded` (boolean): specify whether the geometry have to be rounded (e.g. for squares)
  * `scale` (float): 
  * `shape` (any type): the shape to display
  * `size` (float): size of the text/icon (not used in the context of the drawing of a geometry)
  * `style` (an identifier), takes values in: {plain, bold, italic}: the style used to display text
  * `text` (string): the text to draw
  * `texture` (any type in [string, list]): the texture that should be applied to the geometry
  * `to` (point): 

#### Embedments
* The `draw` statement is of type: **Single statement**
* The `draw` statement can be embedded into: aspect, Sequence of statements or action, Layer, 
* The `draw` statement embeds statements:  
 	
#### Definition

`draw` is used in an aspect block to expresse how agents of the species will be drawn. It is evaluated each time the agent has to be drawn. It can also be used in the graphics block.

### Usages

* Any kind of geometry as any location can be drawn when displaying an agent (independently of his shape)
```aspect geometryAspect {
	draw circle(1.0) empty: !hasFood color: #orange ;
}
 ```

* Image or text can also be drawn
```aspect arrowAspect {
	draw "Current state= "+state at: location + {-3,1.5} color: #white font: font('Default', 12, #bold) ;
	draw file(ant_shape_full) rotate: heading at: location size: 5
}
 ```

* Arrows can be drawn with any kind of geometry, using begin_arrow and end_arrow facets, combined with the empty: facet to specify whether it is plain or empty
```aspect arrowAspect {
	draw line([{20, 20}, {40, 40}]) color: #black begin_arrow:5;
	draw line([{10, 10},{20, 50}, {40, 70}]) color: #green end_arrow: 2 begin_arrow: 2 empty: true;
	draw square(10) at: {80,20} color: #purple begin_arrow: 2 empty: true;
}
 ```


[Top of the page](#table-of-contents)
	

----
### else 
#### Facets 
		

#### Embedments
* The `else` statement is of type: **Sequence of statements or action**
* The `else` statement can be embedded into: if, 
* The `else` statement embeds statements:  
 	
#### Definition

This statement cannot be used alone

### Usages
    
* See also: [if](#if), 

[Top of the page](#table-of-contents)
	

----
### enter 
#### Facets 
		

#### Embedments
* The `enter` statement is of type: **Sequence of statements or action**
* The `enter` statement can be embedded into: state, 
* The `enter` statement embeds statements:  
 	
#### Definition

In an FSM architecture, `enter` introduces a sequence of statements to execute upon entering a state.

### Usages

* In the following example, at the step it enters into the state s_init, the message 'Enter in s_init' is displayed followed by the display of the state name:
```	state s_init {
		enter { write "Enter in" + state; }
			write "Enter in" + state;
		}
		write state;
	}
 ```
    
* See also: [state](#state), [exit](#exit), [transition](#transition), 

[Top of the page](#table-of-contents)
	

----
### equation 
#### Facets 
		  
  * **`name`** (an identifier), (omissible) : the equation identifier
  * `params` (list): the list of pramameters used in predefined equation systems
  * `simultaneously` (list): a list of agents containing a system of equations (all systems will be solved simultaneously)
  * `type` (an identifier), takes values in: {SI, SIS, SIR, SIRS, SEIR, LV}: the choice of one among classical models (SI, SIS, SIR, SIRS, SEIR, LV)
  * `vars` (list): the list of variables used in predefined equation systems

#### Embedments
* The `equation` statement is of type: **Sequence of statements or action**
* The `equation` statement can be embedded into: Species, Model, 
* The `equation` statement embeds statements: [#= =],   
 	
#### Definition

The equation statement is used to create an equation system from several single equations.

### Usages

* The basic syntax to define an equation system is:
```float t;
float S;
float I;
equation SI { 
   diff(S,t) = (- 0.3 * S * I / 100);
   diff(I,t) = (0.3 * S * I / 100);
} 
 ```

* If the type: facet is used, a predefined equation system is defined using variables vars: and parameters params: in the right order. All possible predefined equation systems are the following ones (see [EquationPresentation161 EquationPresentation161] for precise definition of each classical equation system): 
```equation eqSI type: SI vars: [S,I,t] params: [N,beta];
equation eqSIS type: SIS vars: [S,I,t] params: [N,beta,gamma];
equation eqSIR type:SIR vars:[S,I,R,t] params:[N,beta,gamma];
equation eqSIRS type: SIRS vars: [S,I,R,t] params: [N,beta,gamma,omega,mu];
equation eqSEIR type: SEIR vars: [S,E,I,R,t] params: [N,beta,gamma,sigma,mu];
equation eqLV type: LV vars: [x,y,t] params: [alpha,beta,delta,gamma] ;
 ```

* If the simultaneously: facet is used, system of all the agents will be solved simultaneously.    
* See also: [=](#=), [solve](#solve), 

[Top of the page](#table-of-contents)
	

----
### error 
#### Facets 
		  
  * **`message`** (string), (omissible) : the message to display in the error.

#### Embedments
* The `error` statement is of type: **Single statement**
* The `error` statement can be embedded into: Behavior, Sequence of statements or action, Layer, 
* The `error` statement embeds statements:  
 	
#### Definition

The statement makes the agent output an error dialog (if the simulation contains a user interface). Otherwise displays the error in the console.

### Usages

* Throwing an error
```error 'This is an error raised by ' + self;
 ```


[Top of the page](#table-of-contents)
	

----
### event 
#### Facets 
		  
  * **`name`** (an identifier), (omissible) , takes values in: {mouse_up, mouse_down, mouse_drag}: the type of event captured  
  * **`action`** (string): the identifier of the action to be executed. It has to be an action written in the global block. This action have to follow the following specification: `action myAction (point location, list selected_agents)`
  * `mouse_location` (string): 
  * `selected_agents` (string): 

#### Embedments
* The `event` statement is of type: **Layer**
* The `event` statement can be embedded into: display, 
* The `event` statement embeds statements:  
 	
#### Definition

`event` allows to interact with the simulation by capturing mouse event and doing an action. This action could apply a change on environment or on agents, according to the goal.

### Usages

* The general syntax is:
```event [event_type] action: myAction;
 ```

* For instance:
```global {
   // ... 
   action myAction (point location, list selected_agents) {
      // location: contains le location of the click in the environment
      // selected_agents: contains agents clicked by the event
      
      // code written by modelers
   }
}

experiment Simple type:gui {
   display my_display {
      event mouse_up action: myAction;
   }
}
 ```
    
* See also: [display](#display), [agents](#agents), [chart](#chart), [graphics](#graphics), [display_grid](#display_grid), [image](#image), [overlay](#overlay), [quadtree](#quadtree), [display_population](#display_population), [text](#text), 

[Top of the page](#table-of-contents)
	

----
### exhaustive 
#### Facets 
		  
  * **`name`** (an identifier), (omissible) : 
  * `aggregation` (a label), takes values in: {min, max}: the agregation method
  * `maximize` (float): the value the algorithm tries to maximize
  * `minimize` (float): the value the algorithm tries to minimize

#### Embedments
* The `exhaustive` statement is of type: **Batch method**
* The `exhaustive` statement can be embedded into: Experiment, 
* The `exhaustive` statement embeds statements:  
 	
#### Definition

This is the standard batch method. The exhaustive mode is defined by default when there is no method element present in the batch section. It explores all the combination of parameter values in a sequential way. See [batch161 the batch dedicated page].

### Usages

* As other batch methods, the basic syntax of the exhaustive statement uses `method exhaustive` instead of the expected `exhaustive name: id` : 
```method exhaustive [facet: value];
 ```

* For example: 
```method exhaustive maximize: food_gathered;
 ```


[Top of the page](#table-of-contents)
	

----
### exit 
#### Facets 
		

#### Embedments
* The `exit` statement is of type: **Sequence of statements or action**
* The `exit` statement can be embedded into: state, 
* The `exit` statement embeds statements:  
 	
#### Definition

In an FSM architecture, `exit` introduces a sequence of statements to execute right before exiting the state.

### Usages

* In the following example, at the state it leaves the state s_init, he will display the message 'EXIT from s_init':
```	state s_init initial: true {
		write state;
		transition to: s1 when: (cycle > 2) {
			write "transition s_init -> s1";
		}
		exit {
			write "EXIT from "+state;
		}
	}
 ```
    
* See also: [enter](#enter), [state](#state), [transition](#transition), 

[Top of the page](#table-of-contents)
	

----
### experiment 
#### Facets 
		  
  * **`name`** (a label), (omissible) : identifier of the experiment  
  * **`title`** (a label):   
  * **`type`** (a label), takes values in: {batch, gui}: the type of the experiment (either 'gui' or 'batch'
  * `control` (an identifier): 
  * `frequency` (int): the execution frequence of the experiment (default value: 1). If frequency: 10, the experiment is executed only each 10 steps.
  * `keep_seed` (boolean): 
  * `multicore` (boolean): 
  * `parent` (an identifier): the parent experiment (in case of inheritance between experiments)
  * `repeat` (int): In case of a batch experiment, expresses hom many times the simulations must be repeated
  * `schedules` (container): an ordered list of agents giving the order of their execution
  * `skills` (list): 
  * `until` (boolean): In case of a batch experiment, an expression that will be evaluated to know when a simulation should be terminated

#### Embedments
* The `experiment` statement is of type: **Experiment**
* The `experiment` statement can be embedded into: Model, 
* The `experiment` statement embeds statements: 

[Top of the page](#table-of-contents)
	

----
### export 
#### Facets 
		  
  * **`var`** (an identifier), (omissible) : 
  * `framerate` (int): 
  * `name` (string): 

#### Embedments
* The `export` statement is of type: **Single statement**
* The `export` statement can be embedded into: Experiment, 
* The `export` statement embeds statements: 

[Top of the page](#table-of-contents)
	

----
### genetic 
#### Facets 
		  
  * **`name`** (an identifier), (omissible) : 
  * `aggregation` (a label), takes values in: {min, max}: the agregation method
  * `crossover_prob` (float): crossover probability between two individual solutions
  * `max_gen` (int): number of generations
  * `maximize` (float): the value the algorithm tries to maximize
  * `minimize` (float): the value the algorithm tries to minimize
  * `mutation_prob` (float): mutation probability for an individual solution
  * `nb_prelim_gen` (int): number of random populations used to build the initial population
  * `pop_dim` (int): size of the population (number of individual solutions)

#### Embedments
* The `genetic` statement is of type: **Batch method**
* The `genetic` statement can be embedded into: Experiment, 
* The `genetic` statement embeds statements:  
 	
#### Definition

This is a simple implementation of Genetic Algorithms (GA). See the wikipedia article and [batch161 the batch dedicated page]. The principle of the GA is to search an optimal solution by applying evolution operators on an initial population of solutions. There are three types of evolution operators: crossover, mutation and selection. Different techniques can be applied for this selection. Most of them are based on the solution quality (fitness).

### Usages

* As other batch methods, the basic syntax of the `genetic` statement uses `method genetic` instead of the expected `genetic name: id` : 
```method genetic [facet: value];
 ```

* For example: 
```method genetic maximize: food_gathered pop_dim: 5 crossover_prob: 0.7 mutation_prob: 0.1 nb_prelim_gen: 1 max_gen: 20; 
 ```


[Top of the page](#table-of-contents)
	

----
### graphics 
#### Facets 
		  
  * **`name`** (a label), (omissible) : the identifier of the graphics
  * `fading` (boolean): Used in conjunction with 'trace:', allows to apply a fading effect to the previous traces. Default is false
  * `position` (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greter than 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.
  * `refresh` (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, usefull in case of agents that do not move)
  * `size` (point): the layer resize factor: {1,1} refers to the original size whereas {0.5,0.5} divides by 2 the height and the width of the layer. In case of a 3D layer, a 3D point can be used (note that {1,1} is equivalent to {1,1,0}, so a resize of a layer containing 3D objects with a 2D points will remove the elevation)
  * `trace` (any type in [boolean, int]): Allows to aggregate the visualization at each timestep on the display. Default is false. If set to an int value, only the last n-th steps will be visualized. If set to true, no limit of timesteps is applied.
  * `transparency` (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency)

#### Embedments
* The `graphics` statement is of type: **Layer**
* The `graphics` statement can be embedded into: display, 
* The `graphics` statement embeds statements:  
 	
#### Definition

`graphics` allows the modeler to freely draw shapes/geometries/texts without having to define a species. It works exactly like a species [Aspect161 aspect]: the draw statement can be used in the same way.

### Usages

* The general syntax is:
```display my_display {
   graphics "my new layer" {
      draw circle(5) at: {10,10} color: #red;
      draw "test" at: {10,10} size: 20 color: #black;
   }
}
 ```
    
* See also: [display](#display), [agents](#agents), [chart](#chart), [event](#event), [graphics](#graphics), [display_grid](#display_grid), [image](#image), [overlay](#overlay), [quadtree](#quadtree), [display_population](#display_population), [text](#text), 

[Top of the page](#table-of-contents)
	

----
### hill_climbing 
#### Facets 
		  
  * **`name`** (an identifier), (omissible) : 
  * `aggregation` (a label), takes values in: {min, max}: the agregation method
  * `iter_max` (int): number of iterations
  * `maximize` (float): the value the algorithm tries to maximize
  * `minimize` (float): the value the algorithm tries to minimize

#### Embedments
* The `hill_climbing` statement is of type: **Batch method**
* The `hill_climbing` statement can be embedded into: Experiment, 
* The `hill_climbing` statement embeds statements:  
 	
#### Definition

This algorithm is an implementation of the Hill Climbing algorithm. See the wikipedia article and [batch161 the batch dedicated page].

### Usages

* As other batch methods, the basic syntax of the `hill_climbing` statement uses `method hill_climbing` instead of the expected `hill_climbing name: id` : 
```method hill_climbing [facet: value];
 ```

* For example: 
```method hill_climbing iter_max: 50 maximize : food_gathered; 
 ```


[Top of the page](#table-of-contents)
	

----
### if 
#### Facets 
		  
  * **`condition`** (boolean), (omissible) : A boolean expression: the condition that is evaluated.

#### Embedments
* The `if` statement is of type: **Sequence of statements or action**
* The `if` statement can be embedded into: Behavior, Sequence of statements or action, Layer, 
* The `if` statement embeds statements: [#else else],   
 	
#### Definition

Allows the agent to execute a sequence of statements if and only if the condition evaluates to true.

### Usages

* The generic syntax is:
```if bool_expr {
    [statements]
}
 ```

* Optionally, the statements to execute when the condition evaluates to false can be defined in a following statement else. The syntax then becomes:
```if bool_expr {
    [statements]
}
else {
    [statements]
}
string valTrue <- "";
if true {
	valTrue <- "true";
}
else {
	valTrue <- "false";
}
 	// valTrue equals "true"
string valFalse <- "";
if false {
	valFalse <- "true";
}
else {
	valFalse <- "false";
}
 	// valFalse equals "false"
 ```

* ifs and elses can be imbricated as needed. For instance:
```if bool_expr {
    [statements]
}
else if bool_expr2 {
    [statements]
}
else {
    [statements]
}
 ```


[Top of the page](#table-of-contents)
	

----
### image 
#### Facets 
		
  * `name` (string), (omissible) : the identifier of the image layer
  * `color` (rgb): in the case of a shapefile, this the color used to fill in geometries of the shapefile
  * `file` (any type in [string, file]): the name/path of the image (in the case of a raster image)
  * `gis` (any type in [file, string]): the name/path of the shape file (to display a shapefile as background, without creating agents from it)
  * `position` (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greter than 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.
  * `refresh` (boolean): (openGL only) specify whether the image display is refreshed. (true by default, usefull in case of images that is not modified over the simulation)
  * `size` (point): the layer resize factor: {1,1} refers to the original size whereas {0.5,0.5} divides by 2 the height and the width of the layer. In case of a 3D layer, a 3D point can be used (note that {1,1} is equivalent to {1,1,0}, so a resize of a layer containing 3D objects with a 2D points will remove the elevation)
  * `transparency` (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency)

#### Embedments
* The `image` statement is of type: **Layer**
* The `image` statement can be embedded into: display, 
* The `image` statement embeds statements:  
 	
#### Definition

`image` allows modeler to display an image (e.g. as background of a simulation).

### Usages

* The general syntax is:
```display my_display {
   image layer_name file: image_file [additional options];
}
 ```

* For instance, in the case of a bitmap image
```display my_display {
   image background file:"../images/my_backgound.jpg";
}
 ```

* Or in the case of a shapefile:
```display my_display {
   image testGIS gis: "../includes/building.shp" color: rgb('blue');
}
 ```

* It is also possible to superpose images on different layers in the same way as for species using opengl display:
```display my_display {
  image image1 file:"../images/image1.jpg";
  image image2 file:"../images/image2.jpg";
  image image3 file:"../images/image3.jpg" position: {0,0,0.5};
}
 ```
    
* See also: [display](#display), [agents](#agents), [chart](#chart), [event](#event), [graphics](#graphics), [display_grid](#display_grid), [overlay](#overlay), [quadtree](#quadtree), [display_population](#display_population), [text](#text), 

[Top of the page](#table-of-contents)
	

----
### inspect 
#### Facets 
		  
  * **`name`** (any type), (omissible) : the identifier of the inspector
  * `attributes` (list): the list of attributes to inspect
  * `refresh` (boolean): Indicates the condition under which this output should be refreshed (default is true)
  * `refresh_every` (int): Allows to refresh the inspector every n time steps (default is 1)
  * `type` (an identifier), takes values in: {agent, species, display_population, table}: the way to inspect agents: in a table, or a set of inspectors
  * `value` (any type): the set of agents to inspect, could be a species, a list of agents or an agent

#### Embedments
* The `inspect` statement is of type: **Output**
* The `inspect` statement can be embedded into: output, permanent, 
* The `inspect` statement embeds statements:  
 	
#### Definition

`inspect` (and `browse`) statements allows modeler to inspect a set of agents, in a table with agents and all their attributes or an agent inspector per agent, depending on the type: chosen. Modeler can choose which attributes to display. When `browse` is used, type: default value is table, whereas when`inspect` is used, type: default value is agent.

### Usages

* An example of syntax is:
```inspect "my_inspector" value: ant attributes: ["name", "location"];
 ```


[Top of the page](#table-of-contents)
	

----
### let 
#### Facets 
		  
  * **`name`** (a new identifier), (omissible) : 
  * `index` (a datatype identifier): 
  * `of` (a datatype identifier): 
  * `type` (a datatype identifier): 
  * `value` (any type): 

#### Embedments
* The `let` statement is of type: **Single statement**
* The `let` statement can be embedded into: Behavior, Sequence of statements or action, Layer, 
* The `let` statement embeds statements: 

[Top of the page](#table-of-contents)
	

----
### loop 
#### Facets 
		
  * `name` (a new identifier), (omissible) : a temporary variable name
  * `from` (int): an int expression
  * `over` (any type in [container, point]): a list, point, matrix or map expression
  * `step` (int): an int expression
  * `times` (int): an int expression
  * `to` (int): an int expression
  * `while` (boolean): a boolean expression

#### Embedments
* The `loop` statement is of type: **Sequence of statements or action**
* The `loop` statement can be embedded into: Behavior, Sequence of statements or action, Layer, 
* The `loop` statement embeds statements:  
 	
#### Definition

Allows the agent to perform the same set of statements either a fixed number of times, or while a condition is true, or by progressing in a collection of elements or along an interval of integers. Be aware that there are no prevention of infinite loops. As a consequence, open loops should be used with caution, as one agent may block the execution of the whole model.

### Usages

* The basic syntax for repeating a fixed number of times a set of statements is:
```loop times: an_int_expression {
     // [statements]
}
 ```

* The basic syntax for repeating a set of statements while a condition holds is:
```loop while: a_bool_expression {
     // [statements]
}
 ```

* The basic syntax for repeating a set of statements by progressing over a container of a point is:
```loop a_temp_var over: a_collection_expression {
     // [statements]
}
 ```

* The basic syntax for repeating a set of statements while an index iterates over a range of values with a fixed step of 1 is:
```loop a_temp_var from: int_expression_1 to: int_expression_2 {
     // [statements]
}
 ```

* The incrementation step of the index can also be chosen:
```loop a_temp_var from: int_expression_1 to: int_expression_2 step: int_expression3 {
     // [statements]
}
 ```

* In these latter three cases, the name facet designates the name of a temporary variable, whose scope is the loop, and that takes, in turn, the value of each of the element of the list (or each value in the interval). For example, in the first instance of the "loop over" syntax :
```int a <- 0;
loop i over: [10, 20, 30] {
     a <- a + i;
} // a now equals 60
 ```

* The second (quite common) case of the loop syntax allows one to use an interval of integers. The from and to facets take an integer expression as arguments, with the first (resp. the last) specifying the beginning (resp. end) of the inclusive interval (i.e. [to, from]). If the step is not defined, it is assumed to be equal to 1.
```list the_list <-list (species_of (self));
loop i from: 0 to: length (the_list) - 1 {
     ask the_list at i {
        // ...
     }
} // every  agent of the list is asked to do something
 ```


[Top of the page](#table-of-contents)
	

----
### match 
#### Facets 
		
  * `value` (any type), (omissible) : 

#### Embedments
* The `match` statement is of type: **Sequence of statements or action**
* The `match` statement can be embedded into: switch, 
* The `match` statement embeds statements:  
 	
#### Definition

In a switch...match structure, the value of each match block is compared to the value in the switch. If they match, the embedded statement set is executed. Three kinds of match can be used

### Usages

* match block is executed if the switch value is equals to the value of the match:
```switch 3 {
   match 1 {write "Match 1"; }
   match 3 {write "Match 2"; }
}
 ```

* match_between block is executed if the switch value is in the interval given in value of the match_between:
```switch 3 {
   match_between [1,2] {write "Match OK between [1,2]"; }
   match_between [2,5] {write "Match OK between [2,5]"; }
}
 ```

* match_one block is executed if the switch value is equals to one of the values of the match_one:
```switch 3 {
   match_one [0,1,2] {write "Match OK with one of [0,1,2]"; }
   match_between [2,3,4,5] {write "Match OK with one of [2,3,4,5]"; }
}
 ```
    
* See also: [switch](#switch), [default](#default), 

[Top of the page](#table-of-contents)
	

----
### migrate 
#### Facets 
		  
  * **`source`** (an identifier), (omissible) : can be an agent, a list of agents, a agent's population to be migrated  
  * **`target`** (an identifier): target species/population that source agent(s) migrate to.
  * `returns` (a new identifier): the list of returned agents in a new local variable

#### Embedments
* The `migrate` statement is of type: **Sequence of statements or action**
* The `migrate` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `migrate` statement embeds statements:  
 	
#### Definition

This command permits agents to migrate from one population/species to another population/species and stay in the same host after the migration. Species of source agents and target species respect the following constraints: (i) they are "peer" species (sharing the same direct macro-species), (ii) they have sub-species vs. parent-species relationship.

### Usages

* It can be used in a 3-levels model, in case where individual agents can be captured into group meso agents and groups into clouds macro agents. migrate is used to allows agents captured by groups to migrate into clouds. See the model 'Balls, Groups and Clouds.gaml' in the library.
```migrate ball_in_group target: ball_in_cloud;
 ```
    
* See also: [capture](#capture), [release](#release), 

[Top of the page](#table-of-contents)
	

----
### monitor 
#### Facets 
		  
  * **`name`** (a label), (omissible) : identifier of the monitor  
  * **`value`** (any type): expression that will be evaluated to be displayed in the monitor
  * `refresh` (boolean): Indicates the condition under which this output should be refreshed (default is true)
  * `refresh_every` (int): Allows to refresh the monitor every n time steps (default is 1)

#### Embedments
* The `monitor` statement is of type: **Output**
* The `monitor` statement can be embedded into: output, permanent, 
* The `monitor` statement embeds statements:  
 	
#### Definition

A monitor allows to follow the value of an arbitrary expression in GAML.

### Usages

* An example of use is:
```monitor "nb preys" value: length(prey as list) refresh_every: 5;  
 ```


[Top of the page](#table-of-contents)
	

----
### output 
#### Facets 
		

#### Embedments
* The `output` statement is of type: **Output**
* The `output` statement can be embedded into: Model, Experiment, 
* The `output` statement embeds statements: [#display display],  [#inspect inspect],  [#monitor monitor],  [#output_file output_file],   
 	
#### Definition

`output` blocks define how to visualize a simulation (with one or more display blocks that define separate windows). It will include a set of displays, monitors and files statements. It will be taken into account only if the experiment type is `gui`.

### Usages

* Its basic syntax is: 
```experiment exp_name type: gui {
   // [inputs]
   output {
      // [display, file or monitor statements]
   }
}
 ```
    
* See also: [display](#display), [monitor](#monitor), [inspect](#inspect), [output_file](#output_file), 

[Top of the page](#table-of-contents)
	

----
### output_file 
#### Facets 
		  
  * **`name`** (an identifier), (omissible) :   
  * **`data`** (string): 
  * `footer` (string): 
  * `header` (string): 
  * `refresh` (boolean): Indicates the condition under which this file should be saved (default is true)
  * `refresh_every` (int): Allows to save the file every n time steps (default is 1)
  * `rewrite` (boolean): 
  * `type` (an identifier), takes values in: {csv, text, xml}: 

#### Embedments
* The `output_file` statement is of type: **Output**
* The `output_file` statement can be embedded into: output, permanent, 
* The `output_file` statement embeds statements: 

[Top of the page](#table-of-contents)
	

----
### overlay 
#### Facets 
		
  * `left` (any type), (omissible) : an expression that will be evaluated and displayed in the left section of the overlay
  * `center` (any type): an expression that will be evaluated and displayed in the center section of the overlay
  * `color` (any type in [list, rgb]): the color(s) used to display the expressions given in other facets
  * `right` (any type): an expression that will be evaluated and displayed in the right section of the overlay

#### Embedments
* The `overlay` statement is of type: **Layer**
* The `overlay` statement can be embedded into: display, 
* The `overlay` statement embeds statements:  
 	
#### Definition

`overlay` allows the modeler to display a line to the already existing overlay, where the results of 'left', 'center' and 'right' facets, when they are defined, are displayed with the corresponding color if defined.

### Usages

* The general syntax is:
```overlay "Cycle: " + (cycle) center: "Duration: " + total_duration + "ms" right: "Model time: " + as_date(time,"") color: [#yellow, #orange, #yellow];
 ```
    
* See also: [display](#display), [agents](#agents), [chart](#chart), [event](#event), [graphics](#graphics), [display_grid](#display_grid), [image](#image), [quadtree](#quadtree), [display_population](#display_population), [text](#text), 

[Top of the page](#table-of-contents)
	

----
### parameter 
#### Facets 
		  
  * **`var`** (an identifier): the name of the variable (that should be declared in the global)
  * `name` (a label), (omissible) : The message displayed in the interface
  * `among` (list): the list of possible values
  * `category` (a label): a category label, used to group parameters in the interface
  * `init` (any type): the init value
  * `max` (any type): the maximum value
  * `min` (any type): the minimum value
  * `step` (float): the increment step (mainly used in batch mode to express the variation step between simulation)
  * `type` (a datatype identifier): the variable type
  * `unit` (a label): the variable unit

#### Embedments
* The `parameter` statement is of type: **Parameter**
* The `parameter` statement can be embedded into: Experiment, 
* The `parameter` statement embeds statements:  
 	
#### Definition

The parameter statement specifies which global attributes (i) will change through the successive simulations (in batch experiments), (ii) can be modified by user via the interface (in gui experiments). In GUI experiments, parameters are displayed depending on their type.

### Usages

* In gui experiment, the general syntax is the following:
```parameter title var: global_var category: cat;
 ```

* In batch experiment, the two following syntaxes can be used to describe the possible values of a parameter:
```parameter 'Value of toto:' var: toto among: [1, 3, 7, 15, 100]; 
parameter 'Value of titi:' var: titi min: 1 max: 100 step: 2; 
 ```


[Top of the page](#table-of-contents)
	

----
### permanent 
#### Facets 
		

#### Embedments
* The `permanent` statement is of type: **Output**
* The `permanent` statement can be embedded into: Experiment, 
* The `permanent` statement embeds statements: [#display display],  [#inspect inspect],  [#monitor monitor],  [#output_file output_file],   
 	
#### Definition

In a batch experiment, the permanent section allows to define an output block that will NOT be re-initialized at the beginning of each simulation but will be filled at the end of each simulation.

### Usages

* For instance, this permanent section will allow to display for each simulation the end value of the food_gathered variable:
```permanent {
	display Ants background: rgb('white') refresh_every: 1 {
		chart "Food Gathered" type: series {
			data "Food" value: food_gathered;
		}
	}
}
 ```


[Top of the page](#table-of-contents)
	

----
### plan 
#### Facets 
		
  * `name` (an identifier), (omissible) : 
  * `finished_when` (boolean): 
  * `instantaneous` (boolean): 
  * `intention` (any type): 
  * `priority` (float): 
  * `when` (boolean): 

#### Embedments
* The `plan` statement is of type: **Behavior**
* The `plan` statement can be embedded into: Species, 
* The `plan` statement embeds statements: 

[Top of the page](#table-of-contents)
	

----
### put 
#### Facets 
		  
  * **`in`** (any type in [container, species, agent, geometry]): an expression that evaluates to a container
  * `item` (any type), (omissible) : any expression
  * `all` (any type): any expression
  * `at` (any type): any expression
  * `edge` (any type): Indicates that the item to put should be considered as an edge of the receiving graph. Soon to be deprecated, use 'put edge(item)...' instead
  * `key` (any type): any expression
  * `weight` (float): an expression that evaluates to a float

#### Embedments
* The `put` statement is of type: **Single statement**
* The `put` statement can be embedded into: chart, Behavior, Sequence of statements or action, 
* The `put` statement embeds statements:  
 	
#### Definition

Allows the agent to replace a value in a container at a given position (in a list or a map) or for a given key (in a map). Note that the behavior and the type of the attributes depends on the specific kind of container.

### Usages

* The allowed parameters configurations are the following ones:
```put expr at: expr in: expr_container;
put all: expr in: expr_container;
 ```

* In the case of a list, the position should an integer in the bound of the list. The facet all: is used to replace all the elements of the list by the given value.
```list<int> putList <- [1,2,3,4,5]; 	// putList equals [1,2,3,4,5]
put -10 at: 1 in: putList; 	// putList equals [1,-10,3,4,5]
put 10 all: true in: putList; 	// putList equals [10,10,10,10,10]
 ```

* In the case of a matrix, the position should be a point in the bound of the matrix. The facet all: is used to replace all the elements of the matrix by the given value.
```matrix<int> putMatrix <- matrix([[0,1],[2,3]]); 	// putMatrix equals matrix([[0,1],[2,3]])
put -10 at: {1,1} in: putMatrix; 	// putMatrix equals matrix([[0,1],[2,-10]])
put 10 all: true in: putMatrix; 	// putMatrix equals matrix([[10,10],[10,10]])
 ```

* In the case of a map, the position should be one of the key values of the map. Notice that if the given key value does not exist in the map, the given pair key::value will be added to the map. The facet all is used to replace the value of all the pairs of the map.
```map<string,int> putMap <- ["x"::4,"y"::7]; 	// putMap equals ["x"::4,"y"::7]
put -10 key: "y" in: putMap; 	// putMap equals ["x"::4,"y"::-10]
put -20 key: "z" in: putMap; 	// putMap equals ["x"::4,"y"::-10, "z"::-20]
put -30 all: true in: putMap; 	// putMap equals ["x"::-30,"y"::-30, "z"::-30]
 ```


[Top of the page](#table-of-contents)
	

----
### quadtree 
#### Facets 
		  
  * **`name`** (a label), (omissible) : identifier of the layer
  * `position` (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greter than 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.
  * `refresh` (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, usefull in case of agents that do not move)
  * `size` (point): the layer resize factor: {1,1} refers to the original size whereas {0.5,0.5} divides by 2 the height and the width of the layer. In case of a 3D layer, a 3D point can be used (note that {1,1} is equivalent to {1,1,0}, so a resize of a layer containing 3D objects with a 2D points will remove the elevation)
  * `transparency` (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency)

#### Embedments
* The `quadtree` statement is of type: **Layer**
* The `quadtree` statement can be embedded into: display, 
* The `quadtree` statement embeds statements:  
 	
#### Definition

`quadtree` allows the modeler to display the quadtree.

### Usages

* The general syntax is:
```display my_display {
   quadtree 'qt' position: { 0, 0.5 } size: quadrant_size;
}
 ```
    
* See also: [display](#display), [agents](#agents), [chart](#chart), [event](#event), [graphics](#graphics), [display_grid](#display_grid), [image](#image), [overlay](#overlay), [quadtree](#quadtree), [display_population](#display_population), [text](#text), 

[Top of the page](#table-of-contents)
	

----
### reactive_tabu 
#### Facets 
		  
  * **`name`** (an identifier), (omissible) : 
  * `aggregation` (a label), takes values in: {min, max}: the agregation method
  * `cycle_size_max` (int): minimal size of the considered cycles
  * `cycle_size_min` (int): maximal size of the considered cycles
  * `iter_max` (int): number of iterations
  * `maximize` (float): the value the algorithm tries to maximize
  * `minimize` (float): the value the algorithm tries to minimize
  * `nb_tests_wthout_col_max` (int): number of movements without collision before shortening the tabu list
  * `tabu_list_size_init` (int): initial size of the tabu list
  * `tabu_list_size_max` (int): maximal size of the tabu list
  * `tabu_list_size_min` (int): minimal size of the tabu list

#### Embedments
* The `reactive_tabu` statement is of type: **Batch method**
* The `reactive_tabu` statement can be embedded into: Experiment, 
* The `reactive_tabu` statement embeds statements:  
 	
#### Definition

This algorithm is a simple implementation of the Reactive Tabu Search algorithm ((Battiti et al., 1993)). This Reactive Tabu Search is an enhance version of the Tabu search. It adds two new elements to the classic Tabu Search. The first one concerns the size of the tabu list: in the Reactive Tabu Search, this one is not constant anymore but it dynamically evolves according to the context. Thus, when the exploration process visits too often the same solutions, the tabu list is extended in order to favor the diversification of the search process. On the other hand, when the process has not visited an already known solution for a high number of iterations, the tabu list is shortened in order to favor the intensification of the search process. The second new element concerns the adding of cycle detection capacities. Thus, when a cycle is detected, the process applies random movements in order to break the cycle. See [batch161 the batch dedicated page].

### Usages

* As other batch methods, the basic syntax of the reactive_tabu statement uses `method reactive_tabu` instead of the expected `reactive_tabu name: id` : 
```method reactive_tabu [facet: value];
 ```

* For example: 
```method reactive_tabu iter_max: 50 tabu_list_size_init: 5 tabu_list_size_min: 2 tabu_list_size_max: 10 nb_tests_wthout_col_max: 20 cycle_size_min: 2 cycle_size_max: 20 maximize: food_gathered;
 ```


[Top of the page](#table-of-contents)
	

----
### reflex 
#### Facets 
		
  * `name` (an identifier), (omissible) : the identifier of the reflex
  * `when` (boolean): an expression that evaluates a boolean, the condition to fulfill in order to execute the statements embedded in the reflex.

#### Embedments
* The `reflex` statement is of type: **Behavior**
* The `reflex` statement can be embedded into: Species, Experiment, Model, 
* The `reflex` statement embeds statements:  
 	
#### Definition

A reflex is a sequence of statements that can be executed, at each time step, by the agent. If no facet when: is defined, it will be executed every time step. If there is a when: facet, it is executed only if the boolean expression evaluates to true.

### Usages

* Example:
```reflex my_reflex when: flip (0.5){ 		//Only executed when flip returns true
    write "Executing the unconditional reflex";
}
 ```


[Top of the page](#table-of-contents)
	

----
### release 
#### Facets 
		  
  * **`target`** (any type in [agent, list]), (omissible) : an expression that is evaluated as an agent or a list of the agents to be released
  * `as` (species): an expression that is evaluated as a species in which the micro-agent will be released
  * `in` (agent): an expresion that is evaluated as an agent that will be the macro-agent in which micro-agent will be released, i.e. their new host
  * `returns` (a new identifier): a new variable containing a list of the newly released agent(s)

#### Embedments
* The `release` statement is of type: **Sequence of statements or action**
* The `release` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `release` statement embeds statements:  
 	
#### Definition

Allows an agent to release its micro-agent(s). The preliminary for an agent to release its micro-agents is that species of these micro-agents are sub-species of other species (cf. [Species161#Nesting_species Nesting species]). The released agents won't be micro-agents of the calling agent anymore. Being released from a macro-agent, the micro-agents will change their species and host (macro-agent).

### Usages

* We consider the following species. Agents of "C" species can be released from a "B" agent to become agents of "A" species. Agents of "D" species cannot be released from the "A" agent because species "D" has no parent species.
```species A {
...
}
species B {
...
   species C parent: A {
   ...
   }
   species D {
   ...
   }
...
}
 ```

* To release all "C" agents from a "B" agent, agent "C" has to execute the following statement. The "C" agent will change to "A" agent. The won't consider "B" agent as their macro-agent (host) anymore. Their host (macro-agent) will the be the host (macro-agent) of the "B" agent.
```release list(C);
 ```

* The modeler can specify the new host and the new species of the released agents:
```release list (C) as: new_species in: new host;
 ```
    
* See also: [capture](#capture), 

[Top of the page](#table-of-contents)
	

----
### remove 
#### Facets 
		  
  * **`from`** (any type in [container, species, agent, geometry]): an expression that evaluates to a container
  * `item` (any type), (omissible) : any expression to remove from the container
  * `all` (any type): an expression that evaluates to a container. If it is true and if the value a list, it removes the first instance of each element of the list. If it is true and the value is not a container, it will remove all instances of this value.
  * `edge` (any type): Indicates that the item to remove should be considered as an edge of the receiving graph. Soon to be deprecated, use 'remove edge(item)...' instead
  * `index` (any type): any expression, the key at which to remove the element from the container
  * `key` (any type): any expression, the key at which to remove the element from the container
  * `node` (any type): Indicates that the item to remove should be considered as a node of the receiving graph. Soon to be deprecated, use 'remove node(item)...' instead
  * `vertex` (any type): 

#### Embedments
* The `remove` statement is of type: **Single statement**
* The `remove` statement can be embedded into: chart, Behavior, Sequence of statements or action, 
* The `remove` statement embeds statements:  
 	
#### Definition

Allows the agent to remove an element from a container (a list, matrix, map...).

### Usages

* This statement should be used in the following ways, depending on the kind of container used and the expected action on it:
```remove expr from: expr_container;
remove index: expr from: expr_container;
remove key: expr from: expr_container;
remove all: expr from: expr_container;
 ```

* In the case of list, the facet `item:` is used to remove the first occurence of a given expression, whereas `all` is used to remove all the occurences of the given expression.
```list<int> removeList <- [3,2,1,2,3];
remove 2 from: removeList; 	// removeList equals [3,1,2,3]
remove 3 all: true from: removeList; 	// removeList equals [1,2]
remove index: 1 from: removeList; 	// removeList equals [1]
 ```

* In the case of map, the facet `key:` is used to remove the pair identified by the given key.
```map<string,int> removeMap <- ["x"::5, "y"::7, "z"::7];
remove key: "x" from: removeMap; 	// removeMap equals ["y"::7, "z"::7]
remove 7 all: true from: removeMap; 	// removeMap equals map([])
 ```

* In addition, a map a be managed as a list with pair key as index. Given that, facets item:, all: and index: can be used in the same way:
```map<string,int> removeMapList <- ["x"::5, "y"::7, "z"::7, "t"::5];
remove 7 from: removeMapList; 	// removeMapList equals ["x"::5, "z"::7, "t"::5]
remove [5,7] all: true from: removeMapList; 	// removeMapList equals ["t"::5]
remove index: "t" from: removeMapList; 	// removeMapList equals map([])
 ```

* In the case of a graph, both edges and nodes can be removes using node: and edge facets. If a node is removed, all edges to and from this node are also removed.
```graph removeGraph <- as_edge_graph([{1,2}::{3,4},{3,4}::{5,6}]);
remove node: {1,2} from: removeGraph;
remove node(1,2) from: removeGraph;
list var <- removeGraph.vertices; 	// var equals [{3,4},{5,6}]
list var <- removeGraph.edges; 	// var equals [polyline({3,4}::{5,6})]
remove edge: {3,4}::{5,6} from: removeGraph;
remove edge({3,4},{5,6}) from: removeGraph;
list var <- removeGraph.vertices; 	// var equals [{3,4},{5,6}]
list var <- removeGraph.edges; 	// var equals []
 ```

* In the case of an agent or a shape, `remove` allows to remove an attribute from the attributes map of the receiver. However, for agents, it will only remove attributes that have been added dynamically, not the ones defined in the species or in its built-in parent.
```global {
   init {
      create speciesRemove;
      speciesRemove sR <- speciesRemove(0); 	// sR.a now equals 100
      remove key:"a" from: sR; 	// sR.a now equals nil
   }
}

species speciesRemove {
   int a <- 100; 
}
 ```

* This statement can not be used on *matrix*.    
* See also: [add](#add), [put](#put), 

[Top of the page](#table-of-contents)
	

----
### return 
#### Facets 
		
  * `value` (any type), (omissible) : an expression that is returned

#### Embedments
* The `return` statement is of type: **Single statement**
* The `return` statement can be embedded into: action, Behavior, Sequence of statements or action, 
* The `return` statement embeds statements:  
 	
#### Definition

Allows to specify which value to return from the evaluation of the surrounding statement. Usually used within the declaration of an action. For more details about actions, see the following [Section161 section].

### Usages

* Contrary to other languages, using return does not stop the evaluation of the surrounding statement (for instance, a loop). It simply indicates what value to return: if it is inside a loop, then, only the last evaluation of return will be returned. Example:
```string foo {
     return "foo";
}

reflex {
    string foo_result <- foo(); 	// foos_result is now equals to "foo"
}
 ```

* In the specific case one wants an agent to ask another agent to execute a statement with a return, it can be done similarly to:
```// In Species A:
string foo_different {
     return "foo_not_same";
}
/// ....
// In Species B:
reflex writing {
    string temp <- some_agent_A.foo_different []; 	// temp is now equals to "foo_not_same" 
}
 ```


[Top of the page](#table-of-contents)
	

----
### run 
#### Facets 
		  
  * **`experiment`** (string), (omissible) :   
  * **`of`** (string): 
  * `core` (int): 
  * `end_cycle` (int): 
  * `out` (string): 
  * `with_output` (map): 
  * `with_param` (map): 

#### Embedments
* The `run` statement is of type: **Sequence of statements or action**
* The `run` statement can be embedded into: Behavior, Single statement, Species, Model, 
* The `run` statement embeds statements: 

[Top of the page](#table-of-contents)
	

----
### save 
#### Facets 
		  
  * **`to`** (string): an expression that evaluates to an string, the path to the file
  * `data` (any type), (omissible) : any expression, that will be saved in the file
  * `crs` (any type): the name of the projectsion, e.g. crs:"EPSG:4326" or its EPSG id, e.g. crs:4326. Here a list of the CRS codes (and EPSG id): http://spatialreference.org
  * `rewrite` (boolean): an expression that evaluates to a boolean, specifying whether the save will ecrase the file or append data at the end of it
  * `type` (an identifier): an expression that evaluates to an string, the type of the output file (it can be only "shp", "text" or "csv")
  * `with` (map): 

#### Embedments
* The `save` statement is of type: **Single statement**
* The `save` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `save` statement embeds statements:  
 	
#### Definition

Allows to save data in a file. The type of file can be "shp", "text" or "csv".

### Usages

* Its simple syntax is:
```save data to: output_file type: a_type_file;
 ```

* To save data in a text file:
```save (string(cycle) + "->"  + name + ":" + location) to: "save_data.txt" type: "text";
 ```

* To save the values of some attributes of the current agent in csv file:
```save [name, location, host] to: "save_data.csv" type: "csv";
 ```

* To save the geometries of all the agents of a species into a shapefile (with optional attributes):
```save species_of(self) to: "save_shapefile.shp" type: "shp" with: [name::"nameAgent", location::"locationAgent"] crs: "EPSG:4326";
 ```

* The save statement can be use in an init block, a reflex, an action or in a user command. Do not use it in experiments.

[Top of the page](#table-of-contents)
	

----
### save_batch 
#### Facets 
		  
  * **`to`** (a label): 
  * `data` (any type), (omissible) : 
  * `rewrite` (boolean): 

#### Embedments
* The `save_batch` statement is of type: **Batch method**
* The `save_batch` statement can be embedded into: Experiment, 
* The `save_batch` statement embeds statements: 

[Top of the page](#table-of-contents)
	

----
### set 
#### Facets 
		  
  * **`name`** (any type), (omissible) : the name of an existin variable or attribute to be modified  
  * **`value`** (any type): the value to affect to the variable or attribute

#### Embedments
* The `set` statement is of type: **Single statement**
* The `set` statement can be embedded into: chart, Behavior, Sequence of statements or action, 
* The `set` statement embeds statements:  
 	
#### Definition

Allows to assign a value to the variable or attribute specified

### Usages

* Other examples of use: 
```

``` 
  

[Top of the page](#table-of-contents)
	

----
### setup 
#### Facets 
		

#### Embedments
* The `setup` statement is of type: **Sequence of statements or action**
* The `setup` statement can be embedded into: Species, Experiment, Model, 
* The `setup` statement embeds statements:  
 	
#### Definition

The setup statement is used to define the set of instructions that will be executed before every [#test test].

### Usages

* As every test should be independant from the others, the setup will mainly contain initialization of variables that will be used in each test.
```species Tester {
    int val_to_test;

    setup {
        val_to_test <- 0;
    }

    test t1 {
       // [set of instructions, including asserts]
    }
}
 ```
    
* See also: [test](#test), [assert](#assert), 

[Top of the page](#table-of-contents)
	

----
### signal 
#### Facets 
		  
  * **`name`** (a new identifier), (omissible) : The name of the variable that will be introduced to represent this signal on the specified grid  
  * **`decay`** (float): represents the amount to remove to the intensity of a signal, once dropped on a place, at each time step. It is a percentage between 0 and 1. If 'decay' is not defined, the signal will not be wiped from the places; otherwise, its intensity will be equal to (intensity `*` decay).
  * `among` (list): 
  * `environment` (species): The name of the grid species on which this signal will be propagated
  * `on` (any type in [species, container]): Either the name of the grid species on which this signal will be propagated (equivalent to 'environment:'), or an expression that returns a subset of the cells of this grid species
  * `propagation` (a label), takes values in: {diffusion, gradient}: represents both the way the signal is propagated and the way to treat multiple propagations of the same signal occuring at once from different places. If propagation equals 'diffusion', the intensity of a signal is shared between its neighbours with respect to 'proportion', 'variation' and the number of neighbours of the environment places (4, 6 or 8). I.e., for a given signal S propagated from place P, the value transmitted to its N neighbours is : S' = (S / N / proportion) - variation. The intensity of S is then diminished by S `*` proportion on P. In a diffusion, the different signals of the same name see their intensities added to each other on each place. If propagation equals 'gradient', the original intensity is not modified, and each neighbours receives the intensity : S / proportion - variation. If multiple propagations occur at once, only the maximum intensity is kept on each place. If 'propagation' is not defined, it is assumed that it is equal to 'diffusion'.
  * `proportion` (float): a value between 0 and 1 that represents the percentage of the intensity which will be shared between the neighbours in the diffusion. For instance, for an intensity of 80, and  a proportion of 0.5, in a 4-neighbours environment, each of the neighbouring places will receive an intensity of (80 `*` 0.5) / 4 = 10. If no 'proportion' is defined, it is assumed that the propagation corresponds to a diffusion where 100% of the intensity is equally divided between the neighbours. I.e., for an intensity of 100, and 4 neighbours per place, each of them receives a signal with an intensity of 25.
  * `range` (float): Indicates the distance (in meter) at which the signal stops propagating
  * `type` (a datatype identifier): 
  * `update` (any type): An expression that will be evaluated each cycle to update the value of the signal on each grid cell
  * `value` (any type): 
  * `variation` (float): an absolute decrease of intensity that occurs between each place. It should be a positive number. However, negative numbers are allowed (be aware, in this case, that if no range is defined, the signal will certainly propagate in the whole environment). If no 'variation' is defined, it defaults to 1 in the case of a gradient type and 0 in the case of a diffusion.

#### Embedments
* The `signal` statement is of type: **Variable (signal)**
* The `signal` statement can be embedded into: Species, 
* The `signal` statement embeds statements: 

[Top of the page](#table-of-contents)
	

----
### simulate 
#### Facets 
		  
  * **`comodel`** (file), (omissible) : 
  * `repeat` (int): 
  * `reset` (boolean): 
  * `share` (list): 
  * `until` (boolean): 
  * `with_experiment` (string): 
  * `with_input` (map): 
  * `with_output` (map): 

#### Embedments
* The `simulate` statement is of type: **Single statement**
* The `simulate` statement can be embedded into: chart, Experiment, Species, Behavior, Sequence of statements or action, 
* The `simulate` statement embeds statements:  
 	
#### Definition

Allows an agent, the sender agent (that can be the [Sections161#global world agent]), to ask another (or other) agent(s) to perform a set of statements. It obeys the following syntax, where the target attribute denotes the receiver agent(s):

### Usages

* Other examples of use: 
```
ask receiver_agent(s) {
     // [statements]
}
``` 
  

[Top of the page](#table-of-contents)
	

----
### solve 
#### Facets 
		  
  * **`equation`** (an identifier), (omissible) : the equation system identifier to be numerically solved
  * `cycle_length` (int): length of simulation cycle which will be synchronize with step of integrator (default value: 1)
  * `discretizing_step` (int): number of discret beside 2 step of simulation (default value: 0)
  * `integrated_times` (list): time interval inside integration process
  * `integrated_values` (list): list of variables's value inside integration process
  * `max_step` (float): maximal step, (used with dp853 method only), (sign is irrelevant, regardless of integration direction, forward or backward), the last step can be smaller than this value
  * `method` (an identifier), takes values in: {rk4, dp853}: integrate method (can be only "rk4" or "dp853") (default value: "rk4")
  * `min_step` (float): minimal step, (used with dp853 method only), (sign is irrelevant, regardless of integration direction, forward or backward), the last step can be smaller than this value
  * `scalAbsoluteTolerance` (float): allowed absolute error (used with dp853 method only)
  * `scalRelativeTolerance` (float): allowed relative error (used with dp853 method only)
  * `step` (float): integration step, use with most integrator methods (default value: 1)
  * `time_final` (float): target time for the integration (can be set to a value smaller than t0 for backward integration)
  * `time_initial` (float): initial time

#### Embedments
* The `solve` statement is of type: **Single statement**
* The `solve` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `solve` statement embeds statements:  
 	
#### Definition

Solves all equations which matched the given name, with all systems of agents that should solved simultaneously.

### Usages

* Other examples of use: 
```
solve SIR method: "rk4" step:0.001;
``` 
  

[Top of the page](#table-of-contents)
	

----
### species 
#### Facets 
		  
  * **`name`** (an identifier), (omissible) : the identifier of the species
  * `cell_height` (float): (grid only), the height of the cells of the grid
  * `cell_width` (float): (grid only), the width of the cells of the grid
  * `compile` (boolean): 
  * `control` (a label): defines the architecture of the species (e.g. fsm...)
  * `edge_species` (an identifier): In the case of a species defining a graph topology for its instances (nodes of the graph), specifies the species to use for representing the edges
  * `file` (file): (grid only), a bitmap file that will be loaded at runtime so that the value of each pixel  can be assigned to the attribute 'grid_value'
  * `frequency` (int): The execution frequency of the species (default value: 1). For instance, if frequency is set to 10, the population of agents will be executed only every 10 cycles.
  * `height` (int): (grid only),  the height of the grid (in terms of agent number)
  * `mirrors` (any type in [list, species]): The species this species is mirroring. The population of this current species will be dependent of that of the species mirrored (i.e. agents creation and death are entirely taken in charge by GAMA with respect to the demographics of the species mirrored). In addition, this species is provided with an attribute called 'target', which allows each agent to know which agent of the mirrored species it is representing.
  * `neighbours` (int): (grid only), the chosen neighbourhood (4, 6 or 8)
  * `parent` (an identifier): the parent class (inheritance)
  * `schedules` (container): A container of agents (a species, a dynamic list, or a combination of species and containers) , which represents which agents will be actually scheduled when the population is scheduled for execution. For instance, 'species a schedules: (10 among a)' will result in a population that schedules only 10 of its own agents every cycle. 'species b schedules: []' will prevent the agents of 'b' to be scheduled. Note that the scope of agents covered here can be larger than the population, which allows to build complex scheduling controls; for instance, defining 'global schedules: [] {...} species b schedules: []; species c schedules: b + world; ' allows to simulate a model where the agents of b are scheduled first, followed by the world, without even having to create an instance of c.
  * `skills` (list): The list of skills that will be made available to the instances of this species. Each new skill provides attributes and actions that will be added to the ones defined in this species
  * `topology` (topology): The topology of the population of agents defined by this species. In case of nested species, it can for example be the shape of the macro-agent. In case of grid or graph species, the topology is automatically computed and cannot be redefined
  * `torus` (boolean): is the topology toric (defaut: false). Needs to be defined on the global species.
  * `use_individual_shapes` (boolean): (grid only),(true by default). Allows to specify whether or not the agents of the grid will have distinct geometries. If set to false, they will all have simpler proxy geometries
  * `use_neighbours_cache` (boolean): (grid only),(true by default). Allows to turn on or off the use of the neighbours cache used for grids. Note that if a diffusion of variable occurs, GAMA will emit a warning and automatically switch to a caching version
  * `use_regular_agents` (boolean): (grid only),(true by default). Allows to specify if the agents of the grid are regular agents (like those of any other species) or minimal ones (which can't have sub-populations, can't inherit from a regular species, etc.)
  * `width` (int): (grid only), the width of the grid (in terms of agent number)

#### Embedments
* The `species` statement is of type: **Species**
* The `species` statement can be embedded into: Model, Environment, Species, 
* The `species` statement embeds statements:  
 	
#### Definition

The species statement allows modelers to define new species in the model. `global` and `grid` are speciel cases of species: `global` being the definition of the global agent (which has automatically one instance, world) and `grid` being a species with a grid topology.

### Usages

* Here is an example of a species definition with a FSM architecture and the additional skill moving:
```species ant skills: [moving] control: fsm {
 ```

* In the case of a species aiming at mirroring another one:
```species node_agent mirrors: list(bug) parent: graph_node edge_species: edge_agent {
 ```

* The definition of the single grid of a model will automatically create gridwidth x gridheight agents:
```grid ant_grid width: gridwidth height: gridheight file: grid_file neighbours: 8 use_regular_agents: false { 
 ```

* Using a file to initialize the grid can replace width/height facets:
```grid ant_grid file: grid_file neighbours: 8 use_regular_agents: false { 
 ```


[Top of the page](#table-of-contents)
	

----
### state 
#### Facets 
		  
  * **`name`** (an identifier), (omissible) : the identifier of the state
  * `final` (boolean): specifies whether the state is a final one (i.e. there is no transition from this state to another state) (default value= false)
  * `initial` (boolean): specifies whether the state is the initial one (default value = false)

#### Embedments
* The `state` statement is of type: **Behavior**
* The `state` statement can be embedded into: fsm, Species, Experiment, Model, 
* The `state` statement embeds statements: [#enter enter],  [#exit exit],   
 	
#### Definition

A state, like a reflex, can contains several statements that can be executed at each time step by the agent.

### Usages

* Here is an exemple integrating 2 states and the statements in the FSM architecture:
```	state s_init initial: true {
		enter { write "Enter in" + state; }
			write "Enter in" + state;
		}

		write state;

		transition to: s1 when: (cycle > 2) {
			write "transition s_init -> s1";
		}

		exit {
			write "EXIT from "+state;
		}
	}
	state s1 {

	enter {write 'Enter in '+state;}

	write state;

	exit {write 'EXIT from '+state;}
}
 ```
    
* See also: [enter](#enter), [exit](#exit), [transition](#transition), 

[Top of the page](#table-of-contents)
	

----
### status 
#### Facets 
		  
  * **`message`** (any type), (omissible) : Allows to display a necessarily short message in the status box in the upper left corner. No formatting characters (carriage returns, tabs, or Unicode characters) should be used, but a background color can be specified. The message will remain in place until it is replaced by another one or by nil, in which case the standard status (number of cycles) will be displayed again
  * `color` (rgb): 

#### Embedments
* The `status` statement is of type: **Single statement**
* The `status` statement can be embedded into: Behavior, Sequence of statements or action, Layer, 
* The `status` statement embeds statements:  
 	
#### Definition

The statement makes the agent output an arbitrary message in the status box.

### Usages

* Outputting a message
```status ('This is my status ' + self) color: yellow;
 ```


[Top of the page](#table-of-contents)
	

----
### switch 
#### Facets 
		  
  * **`value`** (any type), (omissible) : an expression

#### Embedments
* The `switch` statement is of type: **Sequence of statements or action**
* The `switch` statement can be embedded into: Behavior, Sequence of statements or action, Layer, 
* The `switch` statement embeds statements: [#default default],  [#match match],   
 	
#### Definition

The "switch... match" statement is a powerful replacement for imbricated "if ... else ..." constructs. All the blocks that match are executed in the order they are defined. The block prefixed by default is executed only if none have matched (otherwise it is not).

### Usages

* The prototypical syntax is as follows:
```switch an_expression {
        match value1 {...}
        match_one [value1, value2, value3] {...}
        match_between [value1, value2] {...}
        default {...}
}
 ```

* Example:
```switch 3 {
   match 1 {write "Match 1"; }
   match 2 {write "Match 2"; }
   match 3 {write "Match 3"; }
   match_one [4,4,6,3,7]  {write "Match one_of"; }
   match_between [2, 4] {write "Match between"; }
   default {write "Match Default"; }
}
 ```
    
* See also: [match](#match), [default](#default), [if](#if), 

[Top of the page](#table-of-contents)
	

----
### tabu 
#### Facets 
		  
  * **`name`** (an identifier), (omissible) : 
  * `aggregation` (a label), takes values in: {min, max}: the agregation method
  * `iter_max` (int): number of iterations
  * `maximize` (float): the value the algorithm tries to maximize
  * `minimize` (float): the value the algorithm tries to minimize
  * `tabu_list_size` (int): size of the tabu list

#### Embedments
* The `tabu` statement is of type: **Batch method**
* The `tabu` statement can be embedded into: Experiment, 
* The `tabu` statement embeds statements:  
 	
#### Definition

This algorithm is an implementation of the Tabu Search algorithm. See the wikipedia article and [batch161 the batch dedicated page].

### Usages

* As other batch methods, the basic syntax of the tabu statement uses `method tabu` instead of the expected `tabu name: id` : 
```method tabu [facet: value];
 ```

* For example: 
```method tabu iter_max: 50 tabu_list_size: 5 maximize: food_gathered;
 ```


[Top of the page](#table-of-contents)
	

----
### task 
#### Facets 
		  
  * **`name`** (an identifier), (omissible) : the identifier of the task  
  * **`weight`** (float): the priority level of the task

#### Embedments
* The `task` statement is of type: **Behavior**
* The `task` statement can be embedded into: weighted_tasks, sorted_tasks, probabilistic_tasks, Species, Experiment, Model, 
* The `task` statement embeds statements:  
 	
#### Definition

As reflex, a task is a sequence of statements that can be executed, at each time step, by the agent. If an agent owns several tasks, the scheduler chooses a task to execute based on its current priority weight value.

### Usages


[Top of the page](#table-of-contents)
	

----
### test 
#### Facets 
		
  * `name` (an identifier), (omissible) : identifier of the test

#### Embedments
* The `test` statement is of type: **Behavior**
* The `test` statement can be embedded into: Species, Experiment, Model, 
* The `test` statement embeds statements: [#assert assert],   
 	
#### Definition

The test statement allows modeler to define a set of assertions that will be tested. Before the execution of the embeded set of instructions, if a setup is defined in the species, model or experiment, it is executed. In a test, if one assertion fails, the evaluation of other assertions continue (if GAMA is configured in the preferences that the program does not stop at the first exception).

### Usages

* An example of use:
```species Tester {
    // set of attributes that will be used in test

    setup {
        // [set of instructions... in particular initializations]
    }

    test t1 {
       // [set of instructions, including asserts]
    }
}
 ```
    
* See also: [setup](#setup), [assert](#assert), 

[Top of the page](#table-of-contents)
	

----
### text 
#### Facets 
		  
  * **`name`** (string), (omissible) : the string to display
  * `color` (rgb): the color used to display the text
  * `font` (any type in [19, string]): the font used for the text
  * `position` (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greter than 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.
  * `refresh` (boolean): (openGL only) specify whether the display of the text is refreshed. (true by default, usefull in case of text that is not been modified over simulation)
  * `size` (any type in [int, float, point]): the layer resize factor: {1,1} refers to the original size whereas {0.5,0.5} divides it by 2
  * `style` (an identifier), takes values in: {plain, bold, italic}: the style (bold, italic...) udes to display the text
  * `transparency` (float): the transparency rate of the agents (between 0 and 1, 1 means no transparency)
  * `value` (string): 

#### Embedments
* The `text` statement is of type: **Layer**
* The `text` statement can be embedded into: display, 
* The `text` statement embeds statements:  
 	
#### Definition

`text` allows the modeler to display a string (that can change at each step) in a given position of the display.

### Usages

* The general syntax is:
```display my_display {
   text expression [additional options];
}
 ```

* For instance, in a segregation model, `agents` will only display unhappy agents:
```display Segregation {
   text 'Carrying ants : ' + (int(ant as list count(each.has_food)) + int(ant as list count(each.state = 'followingRoad'))) position: {0.5,0.03} color: rgb('black') size: {1,0.02};
}
 ```
    
* See also: [display](#display), [agents](#agents), [chart](#chart), [event](#event), [graphics](#graphics), [display_grid](#display_grid), [image](#image), [overlay](#overlay), [quadtree](#quadtree), [display_population](#display_population), 

[Top of the page](#table-of-contents)
	

----
### trace 
#### Facets 
		

#### Embedments
* The `trace` statement is of type: **Sequence of statements or action**
* The `trace` statement can be embedded into: Behavior, Sequence of statements or action, Layer, 
* The `trace` statement embeds statements:  
 	
#### Definition

All the statements executed in the trace statement are displayed in the console.

### Usages


[Top of the page](#table-of-contents)
	

----
### transition 
#### Facets 
		  
  * **`to`** (an identifier): the identifier of the next state
  * `when` (boolean), (omissible) : a condition to be fulfilled to have a transition to another given state

#### Embedments
* The `transition` statement is of type: **Sequence of statements or action**
* The `transition` statement can be embedded into: Sequence of statements or action, Behavior, 
* The `transition` statement embeds statements:  
 	
#### Definition

In an FSM architecture, `transition` specifies the next state of the life cycle. The transition occurs when the condition is fulfilled. The embedded statements are executed when the transition is triggered.

### Usages

* In the following example, the transition is executed when after 2 steps:
```	state s_init initial: true {
		write state;
		transition to: s1 when: (cycle > 2) {
			write "transition s_init -> s1";
		}
	}
 ```
    
* See also: [enter](#enter), [state](#state), [exit](#exit), 

[Top of the page](#table-of-contents)
	

----
### user_command 
#### Facets 
		  
  * **`name`** (a label), (omissible) : the identifier of the user_command
  * `action` (an identifier): the identifier of the action to be executed
  * `when` (boolean): the condition that should be fulfille in order that the action is executed
  * `with` (map): the map of the parameters::values that requires the action

#### Embedments
* The `user_command` statement is of type: **Sequence of statements or action**
* The `user_command` statement can be embedded into: user_panel, Species, Experiment, Model, 
* The `user_command` statement embeds statements: [#user_input user_input],   
 	
#### Definition

Anywhere in the global block, in a species or in an (GUI) experiment, user_command statements allows to either call directly an existing action (with or without arguments) or to be followed by a block that describes what to do when this command is run.

### Usages

* The general syntax is for example:
```user_command kill_myself action: some_action with: [arg1::val1, arg2::val2, ...];
 ```
    
* See also: [user_init](#user_init), [user_panel](#user_panel), [user_input](#user_input), 

[Top of the page](#table-of-contents)
	

----
### user_init 
#### Facets 
		  
  * **`name`** (an identifier), (omissible) : 
  * `initial` (boolean): 

#### Embedments
* The `user_init` statement is of type: **Behavior**
* The `user_init` statement can be embedded into: Species, Experiment, Model, 
* The `user_init` statement embeds statements: [#user_panel user_panel],   
 	
#### Definition

Used in the user control architecture, user_init is executed only once when the agent is created. It opens a special panel (if it contains user_commands statements). It is the equivalent to the init block in the basic agent architecture.

### Usages
    
* See also: [user_command](#user_command), [user_init](#user_init), [user_input](#user_input), 

[Top of the page](#table-of-contents)
	

----
### user_input 
#### Facets 
		  
  * **`returns`** (a new identifier): a new local variable containing the value given by the user
  * `name` (a label), (omissible) : the displayed name
  * `among` (list): the set of acceptable values for the variable
  * `init` (any type): the init value
  * `max` (float): the maximum value
  * `min` (float): the minimum value
  * `type` (a datatype identifier): the variable type

#### Embedments
* The `user_input` statement is of type: **Single statement**
* The `user_input` statement can be embedded into: user_command, 
* The `user_input` statement embeds statements:  
 	
#### Definition

It allows to let the user define the value of a variable.

### Usages

* Other examples of use: 
```
user_panel "Advanced Control" {
	user_input "Location" returns: loc type: point <- {0,0};
	create cells number: 10 with: [location::loc];
}
``` 
      
* See also: [user_command](#user_command), [user_init](#user_init), [user_panel](#user_panel), 

[Top of the page](#table-of-contents)
	

----
### user_panel 
#### Facets 
		  
  * **`name`** (an identifier), (omissible) : 
  * `initial` (boolean): 

#### Embedments
* The `user_panel` statement is of type: **Behavior**
* The `user_panel` statement can be embedded into: fsm, user_first, user_last, user_init, user_only, Species, Experiment, Model, 
* The `user_panel` statement embeds statements: [#user_command user_command],   
 	
#### Definition

It is the basic behavior of the user control architecture (it is similar to state for the FSM architecture). This user_panel translates, in the interface, in a semi-modal view that awaits the user to choose action buttons, change attributes of the controlled agent, etc. Each user_panel, like a state in FSM, can have a enter and exit sections, but it is only defined in terms of a set of user_commands which describe the different action buttons present in the panel.

### Usages

* The general syntax is for example:
```user_panel default initial: true {
	user_input 'Number' returns: number type: int <- 10;
	ask (number among list(cells)){ do die; }
	transition to: "Advanced Control" when: every (10);
}

user_panel "Advanced Control" {
	user_input "Location" returns: loc type: point <- {0,0};
	create cells number: 10 with: [location::loc];
}
 ```
    
* See also: [user_command](#user_command), [user_init](#user_init), [user_input](#user_input), 

[Top of the page](#table-of-contents)
	

----
### using 
#### Facets 
		  
  * **`topology`** (topology), (omissible) : the topology

#### Embedments
* The `using` statement is of type: **Sequence of statements or action**
* The `using` statement can be embedded into: chart, Behavior, Sequence of statements or action, 
* The `using` statement embeds statements:  
 	
#### Definition

`using` is a statement that allows to set the topology to use by its sub-statements. They can gather it by asking the scope to provide it.

### Usages

* All the spatial operations are topology-dependent (e.g. neighbors are not the same in a continuous and in a grid topology). So `using` statement allows modelers to specify the topology in which the spatial operation will be computed.
```float dist <- 0.0;
using topology(grid_ant) {
	d (self.location distance_to target.location);
}
 ```


[Top of the page](#table-of-contents)
	

----
### warn 
#### Facets 
		  
  * **`message`** (string), (omissible) : the message to display as a warning.

#### Embedments
* The `warn` statement is of type: **Single statement**
* The `warn` statement can be embedded into: Behavior, Sequence of statements or action, Layer, 
* The `warn` statement embeds statements:  
 	
#### Definition

The statement makes the agent output an arbitrary message in the error view as a warning.

### Usages

* Emmitting a warning
```warn 'This is a warning from ' + self;
 ```


[Top of the page](#table-of-contents)
	

----
### write 
#### Facets 
		  
  * **`message`** (any type), (omissible) : the message to display. Modelers can add some formatting characters to the message (carriage returns, tabs, or Unicode characters), which will be used accordingly in the console.

#### Embedments
* The `write` statement is of type: **Single statement**
* The `write` statement can be embedded into: Behavior, Sequence of statements or action, Layer, 
* The `write` statement embeds statements:  
 	
#### Definition

The statement makes the agent output an arbitrary message in the console.

### Usages

* Outputting a message
```write 'This is a message from ' + self;
 ```


[Top of the page](#table-of-contents)
	