# Statements
---- 	
**This file is automatically generated from java files. Do Not Edit It.**

----

## Table of Contents
<wiki:toc max_depth="2" />
[=](#=), [assert](#assert), [diffusion](#diffusion), [draw](#draw), [equation](#equation), [layout_forceatlas2](#layout_forceatlas2), [layout_yifanhu](#layout_yifanhu), [pause_sound](#pause_sound), [plan](#plan), [resume_sound](#resume_sound), [run](#run), [solve](#solve), [start_sound](#start_sound), [stop_sound](#stop_sound), [test](#test), 


## Statements by kinds

* **Behavior**
  * [plan](#plan),  [test](#test),  
* **Sequence of statements or action**
  * [equation](#equation),  [pause_sound](#pause_sound),  [resume_sound](#resume_sound),  [run](#run),  [start_sound](#start_sound),  [stop_sound](#stop_sound),  
* **Single statement**
  * [=](#=),  [assert](#assert),  [diffusion](#diffusion),  [draw](#draw),  [layout_forceatlas2](#layout_forceatlas2),  [layout_yifanhu](#layout_yifanhu),  [solve](#solve),  


## Statements by embedment

* **Behavior**
  * [diffusion](#diffusion), [layout_forceatlas2](#layout_forceatlas2), [layout_yifanhu](#layout_yifanhu), [pause_sound](#pause_sound), [resume_sound](#resume_sound), [run](#run), [solve](#solve), [start_sound](#start_sound), [stop_sound](#stop_sound), 
* **Experiment**
  * [test](#test), 
* **Layer**
  * [draw](#draw), 
* **Model**
  * [equation](#equation), [run](#run), [test](#test), 
* **Sequence of statements or action**
  * [diffusion](#diffusion), [draw](#draw), [layout_forceatlas2](#layout_forceatlas2), [layout_yifanhu](#layout_yifanhu), [pause_sound](#pause_sound), [resume_sound](#resume_sound), [solve](#solve), [start_sound](#start_sound), [stop_sound](#stop_sound), 
* **Single statement**
  * [run](#run), 
* **Species**
  * [equation](#equation), [plan](#plan), [run](#run), [test](#test), 
* **aspect**
  * [draw](#draw), 
* **equation**
  * [=](#=), 
* **test**
  * [assert](#assert), 


## General syntax

A statement represents either a declaration or an imperative command. It consists in a keyword, followed by specific facets, some of them mandatory (in bold), some of them optional. One of the facet names can be ommitted (the one denoted as omissible). It has to be the first one.

```
statement_keyword expression1 facet2: expression2 ... ;
or
statement_keyword facet1: expression1 facet2: expression2 ...;
```

If the statement encloses other statements, it is called a **sequence statement**, and its sub-statements (either sequence statements or single statements) are declared between curly brackets, as in:

```
statement_keyword1 expression1 facet2: expression2... { // a sequence statement
     statement_keyword2 expression1 facet2: expression2...;  // a single statement
     statement_keyword3 expression1 facet2: expression2...;
}
```

[Top of the page](#table-of-contents)

	
<br/>
----
### = 
#### Facets 
		  
  * **`right`** (float), (omissible) : the right part of the equation (it is mandatory that it can be evaluate to a float  
  * **`left`** (any type): the left part of the equation (it should be a variable or a call to the diff() or diff2() operators)

#### Embedments
* The `=` statement is of type: **Single statement**
* The `=` statement can be embedded into: equation, 
* The `=` statement embeds statements:  
 	
#### Definition

Allows to implement an equation in the form function(n, t) = expression. The left function is only here as a placeholder for enabling a simpler syntax and grabbing the variable as its left member.

### Usages

* The syntax of the = statement is a bit different from the other statements. It hase to be used as follows (in an equation):
```float t;
float S;
float I;
equation SI { 
   diff(S,t) = (- 0.3 * S * I / 100);
   diff(I,t) = (0.3 * S * I / 100);
} 
 ```
    
* See also: [equation](#equation), [solve](#solve), 

[Top of the page](#table-of-contents)
	
<br/>
----
### assert 
#### Facets 
		  
  * **`value`** (any type), (omissible) : the value that is evaluated and compared to other facets
  * `equals` (any type): an expresion, assert tests whether the value is equals to this expression
  * `is_not` (any type): an expression, assert tests whether the value is not equals to this expression
  * `raises` (an identifier): "error" or "warning", used in testing what raises the evaluation of the value: expresion

#### Embedments
* The `assert` statement is of type: **Single statement**
* The `assert` statement can be embedded into: test, 
* The `assert` statement embeds statements:  
 	
#### Definition

Allows to check whether the evaluation of a given expression fulfils a given condition. If it is not fulfilled, an exception is raised.

### Usages

* if the equals: facet is used, the equality between the evaluation of expressions in the value: and in the equals: facets is tested
```assert (2+2) equals: 4;
 ```

* if the is_not: facet is used, the inequality between the evaluation of expressions in the value: and in the equals: facets is tested
```assert self is_not: nil;
 ```

* if the raises: facet is used with either "warning" or "error", the statement tests whether the evaluation of the value: expression raises an error (resp. a warning)
```int z <- 0;
assert (3/z) raises: "error";
 ```
    
* See also: [test](#test), [setup](#setup), 

[Top of the page](#table-of-contents)
	
<br/>
----
### diffusion 
#### Facets 
		  
  * **`var`** (an identifier), (omissible) : the variable to be diffused  
  * **`on`** (an identifier): the species (in general a grid), on which the diffusion will occur
  * `cycle_length` (int): the number of diffusion operation applied in one simulation step
  * `mask` (matrix): a matrix masking the diffusion (matrix created from a image for example)
  * `mat_diffu` (matrix): the diffusion matrix (can have any size)
  * `method` (an identifier), takes values in: {convolution, dot_product}: the diffusion method
  * `proportion` (float): a diffusion rate
  * `radius` (int): a diffusion radius

#### Embedments
* The `diffusion` statement is of type: **Single statement**
* The `diffusion` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `diffusion` statement embeds statements:  
 	
#### Definition

This statements allows a value to diffuse among a species on agents (generally on a grid) depending on a given diffusion matrix.

### Usages

* A basic example of diffusion of the variable phero defined in the species cells, given a diffusion matrix math_diff is:
```matrix<float> math_diff <- matrix([[1/9,1/9,1/9],[1/9,1/9,1/9],[1/9,1/9,1/9]]);
diffusion var: phero on: cells mat_diffu: math_diff;
 ```

* The diffusion can be masked by obstacles, created from a bitmap image:
```diffusion var: phero on: cells mat_diffu: math_diff mask: mymask;
 ```

* A convenient way to have an uniform diffusion in a given radius is (which is equivalent to the above diffusion):
```diffusion var: phero on: cells proportion: 1/9 radius: 1;
 ```


[Top of the page](#table-of-contents)
	
<br/>
----
### draw 
#### Facets 
		
  * `geometry` (any type), (omissible) : any type of data (it can be geometry, image, text)
  * `at` (point): location where the shape/text/icon is drawn
  * `begin_arrow` (any type in [int, float]): the size of the arrow, located at the beginning of the drawn geometry
  * `bitmap` (boolean): 
  * `border` (any type in [rgb, boolean]): if used with a color, represents the color of the geometry border. If set to false, expresses that no border should be drawn. If not set, the borders will be drawn using the color of the geometry.
  * `color` (rgb): the color to use to display the text/icon/geometry
  * `depth` (float): (only if the display type is opengl) Add a depth to the geometry previously defined (a line becomes a plan, a circle becomes a cylinder, a square becomes a cube, a polygon becomes a polyhedron with height equal to the depth value). Note: This only works if a the agent has not a point geometry
  * `empty` (boolean): a condition specifying whether the geometry is empty or full
  * `end_arrow` (any type in [int, float]): the size of the arrow, located at the end of the drawn geometry
  * `font` (any type in [19, string]): the font used to draw the text
  * `image` (string): path of the icon to draw (JPEG, PNG, GIF)
  * `rotate` (any type in [float, int]): orientation of the shape/text/icon
  * `rotate3D` (pair): orientation of the shape/text/icon
  * `rounded` (boolean): specify whether the geometry have to be rounded (e.g. for squares)
  * `scale` (float): 
  * `shape` (any type): the shape to display
  * `size` (float): size of the text/icon (not used in the context of the drawing of a geometry)
  * `style` (an identifier), takes values in: {plain, bold, italic}: the style used to display text
  * `text` (string): the text to draw
  * `texture` (any type in [string, list]): the texture that should be applied to the geometry
  * `to` (point): 

#### Embedments
* The `draw` statement is of type: **Single statement**
* The `draw` statement can be embedded into: aspect, Sequence of statements or action, Layer, 
* The `draw` statement embeds statements:  
 	
#### Definition

`draw` is used in an aspect block to expresse how agents of the species will be drawn. It is evaluated each time the agent has to be drawn. It can also be used in the graphics block.

### Usages

* Any kind of geometry as any location can be drawn when displaying an agent (independently of his shape)
```aspect geometryAspect {
	draw circle(1.0) empty: !hasFood color: #orange ;
}
 ```

* Image or text can also be drawn
```aspect arrowAspect {
	draw "Current state= "+state at: location + {-3,1.5} color: #white font: font('Default', 12, #bold) ;
	draw file(ant_shape_full) rotate: heading at: location size: 5
}
 ```

* Arrows can be drawn with any kind of geometry, using begin_arrow and end_arrow facets, combined with the empty: facet to specify whether it is plain or empty
```aspect arrowAspect {
	draw line([{20, 20}, {40, 40}]) color: #black begin_arrow:5;
	draw line([{10, 10},{20, 50}, {40, 70}]) color: #green end_arrow: 2 begin_arrow: 2 empty: true;
	draw square(10) at: {80,20} color: #purple begin_arrow: 2 empty: true;
}
 ```


[Top of the page](#table-of-contents)
	
<br/>
----
### equation 
#### Facets 
		  
  * **`name`** (an identifier), (omissible) : the equation identifier
  * `params` (list): the list of pramameters used in predefined equation systems
  * `simultaneously` (list): a list of agents containing a system of equations (all systems will be solved simultaneously)
  * `type` (an identifier), takes values in: {SI, SIS, SIR, SIRS, SEIR, LV}: the choice of one among classical models (SI, SIS, SIR, SIRS, SEIR, LV)
  * `vars` (list): the list of variables used in predefined equation systems

#### Embedments
* The `equation` statement is of type: **Sequence of statements or action**
* The `equation` statement can be embedded into: Species, Model, 
* The `equation` statement embeds statements: [#= =],   
 	
#### Definition

The equation statement is used to create an equation system from several single equations.

### Usages

* The basic syntax to define an equation system is:
```float t;
float S;
float I;
equation SI { 
   diff(S,t) = (- 0.3 * S * I / 100);
   diff(I,t) = (0.3 * S * I / 100);
} 
 ```

* If the type: facet is used, a predefined equation system is defined using variables vars: and parameters params: in the right order. All possible predefined equation systems are the following ones (see [EquationPresentation161 EquationPresentation161] for precise definition of each classical equation system): 
```equation eqSI type: SI vars: [S,I,t] params: [N,beta];
equation eqSIS type: SIS vars: [S,I,t] params: [N,beta,gamma];
equation eqSIR type:SIR vars:[S,I,R,t] params:[N,beta,gamma];
equation eqSIRS type: SIRS vars: [S,I,R,t] params: [N,beta,gamma,omega,mu];
equation eqSEIR type: SEIR vars: [S,E,I,R,t] params: [N,beta,gamma,sigma,mu];
equation eqLV type: LV vars: [x,y,t] params: [alpha,beta,delta,gamma] ;
 ```

* If the simultaneously: facet is used, system of all the agents will be solved simultaneously.    
* See also: [=](#=), [solve](#solve), 

[Top of the page](#table-of-contents)
	
<br/>
----
### layout_forceatlas2 
#### Facets 
		  
  * **`graph`** (graph), (omissible) : the graph to apply the layout.
  * `approximate_repulsion` (boolean): Barnes Hut optimization: n2 complexity to n.ln(n); allows larger graphs. default: false
  * `approximation` (float): Theta of the Barnes Hut optimization. default: 1.2
  * `bounded_point1` (point): The new nodes positions are bounded within the two bound points if both are not null. default: null
  * `bounded_point2` (point): The new nodes positions are bounded within the two bound points if both are not null. default: null
  * `dissuade_hubs` (boolean): Distributes attraction along outbound edges. Hubs attract less and thus are pushed to the borders (default: false).
  * `edge_weight_influence` (float): How much influence you give to the edges wight. 0 is no influence, 1 is normal. default: 1.0
  * `gravity` (float): Attracts nodes to the center. Prevents islands from drifting away. default: 1.0
  * `linlog_mode` (boolean): Switch model from lin-lin to lin-log. Makes clusters more tight (default: false).
  * `nb_steps` (int): The number of steps of the algorithm to perform (default 1).
  * `prevent_overlap` (boolean): Should not be used with approximate_repulsion default: false
  * `scaling` (float): How much repulsion you want. More makes a more sparse graph. default: 2.0
  * `stronger_gravity` (boolean): A stronger gravity law default: false
  * `thread_number` (int): More threads means more speed (default: 1).
  * `tolerance` (float): How much swinging you allow. Above 1 discouraged. Lower gives less speed and more precision. default: 0.1

#### Embedments
* The `layout_forceatlas2` statement is of type: **Single statement**
* The `layout_forceatlas2` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `layout_forceatlas2` statement embeds statements: 

[Top of the page](#table-of-contents)
	
<br/>
----
### layout_yifanhu 
#### Facets 
		  
  * **`graph`** (graph), (omissible) : the graph to apply the layout.
  * `bounded_point1` (point): The new nodes positions are bounded within the two bound points if both are not null. default: null
  * `bounded_point2` (point): The new nodes positions are bounded within the two bound points if both are not null. default: null
  * `nb_steps` (int): The number of steps of the algorithm to perform (default 1).
  * `optimal_distance` (float): the natural length of the springs. Bigger values mean nodes will be farther apart (default: 100).
  * `quadtree_max_level` (int): The maximum level to be used in the quadtree representation. Greater values mean more accuracy (default: 10).
  * `relative_strength` (float): The relative strength between electrical force (repulsion) and spring force (attriaction). default: 0.2
  * `step_size` (float): The step size used in the algorithm. It has to be a meaningful size compared to the optimal distance (e.g. 10%). default: 10
  * `theta` (float): The theta parameter for Barnes-Hut opening criteria. Smaller values mean more accuracy (default: 1.2).

#### Embedments
* The `layout_yifanhu` statement is of type: **Single statement**
* The `layout_yifanhu` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `layout_yifanhu` statement embeds statements: 

[Top of the page](#table-of-contents)
	
<br/>
----
### pause_sound 
#### Facets 
		

#### Embedments
* The `pause_sound` statement is of type: **Sequence of statements or action**
* The `pause_sound` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `pause_sound` statement embeds statements: 

[Top of the page](#table-of-contents)
	
<br/>
----
### plan 
#### Facets 
		
  * `name` (an identifier), (omissible) : 
  * `finished_when` (boolean): 
  * `instantaneous` (boolean): 
  * `intention` (any type): 
  * `priority` (float): 
  * `when` (boolean): 

#### Embedments
* The `plan` statement is of type: **Behavior**
* The `plan` statement can be embedded into: Species, 
* The `plan` statement embeds statements: 

[Top of the page](#table-of-contents)
	
<br/>
----
### resume_sound 
#### Facets 
		

#### Embedments
* The `resume_sound` statement is of type: **Sequence of statements or action**
* The `resume_sound` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `resume_sound` statement embeds statements: 

[Top of the page](#table-of-contents)
	
<br/>
----
### run 
#### Facets 
		  
  * **`experiment`** (string), (omissible) :   
  * **`of`** (string): 
  * `core` (int): 
  * `end_cycle` (int): 
  * `out` (string): 
  * `with_output` (map): 
  * `with_param` (map): 

#### Embedments
* The `run` statement is of type: **Sequence of statements or action**
* The `run` statement can be embedded into: Behavior, Single statement, Species, Model, 
* The `run` statement embeds statements: 

[Top of the page](#table-of-contents)
	
<br/>
----
### solve 
#### Facets 
		  
  * **`equation`** (an identifier), (omissible) : the equation system identifier to be numerically solved
  * `cycle_length` (int): length of simulation cycle which will be synchronize with step of integrator (default value: 1)
  * `discretizing_step` (int): number of discret beside 2 step of simulation (default value: 0)
  * `integrated_times` (list): time interval inside integration process
  * `integrated_values` (list): list of variables's value inside integration process
  * `max_step` (float): maximal step, (used with dp853 method only), (sign is irrelevant, regardless of integration direction, forward or backward), the last step can be smaller than this value
  * `method` (an identifier), takes values in: {rk4, dp853}: integrate method (can be only "rk4" or "dp853") (default value: "rk4")
  * `min_step` (float): minimal step, (used with dp853 method only), (sign is irrelevant, regardless of integration direction, forward or backward), the last step can be smaller than this value
  * `scalAbsoluteTolerance` (float): allowed absolute error (used with dp853 method only)
  * `scalRelativeTolerance` (float): allowed relative error (used with dp853 method only)
  * `step` (float): integration step, use with most integrator methods (default value: 1)
  * `time_final` (float): target time for the integration (can be set to a value smaller than t0 for backward integration)
  * `time_initial` (float): initial time

#### Embedments
* The `solve` statement is of type: **Single statement**
* The `solve` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `solve` statement embeds statements:  
 	
#### Definition

Solves all equations which matched the given name, with all systems of agents that should solved simultaneously.

### Usages

* Other examples of use: 
```
solve SIR method: "rk4" step:0.001;
``` 
  

[Top of the page](#table-of-contents)
	
<br/>
----
### start_sound 
#### Facets 
		  
  * **`source`** (string): The path to music file. This path is relative to the path of the model.
  * `mode` (an identifier), takes values in: {overwrite, ignore}: Mode of
  * `repeat` (boolean): 

#### Embedments
* The `start_sound` statement is of type: **Sequence of statements or action**
* The `start_sound` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `start_sound` statement embeds statements: 

[Top of the page](#table-of-contents)
	
<br/>
----
### stop_sound 
#### Facets 
		

#### Embedments
* The `stop_sound` statement is of type: **Sequence of statements or action**
* The `stop_sound` statement can be embedded into: Behavior, Sequence of statements or action, 
* The `stop_sound` statement embeds statements: 

[Top of the page](#table-of-contents)
	
<br/>
----
### test 
#### Facets 
		
  * `name` (an identifier), (omissible) : identifier of the test

#### Embedments
* The `test` statement is of type: **Behavior**
* The `test` statement can be embedded into: Species, Experiment, Model, 
* The `test` statement embeds statements: [#assert assert],   
 	
#### Definition

The test statement allows modeler to define a set of assertions that will be tested. Before the execution of the embeded set of instructions, if a setup is defined in the species, model or experiment, it is executed. In a test, if one assertion fails, the evaluation of other assertions continue (if GAMA is configured in the preferences that the program does not stop at the first exception).

### Usages

* An example of use:
```species Tester {
    // set of attributes that will be used in test

    setup {
        // [set of instructions... in particular initializations]
    }

    test t1 {
       // [set of instructions, including asserts]
    }
}
 ```
    
* See also: [setup](#setup), [assert](#assert), 

[Top of the page](#table-of-contents)
	