# Operators 
----
**This file is automatically generated from java files. Do Not Edit It.**
----

## Definition 

Operators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function. 

Most of them use a classical prefixed functional syntax (i.e. `operator_name(operand1, operand2, operand3)`, see below), with the exception of arithmetic (e.g. `+`, `/`), logical (`and`, `or`), comparison (e.g. `>`, `<`), access (`.`, `[..]`) and pair (`::`) operators, which require an infixed notation (i.e. `operand1 operator_symbol operand1`). 

The ternary functional if-else operator, `? :`, uses a special infixed syntax composed with two symbols (e.g. `operand1 ? operand2 : operand3`). Two unary operators (`-` and `!`) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g. ` - 10`, `! (operand1 or operand2)`). 

Finally, special constructor operators (`{...}` for constructing points, `[...]` for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. `{1,2,3}`, `[operand1, operand2, ..., operandn]` or `[key1::value1, key2::value2... keyn::valuen]`).

With the exception of these special cases above, the following rules apply to the syntax of operators:
* if they only have one operand, the functional prefixed syntax is mandatory (e.g. `operator_name(operand1)`)
* if they have two arguments, either the functional prefixed syntax (e.g. `operator_name(operand1, operand2)`) or the infixed syntax (e.g. `operand1 operator_name operand2`) can be used.
* if they have more than two arguments, either the functional prefixed syntax (e.g. `operator_name(operand1, operand2, ..., operand)`) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. `operand1 operator_name(operand2, ..., operand)`) can be used.

All of these alternative syntaxes are completely equivalent.

Operators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the `shuffle` operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.

<br/>
----

## Priority between operators

The priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first.

GAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely:
* the constructor operators, like `::`, used to compose pairs of operands, have the lowest priority of all operators (e.g. `a > b :: b > c` will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, `[a > 10, b > 5]` will return a list of boolean values.
* it is followed by the `?:` operator, the functional if-else (e.g. ` a > b ? a + 10 : a - 10` will return the result of the if-else).
* next are the logical operators, `and` and `or` (e.g. `a > b or b > c` will return the value of the test)
* next are the comparison operators (i.e. `>`, `<`, `<=`, `>=`, `=`, `!=`)
* next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)
* next the unary operators `-` and `!`
* next the access operators `.` and `[]` (e.g. `{1,2,3}.x > 20 + {4,5,6}.y` will return the result of the comparison between the x and y ordinates of the two points)
* and finally the functional operators, which have the highest priority of all.

<br/>
----

## Using actions as operators

Actions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand.

For instance, if the following species is defined:

```
species spec1 {
        int min(int x, int y) {
                return x > y ? x : y;
        }
}```

Any agent instance of spec1 can use `min` as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:

```
global {
        init {
                create spec1;
                spec1 my_agent <- spec1[0];
                int the_min <- my_agent min(10,20); // or min(my_agent, 10, 20);
        }
}```

If the action doesn't have any operands, the syntax to use is `my_agent the_action()`. Finally, if it does not return a value, it might still be used but is considering as returning a value of type `unknown` (e.g. `unknown result <- my_agent the_action(op1, op2);`).

Note that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).

[Top of the page](#table-of-contents)
	
<br/>
----

## Table of Contents

<br/>
----

## Operators by categories
	
<br/>
----

### 3D
[box](#box), [cone3D](#cone3D), [cube](#cube), [cylinder](#cylinder), [dem](#dem), [hexagon](#hexagon), [pyramid](#pyramid), [rgb_to_xyz](#rgb_to_xyz), [set_z](#set_z), [sphere](#sphere), [teapot](#teapot), 
<br/>
----

### DescriptiveStatistics
[auto_correlation](#auto_correlation), [correlation](#correlation), [covariance](#covariance), [durbin_watson](#durbin_watson), [kurtosis](#kurtosis), [moment](#moment), [quantile](#quantile), [quantile_inverse](#quantile_inverse), [rank_interpolated](#rank_interpolated), [rms](#rms), [skew](#skew), [variance](#variance), 
<br/>
----

### Distributions
[binomial_coeff](#binomial_coeff), [binomial_complemented](#binomial_complemented), [binomial_sum](#binomial_sum), [chi_square](#chi_square), [chi_square_complemented](#chi_square_complemented), [gamma_distribution](#gamma_distribution), [gamma_distribution_complemented](#gamma_distribution_complemented), [normal_area](#normal_area), [normal_density](#normal_density), [normal_inverse](#normal_inverse), [pValue_for_fStat](#pValue_for_fStat), [pValue_for_tStat](#pValue_for_tStat), [student_area](#student_area), [student_t_inverse](#student_t_inverse), 
<br/>
----

### Driving operators
[as_driving_graph](#as_driving_graph), 
<br/>
----

### EDP-related operators
[diff](#diff), [diff2](#diff2), [internal_zero_order_equation](#internal_zero_order_equation), 
<br/>
----

### Files-related operators
[crs](#crs), [is_obj](#is_obj), [is_threeds](#is_threeds), [obj_file](#obj_file), [threeds_file](#threeds_file), 
<br/>
----

### GammaFunction
[beta](#beta), [gamma](#gamma), [incomplete_beta](#incomplete_beta), [incomplete_gamma](#incomplete_gamma), [incomplete_gamma_complement](#incomplete_gamma_complement), [log_gamma](#log_gamma), 
<br/>
----

### Graphs-related operators
[CPU_path_between](#CPU_path_between), [GPU_path_between](#GPU_path_between), 
<br/>
----

### Grid-related operators
[as_4_grid](#as_4_grid), [as_grid](#as_grid), [as_hexagonal_grid](#as_hexagonal_grid), 
<br/>
----

### Iterator operators

<br/>
----

### Map comparaison operators
[fuzzy_kappa](#fuzzy_kappa), [fuzzy_kappa_sim](#fuzzy_kappa_sim), [kappa](#kappa), [kappa_sim](#kappa_sim), [percent_absolute_deviation](#percent_absolute_deviation), 
<br/>
----

### OpenGIS
[gml_from_wfs](#gml_from_wfs), [image_from_direct_wms](#image_from_direct_wms), [image_from_wms](#image_from_wms), [read_json_rest](#read_json_rest), 
<br/>
----

### Path-related operators
[CPU_path_between](#CPU_path_between), [GPU_path_between](#GPU_path_between), [path_between](#path_between), [path_to](#path_to), 
<br/>
----

### Points-related operators
[add_point](#add_point), [angle_between](#angle_between), [any_location_in](#any_location_in), [closest_points_with](#closest_points_with), [farthest_point_to](#farthest_point_to), [points_at](#points_at), [points_on](#points_on), 
<br/>
----

### Shape
[antislice](#antislice), [arc](#arc), [box](#box), [circle](#circle), [cone](#cone), [cone3D](#cone3D), [cube](#cube), [curve](#curve), [cylinder](#cylinder), [ellipse](#ellipse), [envelope](#envelope), [geometry_collection](#geometry_collection), [hemisphere](#hemisphere), [hexagon](#hexagon), [line](#line), [link](#link), [pacman](#pacman), [plan](#plan), [polygon](#polygon), [polyhedron](#polyhedron), [pyramid](#pyramid), [rectangle](#rectangle), [rgbcube](#rgbcube), [rgbtriangle](#rgbtriangle), [slice](#slice), [sphere](#sphere), [spherical_pie](#spherical_pie), [square](#square), [squircle](#squircle), [teapot](#teapot), [triangle](#triangle), 
<br/>
----

### Spatial operators
[-](#-), [*](#*), [+](#+), [add_point](#add_point), [agent_closest_to](#agent_closest_to), [agents_at_distance](#agents_at_distance), [agents_inside](#agents_inside), [agents_overlapping](#agents_overlapping), [angle_between](#angle_between), [antislice](#antislice), [any_location_in](#any_location_in), [arc](#arc), [around](#around), [as_4_grid](#as_4_grid), [as_grid](#as_grid), [as_hexagonal_grid](#as_hexagonal_grid), [at_distance](#at_distance), [at_location](#at_location), [box](#box), [circle](#circle), [clean](#clean), [closest_points_with](#closest_points_with), [closest_to](#closest_to), [cone](#cone), [cone3D](#cone3D), [convex_hull](#convex_hull), [covers](#covers), [crosses](#crosses), [crs](#crs), [CRS_transform](#CRS_transform), [CRS_transform](#CRS_transform), [cube](#cube), [curve](#curve), [cylinder](#cylinder), [dem](#dem), [direction_between](#direction_between), [disjoint_from](#disjoint_from), [distance_between](#distance_between), [distance_to](#distance_to), [ellipse](#ellipse), [envelope](#envelope), [farthest_point_to](#farthest_point_to), [geometry_collection](#geometry_collection), [hemisphere](#hemisphere), [hexagon](#hexagon), [hierarchical_clustering](#hierarchical_clustering), [IDW](#IDW), [IDW](#IDW), [inside](#inside), [inter](#inter), [intersects](#intersects), [line](#line), [link](#link), [masked_by](#masked_by), [neighbours_at](#neighbours_at), [neighbours_of](#neighbours_of), [overlapping](#overlapping), [overlaps](#overlaps), [pacman](#pacman), [partially_overlaps](#partially_overlaps), [path_between](#path_between), [path_to](#path_to), [plan](#plan), [points_at](#points_at), [points_on](#points_on), [polygon](#polygon), [polyhedron](#polyhedron), [pyramid](#pyramid), [rectangle](#rectangle), [rgb_to_xyz](#rgb_to_xyz), [rgbcube](#rgbcube), [rgbtriangle](#rgbtriangle), [rotated_by](#rotated_by), [scaled_to](#scaled_to), [set_z](#set_z), [simple_clustering_by_distance](#simple_clustering_by_distance), [simplification](#simplification), [skeletonize](#skeletonize), [slice](#slice), [smooth](#smooth), [sphere](#sphere), [spherical_pie](#spherical_pie), [split_at](#split_at), [split_geometry](#split_geometry), [split_lines](#split_lines), [square](#square), [squircle](#squircle), [teapot](#teapot), [to_GAMA_CRS](#to_GAMA_CRS), [to_GAMA_CRS](#to_GAMA_CRS), [to_rectangles](#to_rectangles), [to_squares](#to_squares), [touches](#touches), [towards](#towards), [transformed_by](#transformed_by), [translated_by](#translated_by), [triangle](#triangle), [triangulate](#triangulate), [union](#union), [voronoi](#voronoi), [without_holes](#without_holes), 
<br/>
----

### Spatial properties operators
[covers](#covers), [crosses](#crosses), [intersects](#intersects), [partially_overlaps](#partially_overlaps), [touches](#touches), 
<br/>
----

### Spatial queries operators
[agent_closest_to](#agent_closest_to), [agents_at_distance](#agents_at_distance), [agents_inside](#agents_inside), [agents_overlapping](#agents_overlapping), [at_distance](#at_distance), [closest_to](#closest_to), [inside](#inside), [neighbours_at](#neighbours_at), [neighbours_of](#neighbours_of), [overlapping](#overlapping), 
<br/>
----

### Spatial relations operators
[direction_between](#direction_between), [distance_between](#distance_between), [distance_to](#distance_to), [path_between](#path_between), [path_to](#path_to), [towards](#towards), 
<br/>
----

### Spatial statistical operators
[hierarchical_clustering](#hierarchical_clustering), [simple_clustering_by_distance](#simple_clustering_by_distance), 
<br/>
----

### Spatial transformations operators
[-](#-), [*](#*), [+](#+), [as_4_grid](#as_4_grid), [as_grid](#as_grid), [as_hexagonal_grid](#as_hexagonal_grid), [at_location](#at_location), [clean](#clean), [convex_hull](#convex_hull), [CRS_transform](#CRS_transform), [CRS_transform](#CRS_transform), [rotated_by](#rotated_by), [scaled_to](#scaled_to), [simplification](#simplification), [skeletonize](#skeletonize), [smooth](#smooth), [split_geometry](#split_geometry), [split_lines](#split_lines), [to_GAMA_CRS](#to_GAMA_CRS), [to_GAMA_CRS](#to_GAMA_CRS), [to_rectangles](#to_rectangles), [to_squares](#to_squares), [transformed_by](#transformed_by), [translated_by](#translated_by), [triangulate](#triangulate), [voronoi](#voronoi), [without_holes](#without_holes), 
<br/>
----

### Statistical operators
[clustering_cobweb](#clustering_cobweb), [clustering_DBScan](#clustering_DBScan), [clustering_em](#clustering_em), [clustering_farthestFirst](#clustering_farthestFirst), [clustering_simple_kmeans](#clustering_simple_kmeans), [clustering_xmeans](#clustering_xmeans), [hierarchical_clustering](#hierarchical_clustering), [simple_clustering_by_distance](#simple_clustering_by_distance), 
<br/>
----

### Types-related operators

<br/>
----

### Water level operators
[water_area_for](#water_area_for), [water_level_for](#water_level_for), [water_polylines_for](#water_polylines_for), 
<br/>
----

## Operators
	
<br/>
----

### -
* **Possible use:** 
    * geometry OP `container<geometry>` --->  geometry
    * geometry OP float --->  geometry
    * geometry OP geometry --->  geometry
* **Special cases:**     
  * if the right-operand is a list of points, geometries or agents, returns the geometry resulting from the difference between the left-geometry and all of the right-geometries 
```
geometry var0 <- rectangle(10,10) - [circle(2), square(2)]; 	// var0 equals rectangle(10,10) - (circle(2) + square(2))
 ```     
  * if the left-hand operand is a geometry and the rigth-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) reduced by the right-hand operand distance 
```
geometry var1 <- shape - 5; 	// var1 equals a geometry corresponding to the geometry of the agent applying the operator reduced by a distance of 5
 ```     
  * if both operands are a point, a geometry or an agent, returns the geometry resulting from the difference between both geometries 
```
geometry var2 <- geom1 - geom2; 	// var2 equals a geometry corresponding to difference between geom1 and geom2
 ``` 

[Top of the page](#table-of-contents)
  	
<br/>
----

### `*`
* **Possible use:** 
    * geometry OP float --->  geometry
    * geometry OP point --->  geometry
* **Special cases:**     
  * if the left-hand operand is a geometry and the rigth-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) scaled by the right-hand operand coefficient 
```
geometry var0 <- circle(10) * 2; 	// var0 equals circle(20)
 ```     
  * if the left-hand operand is a geometry and the rigth-hand operand a point, returns a geometry corresponding to the left-hand operand (geometry, agent, point) scaled by the right-hand operand coefficients in the 3 dimensions 
```
geometry var1 <- shape * {0.5,0.5,2}; 	// var1 equals a geometry corresponding to the geometry of the agent applying the operator scaled by a coefficient of 0.5 in x, 0.5 in y and 2 in z
 ``` 

[Top of the page](#table-of-contents)
  	
<br/>
----

### +
* **Possible use:** 
    * geometry OP map --->  geometry
    * geometry OP float --->  geometry
    * geometry OP geometry --->  geometry
* **Special cases:**     
  * if the left-hand operand is a geometry and the rigth-hand operand a map (with [distance::float, quadrantSegments:: int (the number of line segments used to represent a quadrant of a circle), endCapStyle::int (1: (default) a semi-circle, 2: a straight line perpendicular to the end segment, 3: a half-square)]), returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged considering the right-hand operand parameters 
```
geometry var0 <- shape + ["distance"::5.0, "quadrantSegments"::4, "endCapStyle":: 2]; 	// var0 equals a geometry corresponding to the geometry of the agent applying the operator enlarged by a distance of 5, with 4 segments to represent a quadrant of a circle and a straight line perpendicular to the end segment
 ```     
  * if the left-hand operand is a geometry and the rigth-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the right-hand operand distance 
```
geometry var1 <- circle(5) + 5; 	// var1 equals circle(10)
 ```     
  * if the right-operand is a point, a geometry or an agent, returns the geometry resulting from the union between both geometries 
```
geometry var2 <- geom1 + geom2; 	// var2 equals a geometry corresponding to union between geom1 and geom2
 ``` 

[Top of the page](#table-of-contents)
  	
<br/>
----

### add_point
* **Possible use:** 
    * geometry OP point --->  geometry 
* **Result:** A geometry resulting from the addition of the right point (coordinate) to the left-hand geometry
* **Examples:** 
```
geometry var0 <- polygon([{10,10},{10,20},{20,20}]) add_point {20,10}; 	// var0 equals polygon([{10,10},{10,20},{20,20},{20,10}])
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### agent_closest_to
* **Possible use:** 
    * OP(unknown) --->  agent 
* **Result:** An agent, the closest to the operand (casted as a geometry).  
* **Comment:** the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.
* **Examples:** 
```
agent var0 <- agent_closest_to(self); 	// var0 equals the closest agent to the agent applying the operator.
```
      
* **See also:** [neighbours_at](#neighbours_at), [neighbours_of](#neighbours_of), [agents_inside](#agents_inside), [agents_overlapping](#agents_overlapping), [closest_to](#closest_to), [inside](#inside), [overlapping](#overlapping), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### agents_at_distance
* **Possible use:** 
    * OP(float) --->  list 
* **Result:** A list of agents situated at a distance lower than the right argument.
* **Examples:** 
```
list var0 <- agents_at_distance(20); 	// var0 equals all the agents (excluding the caller) which distance to the caller is lower than 20
```
      
* **See also:** [neighbours_at](#neighbours_at), [neighbours_of](#neighbours_of), [agent_closest_to](#agent_closest_to), [agents_inside](#agents_inside), [closest_to](#closest_to), [inside](#inside), [overlapping](#overlapping), [at_distance](#at_distance), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### agents_inside
* **Possible use:** 
    * OP(unknown) --->  `list<agent>` 
* **Result:** A list of agents covered by the operand (casted as a geometry).
* **Examples:** 
```
list<agent> var0 <- agents_inside(self); 	// var0 equals the agents that are covered by the shape of the agent applying the operator.
```
      
* **See also:** [agent_closest_to](#agent_closest_to), [agents_overlapping](#agents_overlapping), [closest_to](#closest_to), [inside](#inside), [overlapping](#overlapping), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### agents_overlapping
* **Possible use:** 
    * OP(unknown) --->  `list<agent>` 
* **Result:** A list of agents overlapping the operand (casted as a geometry).
* **Examples:** 
```
list<agent> var0 <- agents_overlapping(self); 	// var0 equals the agents that overlap the shape of the agent applying the operator.
```
      
* **See also:** [neighbours_at](#neighbours_at), [neighbours_of](#neighbours_of), [agent_closest_to](#agent_closest_to), [agents_inside](#agents_inside), [closest_to](#closest_to), [inside](#inside), [overlapping](#overlapping), [at_distance](#at_distance), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### angle_between
* **Possible use:** 
    * point OP point --->  int 
* **Result:** the angle between vectors P0P1 and P0P2 (P0, P1, P2 being the three point operands)
* **Examples:** 
```
int var0 <- angle_between({5,5},{10,5},{5,10}); 	// var0 equals 90
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### antislice
* **Possible use:** 
    * float OP float --->  geometry 
* **Result:** A sphere geometry which radius is equal to the operand made of 2 hemispheres.  
* **Comment:** the centre of the sphere is by default the location of the current agent that is calling this operator.
* **Special cases:**     
  * returns a point if the operand is lower or equal to 0.
* **Examples:** 
```
geometry var0 <- antislice(10,0.3); 	// var0 equals a circle geometry of radius 10, displayed as an antislice.
```
      
* **See also:** [around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), [hemisphere](#hemisphere), [pie3D](#pie3D), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### any_location_in
* **Possible use:** 
    * OP(geometry) --->  point 
* **Result:** A point inside (or touching) the operand-geometry.
* **Examples:** 
```
point var0 <- any_location_in(square(5)); 	// var0 equals a point in the square, for example : {3,4.6}.
```
      
* **See also:** [closest_points_with](#closest_points_with), [farthest_point_to](#farthest_point_to), [points_at](#points_at), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### any_point_inSame signification as [any_location_in](#any_location_in)

[Top of the page](#table-of-contents)
  	
<br/>
----

### arc
* **Possible use:** 
    * float OP float --->  geometry
    * float OP float --->  geometry 
* **Result:** An arc, which radius is equal to the first operand, heading to the second, amplitude to the third and a boolean indicating whether to return a linestring or a polygon to the fourthAn arc, which radius is equal to the first operand, heading to the second and amplitude the third  
* **Comment:** the centre of the arc is by default the location of the current agent in which has been called this operator.the centre of the arc is by default the location of the current agent in which has been called this operator. This operator returns a polygon by default.
* **Special cases:**     
  * returns a point if the radius operand is lower or equal to 0.    
  * returns a point if the radius operand is lower or equal to 0.
* **Examples:** 
```
geometry var0 <- arc(4,45,90, false); 	// var0 equals a geometry as an arc of radius 4, in a direction of 45Â° and an amplitude of 90Â°, which only contains the points on the arc
geometry var1 <- arc(4,45,90); 	// var1 equals a geometry as an arc of radius 4, in a direction of 45Â° and an amplitude of 90Â°
```
      
* **See also:** [around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [super_ellipse](#super_ellipse), [rectangle](#rectangle), [square](#square), [circle](#circle), [ellipse](#ellipse), [triangle](#triangle), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### around
* **Possible use:** 
    * float OP unknown --->  geometry 
* **Result:** A geometry resulting from the difference between a buffer around the right-operand casted in geometry at a distance left-operand (right-operand buffer left-operand) and the right-operand casted as geometry.
* **Special cases:**     
  * returns a circle geometry of radius right-operand if the left-operand is nil
* **Examples:** 
```
geometry var0 <- 10 around circle(5); 	// var0 equals the ring geometry between 5 and 10.
```
      
* **See also:** [circle](#circle), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### as_4_grid
* **Possible use:** 
    * geometry OP point --->  matrix 
* **Result:** A matrix of square geometries (grid with 4-neighbourhood) with dimension given by the rigth-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)
* **Examples:** 
```
matrix var0 <- self as_4_grid {10, 5}; 	// var0 equals the matrix of square geometries (grid with 4-neighbourhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.
```
      
* **See also:** [as_grid](#as_grid), [as_hexagonal_grid](#as_hexagonal_grid), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### as_driving_graph
* **Possible use:** 
    * container OP container --->  graph 
* **Result:** creates a graph from the list/map of edges given as operand and connect the node to the edge
* **Examples:** 
```
as_driving_graph(road,node)  --:  build a graph while using the road agents as edges and the node agents as nodes
```
      
* **See also:** [as_intersection_graph](#as_intersection_graph), [as_distance_graph](#as_distance_graph), [as_edge_graph](#as_edge_graph), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### as_grid
* **Possible use:** 
    * geometry OP point --->  matrix 
* **Result:** A matrix of square geometries (grid with 8-neighbourhood) with dimension given by the rigth-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)
* **Examples:** 
```
matrix var0 <- self as_grid {10, 5}; 	// var0 equals a matrix of square geometries (grid with 8-neighbourhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.
```
      
* **See also:** [as_4_grid](#as_4_grid), [as_hexagonal_grid](#as_hexagonal_grid), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### as_hexagonal_grid
* **Possible use:** 
    * geometry OP point --->  `list<geometry>` 
* **Result:** A list of geometries (hexagonal) corresponding to the hexagonal tesselation of the first operand geometry
* **Examples:** 
```
list<geometry> var0 <- self as_hexagonal_grid {10, 5}; 	// var0 equals list of geometries (hexagonal) corresponding to the hexagonal tesselation of the first operand geometry
```
      
* **See also:** [as_4_grid](#as_4_grid), [as_grid](#as_grid), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### at_distance
* **Possible use:** 
    * msi.gama.util.IContainer<?,? extends msi.gama.metamodel.shape.IShape> OP float --->  `list<agent>` 
* **Result:** A list of agents among the left-operand list that are located at a distance <= the right operand from the caller agent (in its topology)
* **Examples:** 
```
list<agent> var0 <- [ag1, ag2, ag3] at_distance 20; 	// var0 equals the agents of the list located at a distance <= 20 from the caller agent (in the same order).
```
      
* **See also:** [neighbours_at](#neighbours_at), [neighbours_of](#neighbours_of), [agent_closest_to](#agent_closest_to), [agents_inside](#agents_inside), [closest_to](#closest_to), [inside](#inside), [overlapping](#overlapping), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### at_location
* **Possible use:** 
    * geometry OP point --->  geometry 
* **Result:** A geometry resulting from the tran of a translation to the right-hand operand point of the left-hand operand (geometry, agent, point)
* **Examples:** 
```
geometry var0 <- self at_location {10, 20}; 	// var0 equals the geometry resulting from a translation to the location {10, 20} of the left-hand geometry (or agent).
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### auto_correlation
* **Possible use:** 
    * container OP int --->  float 
* **Result:** Returns the auto-correlation of a data sequence

[Top of the page](#table-of-contents)
  	
<br/>
----

### beta
* **Possible use:** 
    * float OP float --->  float 
* **Result:** Returns the beta function with arguments a, b.

[Top of the page](#table-of-contents)
  	
<br/>
----

### binomial_coeff
* **Possible use:** 
    * int OP int --->  float 
* **Result:** Returns n choose k as a double. Note the integerization of the double return value.

[Top of the page](#table-of-contents)
  	
<br/>
----

### binomial_complemented
* **Possible use:** 
    * int OP int --->  float 
* **Result:** Returns the sum of the terms k+1 through n of the Binomial probability density, where n is the number of trials and P is the probability of success in the range 0 to 1.

[Top of the page](#table-of-contents)
  	
<br/>
----

### binomial_sum
* **Possible use:** 
    * int OP int --->  float 
* **Result:** Returns the sum of the terms 0 through k of the Binomial probability density, where n is the number of trials and p is the probability of success in the range 0 to 1.

[Top of the page](#table-of-contents)
  	
<br/>
----

### box
* **Possible use:** 
    * OP(point) --->  geometry
    * float OP float --->  geometry 
* **Result:** A box geometry which side sizes are given by the operands.  
* **Comment:** the centre of the box is by default the location of the current agent in which has been called this operator.the centre of the box is by default the location of the current agent in which has been called this operator.
* **Special cases:**     
  * returns nil if the operand is nil.    
  * returns nil if the operand is nil.
* **Examples:** 
```
geometry var0 <- box({10, 5 , 5}); 	// var0 equals a geometry as a rectangle with width = 10, heigh = 5 depth= 5.
geometry var1 <- box(10, 5 , 5); 	// var1 equals a geometry as a rectangle with width = 10, heigh = 5 depth= 5.
```
      
* **See also:** [around](#around), [circle](#circle), [sphere](#sphere), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [square](#square), [cube](#cube), [triangle](#triangle), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### bufferSame signification as [+](#+)

[Top of the page](#table-of-contents)
  	
<br/>
----

### chi_square
* **Possible use:** 
    * float OP float --->  float 
* **Result:** Returns the area under the left hand tail (from 0 to x) of the Chi square probability density function with df degrees of freedom.

[Top of the page](#table-of-contents)
  	
<br/>
----

### chi_square_complemented
* **Possible use:** 
    * float OP float --->  float 
* **Result:** Returns the area under the right hand tail (from x to infinity) of the Chi square probability density function with df degrees of freedom.

[Top of the page](#table-of-contents)
  	
<br/>
----

### circle
* **Possible use:** 
    * OP(float) --->  geometry 
* **Result:** A circle geometry which radius is equal to the operand.  
* **Comment:** the centre of the circle is by default the location of the current agent in which has been called this operator.
* **Special cases:**     
  * returns a point if the operand is lower or equal to 0.
* **Examples:** 
```
geometry var0 <- circle(10); 	// var0 equals a geometry as a circle of radius 10.
```
      
* **See also:** [around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### clean
* **Possible use:** 
    * OP(geometry) --->  geometry 
* **Result:** A geometry corresponding to the cleaning of the operand (geometry, agent, point)  
* **Comment:** The cleaning corresponds to a buffer with a distance of 0.0
* **Examples:** 
```
geometry var0 <- clean(self); 	// var0 equals returns the geometry resulting from the cleaning of the geometry of the agent applying the operator.
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### closest_points_with
* **Possible use:** 
    * geometry OP geometry --->  `list<point>` 
* **Result:** A list of two closest points between the two geometries.
* **Examples:** 
```
list<point> var0 <- geom1 closest_points_with(geom2); 	// var0 equals [pt1, pt2] with pt1 the closest point of geom1 to geom2 and pt1 the closest point of geom2 to geom1
```
      
* **See also:** [any_location_in](#any_location_in), [any_point_in](#any_point_in), [farthest_point_to](#farthest_point_to), [points_at](#points_at), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### closest_to
* **Possible use:** 
    * msi.gama.util.IContainer<?,? extends msi.gama.metamodel.shape.IShape> OP unknown --->  agent 
* **Result:** An agent among the left-operand list of agents, species or meta-population (addition of species), the closest to the operand (casted as a geometry).  
* **Comment:** the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.
* **Examples:** 
```
agent var0 <- [ag1, ag2, ag3] closest_to(self); 	// var0 equals return the closest agent among ag1, ag2 and ag3 to the agent applying the operator.
(species1 + species2) closest_to self
```
      
* **See also:** [neighbours_at](#neighbours_at), [neighbours_of](#neighbours_of), [inside](#inside), [overlapping](#overlapping), [agents_overlapping](#agents_overlapping), [agents_inside](#agents_inside), [agent_closest_to](#agent_closest_to), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### clustering_cobweb
* **Possible use:** 
    * ??? OP msi.gama.util.IList<java.lang.String> --->  `list<list<agent>>` 
* **Result:** A list of agent groups clusteredby CobWeb Algorithm based on the given attributes. Some paremeters can be defined: acuity: minimum standard deviation for numeric attributes; cutoff: category utility threshold by which to prune nodes seed
* **Examples:** 
```
list<list<agent>> var0 <- clustering_cobweb([ag1, ag2, ag3, ag4, ag5],["size","age", "weight"],["acuity"::3.0, "cutoff"::0.5); 	// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]
```
      
* **See also:** [clustering_xmeans](#clustering_xmeans), [clustering_em](#clustering_em), [clustering_farthestFirst](#clustering_farthestFirst), [clustering_simple_kmeans](#clustering_simple_kmeans), [clustering_cobweb](#clustering_cobweb), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### clustering_DBScan
* **Possible use:** 
    * ??? OP msi.gama.util.IList<java.lang.String> --->  `list<list<agent>>` 
* **Result:** A list of agent groups clustered by DBScan Algorithm based on the given attributes. Some paremeters can be defined: distance_f: The distance function to use for instances comparison (euclidean or manhattan); min_points: minimun number of DataObjects required in an epsilon-range-queryepsilon: epsilon -- radius of the epsilon-range-queries
* **Examples:** 
```
list<list<agent>> var0 <- clustering_DBScan([ag1, ag2, ag3, ag4, ag5],["size","age", "weight"],["distance_f"::"manhattan"]); 	// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]
```
      
* **See also:** [clustering_xmeans](#clustering_xmeans), [clustering_em](#clustering_em), [clustering_farthestFirst](#clustering_farthestFirst), [clustering_simple_kmeans](#clustering_simple_kmeans), [clustering_cobweb](#clustering_cobweb), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### clustering_em
* **Possible use:** 
    * ??? OP msi.gama.util.IList<java.lang.String> --->  `list<list<agent>>` 
* **Result:** A list of agent groups clustered by EM Algorithm based on the given attributes. Some paremeters can be defined: max_iterations: the maximum number of iterations to perform;num_clusters: the number of clusters; minStdDev: minimum allowable standard deviation
* **Examples:** 
```
list<list<agent>> var0 <- clustering_em([ag1, ag2, ag3, ag4, ag5],["size","age", "weight"],["max_iterations"::10, "num_clusters"::3]); 	// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]
```
      
* **See also:** [clustering_xmeans](#clustering_xmeans), [clustering_simple_kmeans](#clustering_simple_kmeans), [clustering_farthestFirst](#clustering_farthestFirst), [clustering_DBScan](#clustering_DBScan), [clustering_cobweb](#clustering_cobweb), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### clustering_farthestFirst
* **Possible use:** 
    * ??? OP msi.gama.util.IList<java.lang.String> --->  `list<list<agent>>` 
* **Result:** A list of agent groups clustered by Farthest First Algorithm based on the given attributes. Some paremeters can be defined: num_clusters: the number of clusters
* **Examples:** 
```
list<list<agent>> var0 <- clustering_farthestFirst([ag1, ag2, ag3, ag4, ag5],["size","age", "weight"],["num_clusters"::3]); 	// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]
```
      
* **See also:** [clustering_xmeans](#clustering_xmeans), [clustering_simple_kmeans](#clustering_simple_kmeans), [clustering_em](#clustering_em), [clustering_DBScan](#clustering_DBScan), [clustering_cobweb](#clustering_cobweb), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### clustering_simple_kmeans
* **Possible use:** 
    * ??? OP msi.gama.util.IList<java.lang.String> --->  `list<list<agent>>` 
* **Result:** A list of agent groups clustered by K-Means Algorithm based on the given attributes. Some paremeters can be defined: distance_f: The distance function to use. 4 possible distance functions: euclidean (by default) ; 'chebyshev', 'manhattan' or 'levenshtein'; dont_replace_missing_values: if false, replace missing values globally with mean/mode; max_iterations: the maximum number of iterations to perform;num_clusters: the number of clusters
* **Examples:** 
```
list<list<agent>> var0 <- clustering_simple_kmeans([ag1, ag2, ag3, ag4, ag5],["size","age", "weight"],["distance_f"::"manhattan", "num_clusters"::3]); 	// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]
```
      
* **See also:** [clustering_xmeans](#clustering_xmeans), [clustering_em](#clustering_em), [clustering_farthestFirst](#clustering_farthestFirst), [clustering_DBScan](#clustering_DBScan), [clustering_cobweb](#clustering_cobweb), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### clustering_xmeans
* **Possible use:** 
    * ??? OP msi.gama.util.IList<java.lang.String> --->  `list<list<agent>>` 
* **Result:** A list of agent groups clustered by X-Means Algorithm based on the given attributes. Some paremeters can be defined: bin_value: value given for true value of boolean attributes; cut_off_factor: the cut-off factor to use;distance_f: The distance function to use. 4 possible distance functions: euclidean (by default) ; 'chebyshev', 'manhattan' or 'levenshtein'; max_iterations: the maximum number of iterations to perform; max_kmeans: the maximum number of iterations to perform in KMeans; max_kmeans_for_children: the maximum number of iterations KMeans that is performed on the child centers;max_num_clusters: the maximum number of clusters; min_num_clusters: the minimal number of clusters
* **Examples:** 
```
list<list<agent>> var0 <- clustering_xmeans([ag1, ag2, ag3, ag4, ag5],["size","age", "weight", "is_male"],["bin_value"::1.0, "distance_f"::"manhattan", "max_num_clusters"::10, "min_num_clusters"::2]); 	// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]
```
      
* **See also:** [clustering_simple_kmeans](#clustering_simple_kmeans), [clustering_em](#clustering_em), [clustering_farthestFirst](#clustering_farthestFirst), [clustering_DBScan](#clustering_DBScan), [clustering_cobweb](#clustering_cobweb), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### cone
* **Possible use:** 
    * OP(point) --->  geometry
    * int OP int --->  geometry 
* **Result:** A cone geometry which min and max angles are given by the operands.A cone geometry which min and max angles are given by the operands.  
* **Comment:** the centre of the cone is by default the location of the current agent in which has been called this operator.the centre of the cone is by default the location of the current agent in which has been called this operator.
* **Special cases:**     
  * returns nil if the operand is nil.    
  * returns nil if the operand is nil.
* **Examples:** 
```
geometry var0 <- cone({0, 45}); 	// var0 equals a geometry as a cone with min angle is 0 and max angle is 45.
geometry var1 <- cone(0, 45); 	// var1 equals a geometry as a cone with min angle is 0 and max angle is 45.
```
      
* **See also:** [around](#around), [circle](#circle), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### cone3D
* **Possible use:** 
    * float OP float --->  geometry 
* **Result:** A cone geometry which radius is equal to the operand.  
* **Comment:** the centre of the cone is by default the location of the current agent in which has been called this operator.
* **Special cases:**     
  * returns a point if the operand is lower or equal to 0.
* **Examples:** 
```
geometry var0 <- cone3D(10.0,10.0); 	// var0 equals a geometry as a circle of radius 10 but displays a cone.
```
      
* **See also:** [around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### convex_hull
* **Possible use:** 
    * OP(geometry) --->  geometry 
* **Result:** A geometry corresponding to the convex hull of the operand.
* **Examples:** 
```
geometry var0 <- convex_hull(self); 	// var0 equals the convex hull of the geometry of the agent applying the operator
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### correlation
* **Possible use:** 
    * container OP container --->  float 
* **Result:** Returns the correlation of two data sequences

[Top of the page](#table-of-contents)
  	
<br/>
----

### covariance
* **Possible use:** 
    * container OP container --->  float 
* **Result:** Returns the covariance of two data sequences

[Top of the page](#table-of-contents)
  	
<br/>
----

### covers
* **Possible use:** 
    * geometry OP geometry --->  bool 
* **Result:** A boolean, equal to true if the left-geometry (or agent/point) covers the right-geometry (or agent/point).
* **Special cases:**     
  * if one of the operand is null, returns false.
* **Examples:** 
```
bool var0 <- square(5) covers square(2); 	// var0 equals true
```
      
* **See also:** [disjoint_from](#disjoint_from), [crosses](#crosses), [overlaps](#overlaps), [partially_overlaps](#partially_overlaps), [touches](#touches), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### CPU_path_between
* **Possible use:** 
    * graph OP geometry --->  path 
* **Result:** The shortest path between a list of two objects in a graph computed with CPU
* **Examples:** 
```
path var0 <- my_graph CPU_path_between (ag1:: ag2); 	// var0 equals A path between ag1 and ag2
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### crosses
* **Possible use:** 
    * geometry OP geometry --->  bool 
* **Result:** A boolean, equal to true if the left-geometry (or agent/point) crosses the right-geometry (or agent/point).
* **Special cases:**     
  * if one of the operand is null, returns false.    
  * if one operand is a point, returns false.
* **Examples:** 
```
bool var0 <- polyline([{10,10},{20,20}]) crosses polyline([{10,20},{20,10}]); 	// var0 equals true
bool var1 <- polyline([{10,10},{20,20}]) crosses {15,15}; 	// var1 equals true
bool var2 <- polyline([{0,0},{25,25}]) crosses polygon([{10,10},{10,20},{20,20},{20,10}]); 	// var2 equals true
```
      
* **See also:** [disjoint_from](#disjoint_from), [intersects](#intersects), [overlaps](#overlaps), [partially_overlaps](#partially_overlaps), [touches](#touches), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### crs
* **Possible use:** 
    * OP(file) --->  string 
* **Result:** the Coordinate Reference System (CRS) of the GIS file
* **Examples:** 
```
string var0 <- crs(my_shapefile); 	// var0 equals the crs of the shapefile
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### CRS_transform
* **Possible use:** 
    * OP(geometry) --->  geometry
    * geometry OP string --->  geometry
* **Special cases:**     
  * returns the geometry corresponding to the transfomartion of the given geometry by the current CRS (Coordinate Reference System), the one corresponding to the world's agent one 
```
geometry var0 <- CRS_transform(shape); 	// var0 equals a geometry corresponding to the agent geometry transformed into the current CRS
 ```     
  * returns the geometry corresponding to the transfomartion of the given geometry by the left operand CRS (Coordinate Reference System) 
```
geometry var1 <- shape CRS_transform("EPSG:4326"); 	// var1 equals a geometry corresponding to the agent geometry transformed into the EPSG:4326 CRS
 ``` 

[Top of the page](#table-of-contents)
  	
<br/>
----

### CRS_transform
* **Possible use:** 
    * OP(geometry) --->  geometry
    * geometry OP string --->  geometry
* **Special cases:**     
  * returns the geometry corresponding to the transfomartion of the given geometry by the left operand CRS (Coordinate Reference System) 
```
geometry var0 <- shape CRS_transform("EPSG:4326"); 	// var0 equals a geometry corresponding to the agent geometry transformed into the EPSG:4326 CRS
 ```     
  * returns the geometry corresponding to the transfomartion of the given geometry by the current CRS (Coordinate Reference System), the one corresponding to the world's agent one 
```
geometry var1 <- CRS_transform(shape); 	// var1 equals a geometry corresponding to the agent geometry transformed into the current CRS
 ``` 

[Top of the page](#table-of-contents)
  	
<br/>
----

### cube
* **Possible use:** 
    * OP(float) --->  geometry 
* **Result:** A cube geometry which side size is equal to the operand.  
* **Comment:** the centre of the cube is by default the location of the current agent in which has been called this operator.
* **Special cases:**     
  * returns nil if the operand is nil.
* **Examples:** 
```
geometry var0 <- cube(10); 	// var0 equals a geometry as a square of side size 10.
```
      
* **See also:** [around](#around), [circle](#circle), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [triangle](#triangle), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### curve
* **Possible use:** 
    * point OP point --->  geometry
    * point OP point --->  geometry
    * point OP point --->  geometry
    * point OP point --->  geometry 
* **Result:** A cubic Bezier curve geometry built from the four given points composed of a given number of points.A quadratic Bezier curve geometry built from the three given points composed of 10 points.A cubic Bezier curve geometry built from the four given points composed of 10 points.A quadratic Bezier curve geometry built from the three given points composed of a given numnber of points.
* **Special cases:**     
  * if the operand is nil, returns nil    
  * if the last operand (number of points) is inferior to 2, returns nil    
  * if the operand is nil, returns nil    
  * if the operand is nil, returns nil    
  * if the operand is nil, returns nil    
  * if the last operand (number of points) is inferior to 2, returns nil
* **Examples:** 
```
geometry var0 <- curve({0,0}, {0,10}, {10,10}); 	// var0 equals a cubic Bezier curve geometry composed of 10 points from p0 to p3.
geometry var1 <- curve({0,0}, {0,10}, {10,10}); 	// var1 equals a quadratic Bezier curve geometry composed of 10 points from p0 to p2.
geometry var2 <- curve({0,0}, {0,10}, {10,10}); 	// var2 equals a cubic Bezier curve geometry composed of 10 points from p0 to p3.
geometry var3 <- curve({0,0}, {0,10}, {10,10}, 20); 	// var3 equals a quadratic Bezier curve geometry composed of 20 points from p0 to p2.
```
      
* **See also:** [around](#around), [circle](#circle), [cone](#cone), [link](#link), [norm](#norm), [point](#point), [polygone](#polygone), [rectangle](#rectangle), [square](#square), [triangle](#triangle), [line](#line), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### cylinder
* **Possible use:** 
    * float OP float --->  geometry 
* **Result:** A cylinder geometry which radius is equal to the operand.  
* **Comment:** the centre of the cylinder is by default the location of the current agent in which has been called this operator.
* **Special cases:**     
  * returns a point if the operand is lower or equal to 0.
* **Examples:** 
```
geometry var0 <- cylinder(10,10); 	// var0 equals a geometry as a circle of radius 10.
```
      
* **See also:** [around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### dem
* **Possible use:** 
    * OP(file) --->  geometry
    * file OP float --->  geometry
    * file OP file --->  geometry
    * file OP file --->  geometry 
* **Result:** A polygon that is equivalent to the surface of the texture
* **Special cases:**     
  * a point if the operand is lower or equal to 0.
* **Examples:** 
```
geometry var0 <- dem(dem,z_factor); 	// var0 equals a geometry as a rectangle of weight and height equal to the texture.
geometry var1 <- dem(dem); 	// var1 equals returns a geometry as a rectangle of weight and height equal to the texture.
geometry var2 <- dem(dem,texture,z_factor); 	// var2 equals a geometry as a rectangle of weight and height equal to the texture.
geometry var3 <- dem(dem,texture); 	// var3 equals a geometry as a rectangle of weight and height equal to the texture.
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### diff
* **Possible use:** 
    * float OP float --->  float

[Top of the page](#table-of-contents)
  	
<br/>
----

### diff2
* **Possible use:** 
    * float OP float --->  float

[Top of the page](#table-of-contents)
  	
<br/>
----

### direction_between
* **Possible use:** 
    * topology OP `container<geometry>` --->  int 
* **Result:** A direction (in degree) between a list of two geometries (geometries, agents, points) considering a topology.
* **Examples:** 
```
int var0 <- my_topology direction_between [ag1, ag2]; 	// var0 equals the direction between ag1 and ag2 considering the topology my_topology
```
      
* **See also:** [towards](#towards), [direction_to](#direction_to), [distance_to](#distance_to), [distance_between](#distance_between), [path_between](#path_between), [path_to](#path_to), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### direction_toSame signification as [towards](#towards)

[Top of the page](#table-of-contents)
  	
<br/>
----

### disjoint_from
* **Possible use:** 
    * geometry OP geometry --->  bool 
* **Result:** A boolean, equal to true if the left-geometry (or agent/point) is disjoints from the right-geometry (or agent/point).
* **Special cases:**     
  * if one of the operand is null, returns true.    
  * if one operand is a point, returns false if the point is included in the geometry.
* **Examples:** 
```
bool var0 <- polyline([{10,10},{20,20}]) disjoint_from polyline([{15,15},{25,25}]); 	// var0 equals false
bool var1 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{15,15},{15,25},{25,25},{25,15}]); 	// var1 equals false
bool var2 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from {15,15}; 	// var2 equals false
bool var3 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from {25,25}; 	// var3 equals true
bool var4 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{35,35},{35,45},{45,45},{45,35}]); 	// var4 equals true
```
      
* **See also:** [intersects](#intersects), [crosses](#crosses), [overlaps](#overlaps), [partially_overlaps](#partially_overlaps), [touches](#touches), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### distance_between
* **Possible use:** 
    * topology OP `container<geometry>` --->  float 
* **Result:** A distance between a list of geometries (geometries, agents, points) considering a topology.
* **Examples:** 
```
float var0 <- my_topology distance_between [ag1, ag2, ag3]; 	// var0 equals the distance between ag1, ag2 and ag3 considering the topology my_topology
```
      
* **See also:** [towards](#towards), [direction_to](#direction_to), [distance_to](#distance_to), [direction_between](#direction_between), [path_between](#path_between), [path_to](#path_to), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### distance_to
* **Possible use:** 
    * point OP point --->  float
    * geometry OP geometry --->  float 
* **Result:** A distance between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.
* **Examples:** 
```
float var0 <- ag1 distance_to ag2; 	// var0 equals the distance between ag1 and ag2 considering the topology of the agent applying the operator
```
      
* **See also:** [towards](#towards), [direction_to](#direction_to), [distance_between](#distance_between), [direction_between](#direction_between), [path_between](#path_between), [path_to](#path_to), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### dnormSame signification as [normal_density](#normal_density)

[Top of the page](#table-of-contents)
  	
<br/>
----

### durbin_watson
* **Possible use:** 
    * OP(container) --->  float 
* **Result:** Durbin-Watson computation

[Top of the page](#table-of-contents)
  	
<br/>
----

### ellipse
* **Possible use:** 
    * float OP float --->  geometry 
* **Result:** An ellipse geometry which x-radius is equal to the first operand and y-radius is equal to the second operand  
* **Comment:** the centre of the ellipse is by default the location of the current agent in which has been called this operator.
* **Special cases:**     
  * returns a point if both operands are lower or equal to 0, a line if only one is.
* **Examples:** 
```
geometry var0 <- ellipse(10, 10); 	// var0 equals a geometry as an ellipse of width 10 and height 10.
```
      
* **See also:** [around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [circle](#circle), [squircle](#squircle), [triangle](#triangle), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### enlarged_bySame signification as [+](#+)

[Top of the page](#table-of-contents)
  	
<br/>
----

### envelope
* **Possible use:** 
    * OP(unknown) --->  geometry 
* **Result:** A 3D geometry that represents the box that surrounds the geometries or the surface described by the arguments. More general than geometry(arguments).envelope, as it allows to pass int, double, point, image files, shape files, asc files, or any list combining these arguments, in which case the envelope will be correctly expanded. If an envelope cannot be determined from the arguments, a default one of dimensions (0,100, 0, 100, 0, 100) is returned

[Top of the page](#table-of-contents)
  	
<br/>
----

### farthest_point_to
* **Possible use:** 
    * geometry OP point --->  point 
* **Result:** the farthest point of the left-operand to the left-point.
* **Examples:** 
```
point var0 <- geom farthest_point_to(pt); 	// var0 equals the closest point of geom to pt
```
      
* **See also:** [any_location_in](#any_location_in), [any_point_in](#any_point_in), [closest_points_with](#closest_points_with), [points_at](#points_at), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### fuzzy_kappa
* **Possible use:** 
    * ??? OP list --->  float
    * ??? OP list --->  float 
* **Result:** fuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance, weights). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling & Software, 21fuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling & Software, 21
* **Examples:** 
```
fuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2, [1.0,3.0,2.0,2.0,4.0])
fuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2)
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### fuzzy_kappa_sim
* **Possible use:** 
    * ??? OP list --->  float
    * ??? OP list --->  float 
* **Result:** fuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800, fuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance, weights). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800,
* **Examples:** 
```
fuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2)
fuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2,[1.0,3.0,2.0,2.0,4.0])
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### gamma
* **Possible use:** 
    * OP(float) --->  float 
* **Result:** Returns the value of the Gamma function at x.

[Top of the page](#table-of-contents)
  	
<br/>
----

### gamma_distribution
* **Possible use:** 
    * float OP float --->  float 
* **Result:** Returns the integral from zero to x of the gamma probability density function.  
* **Comment:** incomplete_gamma(a,x) is equal to pgamma(a,1,x).

[Top of the page](#table-of-contents)
  	
<br/>
----

### gamma_distribution_complemented
* **Possible use:** 
    * float OP float --->  float 
* **Result:** Returns the integral from x to infinity of the gamma probability density function.

[Top of the page](#table-of-contents)
  	
<br/>
----

### geometry_collection
* **Possible use:** 
    * OP(`container<geometry>`) --->  geometry 
* **Result:** A geometry collection (multi-geometry) composed of the given list of geometries.
* **Special cases:**     
  * if the operand is nil, returns the point geometry {0,0}    
  * if the operand is composed of a single geometry, returns a copy of the geometry.
* **Examples:** 
```
geometry var0 <- geometry_collection([{0,0}, {0,10}, {10,10}, {10,0}]); 	// var0 equals a geometry composed of the 4 points (multi-point).
```
      
* **See also:** [around](#around), [circle](#circle), [cone](#cone), [link](#link), [norm](#norm), [point](#point), [polygone](#polygone), [rectangle](#rectangle), [square](#square), [triangle](#triangle), [line](#line), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### gml_from_wfs
* **Possible use:** 
    * string OP string --->  msi.gama.util.IList<msi.gama.util.IList<java.lang.Object>> 
* **Result:** WMS: A simple call to WFS/GML2

[Top of the page](#table-of-contents)
  	
<br/>
----

### GPU_path_between
* **Possible use:** 
    * graph OP geometry --->  path 
* **Result:** The shortest path between a list of two objects in a graph computed with GPU
* **Examples:** 
```
path var0 <- my_graph GPU_path_between (ag1:: ag2); 	// var0 equals A path between ag1 and ag2
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### hemisphere
* **Possible use:** 
    * float OP float --->  geometry 
* **Result:** An hemisphere geometry which radius is equal to the operand.  
* **Comment:** the centre of the hemisphere is by default the location of the current agent in which has been called this operator.
* **Special cases:**     
  * returns a point if the operand is lower or equal to 0.
* **Examples:** 
```
geometry var0 <- hemisphere(10,0.5); 	// var0 equals a geometry as a circle of radius 10 but displays an hemisphere.
```
      
* **See also:** [around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), [hemisphere](#hemisphere), [pie3D](#pie3D), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### hexagon
* **Possible use:** 
    * OP(point) --->  geometry
    * OP(float) --->  geometry 
* **Result:** A hexagon geometry which the given with and height  
* **Comment:** the centre of the hexagon is by default the location of the current agent in which has been called this operator.the centre of the hexagon is by default the location of the current agent in which has been called this operator.
* **Special cases:**     
  * returns nil if the operand is nil.    
  * returns nil if the operand is nil.
* **Examples:** 
```
geometry var0 <- hexagon({10,5}); 	// var0 equals a geometry as a hexagon of width of 10 and height of 5.
geometry var1 <- hexagon(10); 	// var1 equals a geometry as a hexagon of width of 10 and height of 10.
```
      
* **See also:** [around](#around), [circle](#circle), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [triangle](#triangle), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### hierarchical_clustering
* **Possible use:** 
    * `container<agent>` OP float --->  list 
* **Result:** A tree (list of list) contained groups of agents clustered by distance considering a distance min between two groups.  
* **Comment:** use of hierarchical clustering with Minimum for linkage criterion between two groups of agents.
* **Examples:** 
```
list var0 <- [ag1, ag2, ag3, ag4, ag5] hierarchical_clustering 20.0; 	// var0 equals for example, can return [[[ag1],[ag3]], [ag2], [[[ag4],[ag5]],[ag6]]
```
      
* **See also:** [simple_clustering_by_distance](#simple_clustering_by_distance), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### IDW
* **Possible use:** 
    * msi.gama.util.IContainer<?,? extends msi.gama.metamodel.shape.IShape> OP msi.gama.util.GamaMap<msi.gama.metamodel.shape.GamaPoint,java.lang.Double> --->  msi.gama.util.GamaMap<msi.gama.metamodel.shape.IShape,java.lang.Double> 
* **Result:** Inverse Distance Weighting (IDW) is a type of deterministic method for multivariate interpolation with a known scattered set of points. The assigned values to each geometry are calculated with a weighted average of the values available at the known points. See: http://en.wikipedia.org/wiki/Inverse_distance_weighting Usage: IDW (list of geometries, map of points (key: point, value: value), power parameter)
* **Examples:** 
```
msi.gama.util.GamaMap<msi.gama.metamodel.shape.IShape,java.lang.Double> var0 <- IDW([ag1, ag2, ag3, ag4, ag5],[{10,10}::25.0, {10,80}::10.0, {100,10}::15.0], 2); 	// var0 equals for example, can return [ag1::12.0, ag2::23.0,ag3::12.0,ag4::14.0,ag5::17.0]
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### IDW
* **Possible use:** 
    * msi.gama.util.IContainer<?,? extends msi.gama.metamodel.shape.IShape> OP msi.gama.util.GamaMap<msi.gama.metamodel.shape.GamaPoint,java.lang.Double> --->  msi.gama.util.GamaMap<msi.gama.metamodel.shape.IShape,java.lang.Double> 
* **Result:** Inverse Distance Weighting (IDW) is a type of deterministic method for multivariate interpolation with a known scattered set of points. The assigned values to each geometry are calculated with a weighted average of the values available at the known points. See: http://en.wikipedia.org/wiki/Inverse_distance_weighting Usage: IDW (list of geometries, map of points (key: point, value: value), power parameter)
* **Examples:** 
```
msi.gama.util.GamaMap<msi.gama.metamodel.shape.IShape,java.lang.Double> var0 <- IDW([ag1, ag2, ag3, ag4, ag5],[{10,10}::25.0, {10,80}::10.0, {100,10}::15.0], 2); 	// var0 equals for example, can return [ag1::12.0, ag2::23.0,ag3::12.0,ag4::14.0,ag5::17.0]
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### image_from_direct_wms
* **Possible use:** 
    * string OP string --->  file 
* **Result:** WMS: A simple call to WMS

[Top of the page](#table-of-contents)
  	
<br/>
----

### image_from_wms
* **Possible use:** 
    * string OP string --->  file 
* **Result:** WMS: A simple call to WMS

[Top of the page](#table-of-contents)
  	
<br/>
----

### incomplete_beta
* **Possible use:** 
    * float OP float --->  float 
* **Result:** Returns the regularized integral of the beta function with arguments a and b, from zero to x.

[Top of the page](#table-of-contents)
  	
<br/>
----

### incomplete_gamma
* **Possible use:** 
    * float OP float --->  float 
* **Result:** Returns the regularized integral of the Gamma function with argument a to the integration end point x.

[Top of the page](#table-of-contents)
  	
<br/>
----

### incomplete_gamma_complement
* **Possible use:** 
    * float OP float --->  float 
* **Result:** Returns the complemented regularized incomplete Gamma function of the argument a and integration start point x.

[Top of the page](#table-of-contents)
  	
<br/>
----

### inside
* **Possible use:** 
    * msi.gama.util.IContainer<?,? extends msi.gama.metamodel.shape.IShape> OP unknown --->  `list<agent>` 
* **Result:** A list of agents among the left-operand list, species or meta-population (addition of species), covered by the operand (casted as a geometry).
* **Examples:** 
```
list<agent> var0 <- [ag1, ag2, ag3] inside(self); 	// var0 equals the agents among ag1, ag2 and ag3 that are covered by the shape of the right-hand argument.
list<agent> var1 <- (species1 + species2) inside (self); 	// var1 equals the agents among species species1 and species2 that are covered by the shape of the right-hand argument.
```
      
* **See also:** [neighbours_at](#neighbours_at), [neighbours_of](#neighbours_of), [closest_to](#closest_to), [overlapping](#overlapping), [agents_overlapping](#agents_overlapping), [agents_inside](#agents_inside), [agent_closest_to](#agent_closest_to), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### inter
* **Possible use:** 
    * geometry OP geometry --->  geometry 
* **Result:** A geometry resulting from the intersection between the two geometries
* **Special cases:**     
  * returns nil if one of the operands is nil
* **Examples:** 
```
geometry var0 <- square(10) inter circle(5); 	// var0 equals circle(5)
```
      
* **See also:** [union](#union), [+](#+), [-](#-), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### internal_zero_order_equation
* **Possible use:** 
    * OP(any expression) --->  float

[Top of the page](#table-of-contents)
  	
<br/>
----

### intersectionSame signification as [inter](#inter)

[Top of the page](#table-of-contents)
  	
<br/>
----

### intersects
* **Possible use:** 
    * geometry OP geometry --->  bool 
* **Result:** A boolean, equal to true if the left-geometry (or agent/point) intersects the right-geometry (or agent/point).
* **Special cases:**     
  * if one of the operand is null, returns false.
* **Examples:** 
```
bool var0 <- square(5) intersects {10,10}; 	// var0 equals false
```
      
* **See also:** [disjoint_from](#disjoint_from), [crosses](#crosses), [overlaps](#overlaps), [partially_overlaps](#partially_overlaps), [touches](#touches), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### is_obj
* **Possible use:** 
    * OP(any) --->  bool 
* **Result:** Tests whether the operand is a obj file.

[Top of the page](#table-of-contents)
  	
<br/>
----

### is_threeds
* **Possible use:** 
    * OP(any) --->  bool 
* **Result:** Tests whether the operand is a threeds file.

[Top of the page](#table-of-contents)
  	
<br/>
----

### kappa
* **Possible use:** 
    * list OP list --->  float
    * list OP list --->  float 
* **Result:** kappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20.kappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories, weights). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20.
* **Examples:** 
```
kappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3])
float var1 <- kappa([1,3,5,1,5],[1,1,1,1,5],[1,3,5]); 	// var1 equals the similarity between 0 and 1
float var2 <- kappa([1,1,1,1,5],[1,1,1,1,5],[1,3,5]); 	// var2 equals 1.0
kappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3], [1.0, 2.0, 3.0, 1.0, 5.0])
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### kappa_sim
* **Possible use:** 
    * list OP list --->  float
    * list OP list --->  float 
* **Result:** kappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories). Reference: van Vliet, J., Bregt, A.K. & Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8).kappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories, weights). Reference: van Vliet, J., Bregt, A.K. & Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8)
* **Examples:** 
```
kappa([cat1,cat1,cat2,cat2,cat2],[cat2,cat1,cat2,cat1,cat3],[cat2,cat1,cat2,cat3,cat3], [cat1,cat2,cat3])
kappa([cat1,cat1,cat2,cat2,cat2],[cat2,cat1,cat2,cat1,cat3],[cat2,cat1,cat2,cat3,cat3], [cat1,cat2,cat3],[1.0, 2.0, 3.0, 1.0, 5.0])
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### kurtosis
* **Possible use:** 
    * OP(container) --->  float
    * float OP float --->  float 
* **Result:** Returns the kurtosis (aka excess) of a data sequenceReturns the kurtosis (aka excess) of a data sequence

[Top of the page](#table-of-contents)
  	
<br/>
----

### lgammaSame signification as [log_gamma](#log_gamma)

[Top of the page](#table-of-contents)
  	
<br/>
----

### line
* **Possible use:** 
    * OP(`container<geometry>`) --->  geometry
    * `container<geometry>` OP float --->  geometry 
* **Result:** A polyline geometry from the given list of points.A polyline geometry from the given list of points represented as a cylinder of radius r.
* **Special cases:**     
  * if the operand is nil, returns the point geometry {0,0}    
  * if the operand is composed of a single point, returns a point geometry.    
  * if the operand is nil, returns the point geometry {0,0}    
  * if the operand is composed of a single point, returns a point geometry.    
  * if a radius is added, the given list of points represented as a cylinder of radius r 
```
geometry var1 <- polyline([{0,0}, {0,10}, {10,10}, {10,0}],0.2); 	// var1 equals a polyline geometry composed of the 4 points.
 ``` 
* **Examples:** 
```
geometry var0 <- polyline([{0,0}, {0,10}, {10,10}, {10,0}]); 	// var0 equals a polyline geometry composed of the 4 points.
```
      
* **See also:** [around](#around), [circle](#circle), [cone](#cone), [link](#link), [norm](#norm), [point](#point), [polygone](#polygone), [rectangle](#rectangle), [square](#square), [triangle](#triangle), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### link
* **Possible use:** 
    * OP(pair) --->  geometry 
* **Result:** A link between the 2 elements of the pair.  
* **Comment:** The geometry of the link is the intersection of the two geometries when they intersect, and a line between their centroids when they do not.
* **Special cases:**     
  * if the operand is nil, link returns a point {0,0}    
  * if one of the elements of the pair is a list of geometries or a species, link will consider the union of the geometries or of the geometry of each agent of the species
* **Examples:** 
```
geometry var0 <- link (geom1::geom2); 	// var0 equals a link geometry between geom1 and geom2.
```
      
* **See also:** [around](#around), [circle](#circle), [cone](#cone), [line](#line), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### log_gamma
* **Possible use:** 
    * OP(float) --->  float 
* **Result:** Returns the log of the value of the Gamma function at x.

[Top of the page](#table-of-contents)
  	
<br/>
----

### masked_by
* **Possible use:** 
    * geometry OP `container<geometry>` --->  geometry
    * geometry OP `container<geometry>` --->  geometry
* **Examples:** 
```
geometry var0 <- perception_geom masked_by obstacle_list; 	// var0 equals the geometry representing the part of perception_geom visible from the agent position considering the list of obstacles obstacle_list.
geometry var1 <- perception_geom masked_by obstacle_list; 	// var1 equals the geometry representing the part of perception_geom visible from the agent position considering the list of obstacles obstacle_list.
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### moment
* **Possible use:** 
    * container OP int --->  float 
* **Result:** Returns the moment of k-th order with constant c of a data sequence

[Top of the page](#table-of-contents)
  	
<br/>
----

### neighbours_at
* **Possible use:** 
    * geometry OP float --->  list 
* **Result:** a list, containing all the agents of the same species than the left argument (if it is an agent) located at a distance inferior or equal to the right-hand operand to the left-hand operand (geometry, agent, point).  
* **Comment:** The topology used to compute the neighbourhood  is the one of the left-operand if this one is an agent; otherwise the one of the agent applying the operator.
* **Examples:** 
```
list var0 <- (self neighbours_at (10)); 	// var0 equals all the agents located at a distance lower or equal to 10 to the agent applying the operator.
```
      
* **See also:** [neighbours_of](#neighbours_of), [closest_to](#closest_to), [overlapping](#overlapping), [agents_overlapping](#agents_overlapping), [agents_inside](#agents_inside), [agent_closest_to](#agent_closest_to), [at_distance](#at_distance), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### neighbours_of
* **Possible use:** 
    * topology OP agent --->  list
    * topology OP geometry --->  list 
* **Result:** a list, containing all the agents of the same species than the argument (if it is an agent) located at a distance inferior or equal to 1 to the right-hand operand agent considering the left-hand operand topology.
* **Special cases:**     
  * a list, containing all the agents of the same species than the left argument (if it is an agent) located at a distance inferior or equal to the third argument to the second argument (agent, geometry or point) considering the first operand topology. 
```
list var1 <- neighbours_of (topology(self), self,10); 	// var1 equals all the agents located at a distance lower or equal to 10 to the agent applying the operator considering its topology.
 ``` 
* **Examples:** 
```
list var0 <- topology(self) neighbours_of self; 	// var0 equals returns all the agents located at a distance lower or equal to 1 to the agent applying the operator considering its topology.
```
      
* **See also:** [neighbours_at](#neighbours_at), [closest_to](#closest_to), [overlapping](#overlapping), [agents_overlapping](#agents_overlapping), [agents_inside](#agents_inside), [agent_closest_to](#agent_closest_to), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### normal_area
* **Possible use:** 
    * float OP float --->  float 
* **Result:** Returns the area to the left of x in the normal distribution with the given mean and standard deviation.

[Top of the page](#table-of-contents)
  	
<br/>
----

### normal_density
* **Possible use:** 
    * float OP float --->  float 
* **Result:** Returns the probability of x in the normal distribution with the given mean and standard deviation.

[Top of the page](#table-of-contents)
  	
<br/>
----

### normal_inverse
* **Possible use:** 
    * float OP float --->  float 
* **Result:** Returns the x in the normal distribution with the given mean and standard deviation, to the left of which lies the given area. normal.Inverse returns the value in terms of standard deviations from the mean, so we need to adjust it for the given mean and standard deviation.

[Top of the page](#table-of-contents)
  	
<br/>
----

### obj_file
* **Possible use:** 
    * OP(string) --->  file 
* **Result:** Constructs a file of type obj. Allowed extensions are limited to obj

[Top of the page](#table-of-contents)
  	
<br/>
----

### overlapping
* **Possible use:** 
    * msi.gama.util.IContainer<?,? extends msi.gama.metamodel.shape.IShape> OP unknown --->  `list<agent>` 
* **Result:** A list of agents among the left-operand list, species or meta-population (addition of species), overlapping the operand (casted as a geometry).
* **Examples:** 
```
list<agent> var0 <- [ag1, ag2, ag3] overlapping(self); 	// var0 equals return the agents among ag1, ag2 and ag3 that overlap the shape of the agent applying the operator.
(species1 + species2) overlapping self
```
      
* **See also:** [neighbours_at](#neighbours_at), [neighbours_of](#neighbours_of), [agent_closest_to](#agent_closest_to), [agents_inside](#agents_inside), [closest_to](#closest_to), [inside](#inside), [agents_overlapping](#agents_overlapping), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### overlaps
* **Possible use:** 
    * geometry OP geometry --->  bool 
* **Result:** A boolean, equal to true if the left-geometry (or agent/point) overlaps the right-geometry (or agent/point).
* **Special cases:**     
  * if one of the operand is null, returns false.    
  * if one operand is a point, returns true if the point is included in the geometry
* **Examples:** 
```
bool var0 <- polyline([{10,10},{20,20}]) overlaps polyline([{15,15},{25,25}]); 	// var0 equals true
bool var1 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); 	// var1 equals true
bool var2 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps {25,25}; 	// var2 equals false
bool var3 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{35,35},{35,45},{45,45},{45,35}]); 	// var3 equals false
bool var4 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polyline([{10,10},{20,20}]); 	// var4 equals true
bool var5 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps {15,15}; 	// var5 equals true
bool var6 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{0,0},{0,30},{30,30}, {30,0}]); 	// var6 equals true
bool var7 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); 	// var7 equals true
bool var8 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{10,20},{20,20},{20,30},{10,30}]); 	// var8 equals true
```
      
* **See also:** [disjoint_from](#disjoint_from), [crosses](#crosses), [intersects](#intersects), [partially_overlaps](#partially_overlaps), [touches](#touches), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### pacman
* **Possible use:** 
    * OP(float) --->  geometry
    * float OP float --->  geometry 
* **Result:** An pacman geometry with a dynamic opening mouth which radius is equal to first argument.An pacman geometry which radius is equal to first argument.  
* **Comment:** the centre of the sphere is by default the location of the current agent in which has been called this operator.the centre of the sphere is by default the location of the current agent in which has been called this operator.
* **Special cases:**     
  * returns a point if the operand is lower or equal to 0.    
  * returns a point if the operand is lower or equal to 0.
* **Examples:** 
```
geometry var0 <- pacman(1,0.2); 	// var0 equals a geometry as a circle of radius 10 but displays a sphere.
geometry var1 <- pacman(1); 	// var1 equals a geometry as a circle of radius 10 but displays a sphere.
```
      
* **See also:** [around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), [hemisphere](#hemisphere), [pie3D](#pie3D), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### partially_overlaps
* **Possible use:** 
    * geometry OP geometry --->  bool 
* **Result:** A boolean, equal to true if the left-geometry (or agent/point) partially overlaps the right-geometry (or agent/point).  
* **Comment:** if one geometry operand fully covers the other geometry operand, returns false (contrarily to the overlaps operator).
* **Special cases:**     
  * if one of the operand is null, returns false.
* **Examples:** 
```
bool var0 <- polyline([{10,10},{20,20}]) partially_overlaps polyline([{15,15},{25,25}]); 	// var0 equals true
bool var1 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); 	// var1 equals true
bool var2 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps {25,25}; 	// var2 equals false
bool var3 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{35,35},{35,45},{45,45},{45,35}]); 	// var3 equals false
bool var4 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polyline([{10,10},{20,20}]); 	// var4 equals false
bool var5 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps {15,15}; 	// var5 equals false
bool var6 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{0,0},{0,30},{30,30}, {30,0}]); 	// var6 equals false
bool var7 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); 	// var7 equals true
bool var8 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{10,20},{20,20},{20,30},{10,30}]); 	// var8 equals false
```
      
* **See also:** [disjoint_from](#disjoint_from), [crosses](#crosses), [overlaps](#overlaps), [intersects](#intersects), [touches](#touches), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### path_between
* **Possible use:** 
    * topology OP `container<geometry>` --->  path 
* **Result:** A path between a list of two geometries (geometries, agents or points) considering a topology.
* **Examples:** 
```
path var0 <- my_topology path_between [ag1, ag2]; 	// var0 equals A path between ag1 and ag2
```
      
* **See also:** [towards](#towards), [direction_to](#direction_to), [distance_between](#distance_between), [direction_between](#direction_between), [path_to](#path_to), [distance_to](#distance_to), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### path_to
* **Possible use:** 
    * geometry OP geometry --->  path
    * point OP point --->  path 
* **Result:** A path between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.
* **Examples:** 
```
path var0 <- ag1 path_to ag2; 	// var0 equals the path between ag1 and ag2 considering the topology of the agent applying the operator
```
      
* **See also:** [towards](#towards), [direction_to](#direction_to), [distance_between](#distance_between), [direction_between](#direction_between), [path_between](#path_between), [distance_to](#distance_to), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### pbinomSame signification as [binomial_sum](#binomial_sum)

[Top of the page](#table-of-contents)
  	
<br/>
----

### pchisqSame signification as [chi_square](#chi_square)

[Top of the page](#table-of-contents)
  	
<br/>
----

### percent_absolute_deviation
* **Possible use:** 
    * `list<float>` OP `list<float>` --->  float 
* **Result:** percent absolute deviation indicator for 2 series of values: percent_absolute_deviation(list_vals_observe,list_vals_sim)
* **Examples:** 
```
percent_absolute_deviation([200,300,150,150,200],[250,250,100,200,200])
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### percentileSame signification as [quantile_inverse](#quantile_inverse)

[Top of the page](#table-of-contents)
  	
<br/>
----

### pgammaSame signification as [gamma_distribution](#gamma_distribution)

[Top of the page](#table-of-contents)
  	
<br/>
----

### plan
* **Possible use:** 
    * `container<geometry>` OP float --->  geometry 
* **Result:** A polyline geometry from the given list of points.
* **Special cases:**     
  * if the operand is nil, returns the point geometry {0,0}    
  * if the operand is composed of a single point, returns a point geometry.
* **Examples:** 
```
geometry var0 <- polyplan([{0,0}, {0,10}, {10,10}, {10,0}],10); 	// var0 equals a polyline geometry composed of the 4 points with a depth of 10.
```
      
* **See also:** [around](#around), [circle](#circle), [cone](#cone), [link](#link), [norm](#norm), [point](#point), [polygone](#polygone), [rectangle](#rectangle), [square](#square), [triangle](#triangle), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### pnormSame signification as [normal_area](#normal_area)

[Top of the page](#table-of-contents)
  	
<br/>
----

### points_at
* **Possible use:** 
    * int OP float --->  `list<point>` 
* **Result:** A list of left-operand number of points located at a the right-operand distance to the agent location.
* **Examples:** 
```
list<point> var0 <- 3 points_at(20.0); 	// var0 equals returns [pt1, pt2, pt3] with pt1, pt2 and pt3 located at a distance of 20.0 to the agent location
```
      
* **See also:** [any_location_in](#any_location_in), [any_point_in](#any_point_in), [closest_points_with](#closest_points_with), [farthest_point_to](#farthest_point_to), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### points_on
* **Possible use:** 
    * geometry OP float --->  list 
* **Result:** A list of points of the operand-geometry distant from each other to the float right-operand .
* **Examples:** 
```
list var0 <-  square(5) points_on(2); 	// var0 equals a list of points belonging to the exterior ring of the square distant from each other of 2.
```
      
* **See also:** [closest_points_with](#closest_points_with), [farthest_point_to](#farthest_point_to), [points_at](#points_at), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### polygon
* **Possible use:** 
    * OP(msi.gama.util.IContainer<?,? extends msi.gama.metamodel.shape.IShape>) --->  geometry 
* **Result:** A polygon geometry from the given list of points.
* **Special cases:**     
  * if the operand is nil, returns the point geometry {0,0}    
  * if the operand is composed of a single point, returns a point geometry    
  * if the operand is composed of 2 points, returns a polyline geometry.
* **Examples:** 
```
geometry var0 <- polygon([{0,0}, {0,10}, {10,10}, {10,0}]); 	// var0 equals a polygon geometry composed of the 4 points.
```
      
* **See also:** [around](#around), [circle](#circle), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### polyhedron
* **Possible use:** 
    * `container<geometry>` OP float --->  geometry 
* **Result:** A polyhedron geometry from the given list of points.
* **Special cases:**     
  * if the operand is nil, returns the point geometry {0,0}    
  * if the operand is composed of a single point, returns a point geometry    
  * if the operand is composed of 2 points, returns a polyline geometry.
* **Examples:** 
```
geometry var0 <- polyhedron([{0,0}, {0,10}, {10,10}, {10,0}],10); 	// var0 equals a polygon geometry composed of the 4 points and of depth 10.
```
      
* **See also:** [around](#around), [circle](#circle), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### polylineSame signification as [line](#line)

[Top of the page](#table-of-contents)
  	
<br/>
----

### polyplanSame signification as [plan](#plan)

[Top of the page](#table-of-contents)
  	
<br/>
----

### pValue_for_fStat
* **Possible use:** 
    * float OP int --->  float 
* **Result:** Returns the P value of F statistic fstat with numerator degrees of freedom dfn and denominator degress of freedom dfd. Uses the incomplete Beta function.

[Top of the page](#table-of-contents)
  	
<br/>
----

### pValue_for_tStat
* **Possible use:** 
    * float OP int --->  float 
* **Result:** Returns the P value of the T statistic tstat with df degrees of freedom. This is a two-tailed test so we just double the right tail which is given by studentT of -|tstat|.

[Top of the page](#table-of-contents)
  	
<br/>
----

### pyramid
* **Possible use:** 
    * OP(float) --->  geometry 
* **Result:** A square geometry which side size is given by the operand.  
* **Comment:** the centre of the pyramid is by default the location of the current agent in which has been called this operator.
* **Special cases:**     
  * returns nil if the operand is nil.
* **Examples:** 
```
geometry var0 <- pyramid(5); 	// var0 equals a geometry as a square with side_size = 5.
```
      
* **See also:** [around](#around), [circle](#circle), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### quantile
* **Possible use:** 
    * container OP float --->  float 
* **Result:** Returns the phi-quantile; that is, an element elem for which holds that phi percent of data elements are less than elem. The quantile need not necessarily be contained in the data sequence, it can be a linear interpolation.

[Top of the page](#table-of-contents)
  	
<br/>
----

### quantile_inverse
* **Possible use:** 
    * container OP float --->  float 
* **Result:** Returns how many percent of the elements contained in the receiver are <= element. Does linear interpolation if the element is not contained but lies in between two contained elements.

[Top of the page](#table-of-contents)
  	
<br/>
----

### rank_interpolated
* **Possible use:** 
    * container OP float --->  float 
* **Result:** Returns the linearly interpolated number of elements in a list less or equal to a given element. The rank is the number of elements <= element. Ranks are of the form {0, 1, 2,..., sortedList.size()}. If no element is <= element, then the rank is zero. If the element lies in between two contained elements, then linear interpolation is used and a non integer value is returned.

[Top of the page](#table-of-contents)
  	
<br/>
----

### read_json_rest
* **Possible use:** 
    * string OP string --->  msi.gama.util.IList<msi.gama.util.IList<java.lang.Object>> 
* **Result:** REST: Read data from RESTService

[Top of the page](#table-of-contents)
  	
<br/>
----

### rectangle
* **Possible use:** 
    * OP(point) --->  geometry
    * float OP float --->  geometry 
* **Result:** A rectangle geometry which side sizes are given by the operands.  
* **Comment:** the centre of the rectangle is by default the location of the current agent in which has been called this operator.the centre of the rectangle is by default the location of the current agent in which has been called this operator.
* **Special cases:**     
  * returns nil if the operand is nil.    
  * returns nil if the operand is nil.
* **Examples:** 
```
geometry var0 <- rectangle({10, 5}); 	// var0 equals a geometry as a rectangle with width = 10 and heigh = 5.
geometry var1 <- rectangle(10, 5); 	// var1 equals a geometry as a rectangle with width = 10 and heigh = 5.
```
      
* **See also:** [around](#around), [circle](#circle), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [square](#square), [triangle](#triangle), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### reduced_bySame signification as [-](#-)

[Top of the page](#table-of-contents)
  	
<br/>
----

### rgb_to_xyz
* **Possible use:** 
    * OP(file) --->  `list<point>` 
* **Result:** A list of point corresponding to RGB value of an image (r:x , g:y, b:z)
* **Examples:** 
```
list<point> var0 <- rgb_to_xyz(texture); 	// var0 equals a list of points
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### rgbcube
* **Possible use:** 
    * OP(float) --->  geometry 
* **Result:** A cube geometry which side size is equal to the operand.  
* **Comment:** the centre of the cube is by default the location of the current agent in which has been called this operator.
* **Special cases:**     
  * returns nil if the operand is nil.
* **Examples:** 
```
geometry var0 <- cube(10); 	// var0 equals a geometry as a square of side size 10.
```
      
* **See also:** [around](#around), [circle](#circle), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [triangle](#triangle), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### rgbtriangle
* **Possible use:** 
    * OP(float) --->  geometry 
* **Result:** A triangle geometry which side size is given by the operand.  
* **Comment:** the centre of the triangle is by default the location of the current agent in which has been called this operator.
* **Special cases:**     
  * returns nil if the operand is nil.
* **Examples:** 
```
geometry var0 <- triangle(5); 	// var0 equals a geometry as a triangle with side_size = 5.
```
      
* **See also:** [around](#around), [circle](#circle), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### rms
* **Possible use:** 
    * int OP float --->  float 
* **Result:** Returns the RMS (Root-Mean-Square) of a data sequence. The RMS of data sequence is the square-root of the mean of the squares of the elements in the data sequence. It is a measure of the average size of the elements of a data sequence.

[Top of the page](#table-of-contents)
  	
<br/>
----

### rotated_by
* **Possible use:** 
    * geometry OP int --->  geometry
    * geometry OP float --->  geometry
    * geometry OP float --->  geometry 
* **Result:** A geometry resulting from the application of a rotation by the right-hand operand angles (degree) along the three axis (x,y,z) to the left-hand operand (geometry, agent, point)A geometry resulting from the application of a rotation by the right-hand operand angle (degree) to the left-hand operand (geometry, agent, point)  
* **Comment:** the right-hand operand can be a float or a int
* **Examples:** 
```
geometry var0 <- rotated_by(45, {1,0,0}); 	// var0 equals the geometry resulting from a 45 degres rotation along the {1,0,0} vector to the geometry of the agent applying the operator.
geometry var1 <- self rotated_by 45; 	// var1 equals the geometry resulting from a 45 degres rotation to the geometry of the agent applying the operator.
```
      
* **See also:** [transformed_by](#transformed_by), [translated_by](#translated_by), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### scaled_bySame signification as [*](#*)

[Top of the page](#table-of-contents)
  	
<br/>
----

### scaled_to
* **Possible use:** 
    * geometry OP point --->  geometry 
* **Result:** allows to restrict the size of a geometry so that it fits in the envelope {width, height, depth} defined by the second operand
* **Examples:** 
```
geometry var0 <- shape scaled_to {10,10}; 	// var0 equals a geometry corresponding to the geometry of the agent applying the operator scaled so that it fits a square of 10x10
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### set_z
* **Possible use:** 
    * geometry OP msi.gama.util.IContainer<?,java.lang.Double> --->  geometry
    * geometry OP int --->  geometry 
* **Result:** Sets the z ordinate of the n-th point of a geometry to the value provided by the third argument
* **Examples:** 
```
loop i from: 0 to: length(shape.points) - 1{set shape <-  set_z (shape, i, 3.0);}
shape <- triangle(3) set_z [5,10,14];
```
      
* **See also:** [add_z](#add_z), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### simple_clustering_by_distance
* **Possible use:** 
    * `container<agent>` OP float --->  `list<list<agent>>` 
* **Result:** A list of agent groups clustered by distance considering a distance min between two groups.
* **Examples:** 
```
list<list<agent>> var0 <- [ag1, ag2, ag3, ag4, ag5] simpleClusteringByDistance 20.0; 	// var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]
```
      
* **See also:** [hierarchical_clustering](#hierarchical_clustering), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### simple_clustering_by_envelope_distanceSame signification as [simple_clustering_by_distance](#simple_clustering_by_distance)

[Top of the page](#table-of-contents)
  	
<br/>
----

### simplification
* **Possible use:** 
    * geometry OP float --->  geometry 
* **Result:** A geometry corresponding to the simplification of the operand (geometry, agent, point) considering a tolerance distance.  
* **Comment:** The algorithm used for the simplification is Douglas-Peucker
* **Examples:** 
```
geometry var0 <- self simplification 0.1; 	// var0 equals the geometry resulting from the application of the Douglas-Peuker algorithm on the geometry of the agent applying the operator with a tolerance distance of 0.1.
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### skeletonize
* **Possible use:** 
    * OP(geometry) --->  `list<geometry>` 
* **Result:** A list of geometries (polylines) corresponding to the skeleton of the operand geometry (geometry, agent)
* **Examples:** 
```
list<geometry> var0 <- skeletonize(self); 	// var0 equals the list of geometries corresponding to the skeleton of the geometry of the agent applying the operator.
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### skew
* **Possible use:** 
    * OP(container) --->  float
    * float OP float --->  float 
* **Result:** Returns the skew of a data sequence.Returns the skew of a data sequence, which is moment(data,3,mean) / standardDeviation3

[Top of the page](#table-of-contents)
  	
<br/>
----

### slice
* **Possible use:** 
    * float OP float --->  geometry 
* **Result:** An sphere geometry which radius is equal to the operand made of 2 hemisphere.  
* **Comment:** the centre of the sphere is by default the location of the current agent in which has been called this operator.
* **Special cases:**     
  * returns a point if the operand is lower or equal to 0.
* **Examples:** 
```
geometry var0 <- slice(10,0.3); 	// var0 equals a circle geometry of radius 10, displayed as a slice.
```
      
* **See also:** [around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), [hemisphere](#hemisphere), [pie3D](#pie3D), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### smooth
* **Possible use:** 
    * geometry OP float --->  geometry 
* **Result:** Returns a 'smoothed' geometry, where straight lines are replaces by polynomial (bicubic) curves. The first parameter is the original geometry, the second is the 'fit' parameter which can be in the range 0 (loose fit) to 1 (tightest fit).
* **Examples:** 
```
geometry var0 <- smooth(square(10), 0.0); 	// var0 equals a 'rounded' square
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### solidSame signification as [without_holes](#without_holes)

[Top of the page](#table-of-contents)
  	
<br/>
----

### sphere
* **Possible use:** 
    * OP(float) --->  geometry 
* **Result:** A sphere geometry which radius is equal to the operand.  
* **Comment:** the centre of the sphere is by default the location of the current agent in which has been called this operator.
* **Special cases:**     
  * returns a point if the operand is lower or equal to 0.
* **Examples:** 
```
geometry var0 <- sphere(10); 	// var0 equals a geometry as a circle of radius 10 but displays a sphere.
```
      
* **See also:** [around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### spherical_pie
* **Possible use:** 
    * float OP `list<float>` --->  geometry
    * float OP `list<float>` --->  geometry 
* **Result:** An sphere geometry which radius is equal to the operand made of n pie.An sphere geometry which radius is equal to the operand made of n pie.  
* **Comment:** the centre of the sphere is by default the location of the current agent in which has been called this operator.the centre of the sphere is by default the location of the current agent in which has been called this operator.
* **Special cases:**     
  * returns a point if the operand is lower or equal to 0.    
  * returns a point if the operand is lower or equal to 0.
* **Examples:** 
```
geometry var0 <- spherical_pie(10,[1.0,1.0,1.0]); 	// var0 equals a circle geometry of radius 10, displayed as a sphere with 4 slices.
geometry var1 <- spherical_pie(10/2,[0.1,0.9],[#red,#green]); 	// var1 equals a circle geometry of radius 10, displayed as a sphere with 2 slices.
```
      
* **See also:** [around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), [hemisphere](#hemisphere), [pie3D](#pie3D), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### split_at
* **Possible use:** 
    * geometry OP point --->  `list<geometry>` 
* **Result:** The two part of the left-operand lines split at the given right-operand point
* **Special cases:**     
  * if the left-operand is a point or a polygon, returns an empty list
* **Examples:** 
```
list<geometry> var0 <- polyline([{1,2},{4,6}]) split_at {7,6}; 	// var0 equals [polyline([{1.0,2.0},{7.0,6.0}]), polyline([{7.0,6.0},{4.0,6.0}])]
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### split_geometry
* **Possible use:** 
    * geometry OP float --->  `list<geometry>`
    * geometry OP point --->  `list<geometry>`
    * geometry OP int --->  `list<geometry>` 
* **Result:** A list of geometries that result from the decomposition of the geometry according to a grid with the given number of rows and columns (geometry, nb_cols, nb_rows)A list of geometries that result from the decomposition of the geometry by square cells of the given side size (geometry, size)A list of geometries that result from the decomposition of the geometry by rectangle cells of the given dimension (geometry, {size_x, size_y})
* **Examples:** 
```
list<geometry> var0 <- to_rectangles(self, 10,20); 	// var0 equals the list of the geometries corresponding to the decomposition of the geometry of the agent applying the operator
list<geometry> var1 <- to_squares(self, 10.0); 	// var1 equals the list of the geometries corresponding to the decomposition of the geometry by squares of side size 10.0
list<geometry> var2 <- to_rectangles(self, {10.0, 15.0}); 	// var2 equals the list of the geometries corresponding to the decomposition of the geometry by rectangles of size 10.0, 15.0
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### split_lines
* **Possible use:** 
    * OP(`container<geometry>`) --->  `list<geometry>` 
* **Result:** A list of geometries resulting after cutting the lines at their intersections.
* **Examples:** 
```
list<geometry> var0 <- split_lines([line([{0,10}, {20,10}]), line([{0,10}, {20,10}])]); 	// var0 equals a list of four polylines: line([{0,10}, {10,10}]), line([{10,10}, {20,10}]), line([{10,0}, {10,10}]) and line([{10,10}, {10,20}])
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### square
* **Possible use:** 
    * OP(float) --->  geometry 
* **Result:** A square geometry which side size is equal to the operand.  
* **Comment:** the centre of the square is by default the location of the current agent in which has been called this operator.
* **Special cases:**     
  * returns nil if the operand is nil.
* **Examples:** 
```
geometry var0 <- square(10); 	// var0 equals a geometry as a square of side size 10.
```
      
* **See also:** [around](#around), [circle](#circle), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [triangle](#triangle), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### squircle
* **Possible use:** 
    * float OP float --->  geometry 
* **Result:** A mix of square and circle geometry (see : http://en.wikipedia.org/wiki/Squircle), which side size is equal to the first operand and power is equal to the second operand  
* **Comment:** the centre of the ellipse is by default the location of the current agent in which has been called this operator.
* **Special cases:**     
  * returns a point if the side operand is lower or equal to 0.
* **Examples:** 
```
geometry var0 <- squircle(4,4); 	// var0 equals a geometry as a squircle of side 4 with a power of 4.
```
      
* **See also:** [around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [super_ellipse](#super_ellipse), [rectangle](#rectangle), [square](#square), [circle](#circle), [ellipse](#ellipse), [triangle](#triangle), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### student_area
* **Possible use:** 
    * float OP int --->  float 
* **Result:** Returns the area to the left of x in the Student T distribution with the given degrees of freedom.

[Top of the page](#table-of-contents)
  	
<br/>
----

### student_t_inverse
* **Possible use:** 
    * float OP int --->  float 
* **Result:** Returns the value, t, for which the area under the Student-t probability density function (integrated from minus infinity to t) is equal to x.

[Top of the page](#table-of-contents)
  	
<br/>
----

### teapot
* **Possible use:** 
    * OP(float) --->  geometry 
* **Result:** A teapot geometry which radius is equal to the operand.  
* **Comment:** the centre of the teapot is by default the location of the current agent in which has been called this operator.
* **Special cases:**     
  * returns a point if the operand is lower or equal to 0.
* **Examples:** 
```
geometry var0 <- teapot(10); 	// var0 equals a geometry as a circle of radius 10 but displays a teapot.
```
      
* **See also:** [around](#around), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), [triangle](#triangle), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### threeds_file
* **Possible use:** 
    * OP(string) --->  file 
* **Result:** Constructs a file of type threeds. Allowed extensions are limited to 3ds, max

[Top of the page](#table-of-contents)
  	
<br/>
----

### to_GAMA_CRS
* **Possible use:** 
    * OP(geometry) --->  geometry
    * geometry OP string --->  geometry
* **Special cases:**     
  * returns the geometry corresponding to the transfomartion of the given geometry to the GAMA CRS (Coordinate Reference System) assuming the given geometry is referenced by the current CRS, the one corresponding to the world's agent one 
```
geometry var0 <- to_GAMA_CRS({121,14}); 	// var0 equals a geometry corresponding to the agent geometry transformed into the GAMA CRS
 ```     
  * returns the geometry corresponding to the transfomartion of the given geometry to the GAMA CRS (Coordinate Reference System) assuming the given geometry is referenced by given CRS 
```
geometry var1 <- to_GAMA_CRS({121,14}, "EPSG:4326"); 	// var1 equals a geometry corresponding to the agent geometry transformed into the GAMA CRS
 ``` 

[Top of the page](#table-of-contents)
  	
<br/>
----

### to_GAMA_CRS
* **Possible use:** 
    * OP(geometry) --->  geometry
    * geometry OP string --->  geometry
* **Special cases:**     
  * returns the geometry corresponding to the transfomartion of the given geometry to the GAMA CRS (Coordinate Reference System) assuming the given geometry is referenced by given CRS 
```
geometry var0 <- to_GAMA_CRS({121,14}, "EPSG:4326"); 	// var0 equals a geometry corresponding to the agent geometry transformed into the GAMA CRS
 ```     
  * returns the geometry corresponding to the transfomartion of the given geometry to the GAMA CRS (Coordinate Reference System) assuming the given geometry is referenced by the current CRS, the one corresponding to the world's agent one 
```
geometry var1 <- to_GAMA_CRS({121,14}); 	// var1 equals a geometry corresponding to the agent geometry transformed into the GAMA CRS
 ``` 

[Top of the page](#table-of-contents)
  	
<br/>
----

### to_rectanglesSame signification as [split_geometry](#split_geometry)
* **Possible use:** 
    * geometry OP point --->  `list<geometry>`
    * geometry OP int --->  `list<geometry>` 
* **Result:** A list of rectangles corresponding to the given dimension that result from the decomposition of the geometry into rectangles (geometry, nb_cols, nb_rows, overlaps) by a grid composed of the given number of columns and rows, if overlaps = true, add the rectangles that overlap the border of the geometryA list of rectangles of the size corresponding to the given dimension that result from the decomposition of the geometry into rectangles (geometry, dimension, overlaps), if overlaps = true, add the rectangles that overlap the border of the geometry
* **Examples:** 
```
list<geometry> var0 <- to_rectangles(self, 5, 20, true); 	// var0 equals the list of rectangles corresponding to the discretisation by a grid of 5 columns and 20 rows into rectangles of the geometry of the agent applying the operator. The rectangles overlapping the border of the geometry are kept
list<geometry> var1 <- to_rectangles(self, {10.0, 15.0}, true); 	// var1 equals the list of rectangles of size {10.0, 15.0} corresponding to the discretisation into rectangles of the geometry of the agent applying the operator. The rectangles overlapping the border of the geometry are kept
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### to_squares
* **Possible use:** 
    * geometry OP float --->  `list<geometry>`
    * geometry OP int --->  `list<geometry>`
    * geometry OP int --->  `list<geometry>` 
* **Result:** A list of squares of the size corresponding to the given size that result from the decomposition of the geometry into squares (geometry, size, overlaps), if overlaps = true, add the squares that overlap the border of the geometryA list of a given number of squares from the decomposition of the geometry into squares (geometry, nb_square, overlaps, precision_coefficient), if overlaps = true, add the squares that overlap the border of the geometry, coefficient_precision should be close to 1.0A list of a given number of squares from the decomposition of the geometry into squares (geometry, nb_square, overlaps), if overlaps = true, add the squares that overlap the border of the geometry
* **Examples:** 
```
list<geometry> var0 <- to_squares(self, 10.0, true); 	// var0 equals the list of squares of side size 10.0 corresponding to the discretisation into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept
list<geometry> var1 <- to_squares(self, 10, true, 0.99); 	// var1 equals the list of 10 squares corresponding to the discretisation into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept
list<geometry> var2 <- to_squares(self, 10, true); 	// var2 equals the list of 10 squares corresponding to the discretisation into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### to_trianglesSame signification as [triangulate](#triangulate)

[Top of the page](#table-of-contents)
  	
<br/>
----

### touches
* **Possible use:** 
    * geometry OP geometry --->  bool 
* **Result:** A boolean, equal to true if the left-geometry (or agent/point) touches the right-geometry (or agent/point).  
* **Comment:** returns true when the left-operand only touches the right-operand. When one geometry covers partially (or fully) the other one, it returns false.
* **Special cases:**     
  * if one of the operand is null, returns false.
* **Examples:** 
```
bool var0 <- polyline([{10,10},{20,20}]) touches {15,15}; 	// var0 equals false
bool var1 <- polyline([{10,10},{20,20}]) touches {10,10}; 	// var1 equals true
bool var2 <- {15,15} touches {15,15}; 	// var2 equals false
bool var3 <- polyline([{10,10},{20,20}]) touches polyline([{10,10},{5,5}]); 	// var3 equals true
bool var4 <- polyline([{10,10},{20,20}]) touches polyline([{5,5},{15,15}]); 	// var4 equals false
bool var5 <- polyline([{10,10},{20,20}]) touches polyline([{15,15},{25,25}]); 	// var5 equals false
bool var6 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{15,15},{15,25},{25,25},{25,15}]); 	// var6 equals false
bool var7 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{10,20},{20,20},{20,30},{10,30}]); 	// var7 equals true
bool var8 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{10,10},{0,10},{0,0},{10,0}]); 	// var8 equals true
bool var9 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches {15,15}; 	// var9 equals false
bool var10 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches {10,15}; 	// var10 equals true
```
      
* **See also:** [disjoint_from](#disjoint_from), [crosses](#crosses), [overlaps](#overlaps), [partially_overlaps](#partially_overlaps), [intersects](#intersects), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### towards
* **Possible use:** 
    * geometry OP geometry --->  int 
* **Result:** The direction (in degree) between the two geometries (geometries, agents, points) considering the topology of the agent applying the operator.
* **Examples:** 
```
int var0 <- ag1 towards ag2; 	// var0 equals the direction between ag1 and ag2 and ag3 considering the topology of the agent applying the operator
```
      
* **See also:** [distance_between](#distance_between), [distance_to](#distance_to), [direction_between](#direction_between), [path_between](#path_between), [path_to](#path_to), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### transformed_by
* **Possible use:** 
    * geometry OP point --->  geometry 
* **Result:** A geometry resulting from the application of a rotation and a scaling (rigth-operand : point {angle(degree), scale factor} of the left-hand operand (geometry, agent, point)
* **Examples:** 
```
geometry var0 <- self transformed_by {45, 0.5}; 	// var0 equals the geometry resulting from 45 degrees rotation and 50% scaling of the geometry of the agent applying the operator.
```
      
* **See also:** [rotated_by](#rotated_by), [translated_by](#translated_by), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### translated_by
* **Possible use:** 
    * geometry OP point --->  geometry 
* **Result:** A geometry resulting from the application of a translation by the right-hand operand distance to the left-hand operand (geometry, agent, point)
* **Examples:** 
```
geometry var0 <- self translated_by {10,10,10}; 	// var0 equals the geometry resulting from applying the translation to the left-hand geometry (or agent).
```
      
* **See also:** [rotated_by](#rotated_by), [transformed_by](#transformed_by), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### translated_toSame signification as [at_location](#at_location)

[Top of the page](#table-of-contents)
  	
<br/>
----

### triangle
* **Possible use:** 
    * OP(float) --->  geometry 
* **Result:** A triangle geometry which side size is given by the operand.  
* **Comment:** the centre of the triangle is by default the location of the current agent in which has been called this operator.
* **Special cases:**     
  * returns nil if the operand is nil.
* **Examples:** 
```
geometry var0 <- triangle(5); 	// var0 equals a geometry as a triangle with side_size = 5.
```
      
* **See also:** [around](#around), [circle](#circle), [cone](#cone), [line](#line), [link](#link), [norm](#norm), [point](#point), [polygon](#polygon), [polyline](#polyline), [rectangle](#rectangle), [square](#square), 

[Top of the page](#table-of-contents)
  	
<br/>
----

### triangulate
* **Possible use:** 
    * OP(`list<geometry>`) --->  `list<geometry>`
    * OP(geometry) --->  `list<geometry>` 
* **Result:** A list of geometries (triangles) corresponding to the Delaunay triangulation of the operand geometry (geometry, agent, point)
* **Examples:** 
```
list<geometry> var0 <- triangulate(self); 	// var0 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator.
list<geometry> var1 <- triangulate(self); 	// var1 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator.
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### union
* **Possible use:** 
    * OP(`container<geometry>`) --->  geometry
* **Special cases:**     
  * if the right-operand is a container of points, geometries or agents, returns the geometry resulting from the union all the geometries
* **Examples:** 
```
geometry var0 <- union([geom1, geom2, geom3]); 	// var0 equals a geometry corresponding to union between geom1, geom2 and geom3
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### variance
* **Possible use:** 
    * OP(float) --->  float
    * int OP float --->  float 
* **Result:** Returns the variance of a data sequence. That is (sumOfSquares - mean*sum) / size with mean = sum/size.Returns the variance from a standard deviation.

[Top of the page](#table-of-contents)
  	
<br/>
----

### voronoi
* **Possible use:** 
    * OP(`list<point>`) --->  `list<geometry>` 
* **Result:** A list of geometries corresponding to the Voronoi diagram built from the list of points
* **Examples:** 
```
list<geometry> var0 <- voronoi([{10,10},{50,50},{90,90},{10,90},{90,10}]); 	// var0 equals the list of geometries corresponding to the Voronoi Diagram built from the list of points.
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### water_area_for
* **Possible use:** 
    * geometry OP float --->  float
* **Special cases:**     
  * if the left operand is a polyline and the right operand a float for the water y coordinate, returrns the area of the water (water flow area)
* **Examples:** 
```
waterarea <- my_river_polyline water_area_for my_height_value
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### water_level_for
* **Possible use:** 
    * geometry OP float --->  float
* **Special cases:**     
  * if the left operand is a polyline and the right operand a float for the area, returrns the y coordinate of the water (water level)
* **Examples:** 
```
waterlevel <- my_river_polyline water_level_for my_area_value
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### water_polylines_for
* **Possible use:** 
    * geometry OP float --->  msi.gama.util.IList<msi.gama.util.IList<msi.gama.metamodel.shape.GamaPoint>>
* **Special cases:**     
  * if the left operand is a polyline and the right operand a float for the water y coordinate, returrns the shapes of the river sections (list of list of points)
* **Examples:** 
```
waterarea <- my_river_polyline water_area_for my_height_value
```
  

[Top of the page](#table-of-contents)
  	
<br/>
----

### without_holes
* **Possible use:** 
    * OP(geometry) --->  geometry 
* **Result:** A geometry corresponding to the operand geometry (geometry, agent, point) without its holes
* **Examples:** 
```
geometry var0 <- solid(self); 	// var0 equals the geometry corresponding to the geometry of the agent applying the operator without its holes.
```
  

[Top of the page](#table-of-contents)
  	