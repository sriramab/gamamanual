<<<<<<< HEAD
#Operators (A to C)
 	
----

**This file is automatically generated from java files. Do Not Edit It.**

----

## Definition 

Operators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function. 

Most of them use a classical prefixed functional syntax (i.e. `operator_name(operand1, operand2, operand3)`, see below), with the exception of arithmetic (e.g. `+`, `/`), logical (`and`, `or`), comparison (e.g. `>`, `<`), access (`.`, `[..]`) and pair (`::`) operators, which require an infixed notation (i.e. `operand1 operator_symbol operand1`). 

The ternary functional if-else operator, `? :`, uses a special infixed syntax composed with two symbols (e.g. `operand1 ? operand2 : operand3`). Two unary operators (`-` and `!`) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g. ` - 10`, `! (operand1 or operand2)`). 

Finally, special constructor operators (`{...}` for constructing points, `[...]` for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. `{1,2,3}`, `[operand1, operand2, ..., operandn]` or `[key1::value1, key2::value2... keyn::valuen]`).

With the exception of these special cases above, the following rules apply to the syntax of operators:
* if they only have one operand, the functional prefixed syntax is mandatory (e.g. `operator_name(operand1)`)
* if they have two arguments, either the functional prefixed syntax (e.g. `operator_name(operand1, operand2)`) or the infixed syntax (e.g. `operand1 operator_name operand2`) can be used.
* if they have more than two arguments, either the functional prefixed syntax (e.g. `operator_name(operand1, operand2, ..., operand)`) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. `operand1 operator_name(operand2, ..., operand)`) can be used.

All of these alternative syntaxes are completely equivalent.

Operators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the `shuffle` operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.

<br/>
----

## Priority between operators

The priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first.

GAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely:
* the constructor operators, like `::`, used to compose pairs of operands, have the lowest priority of all operators (e.g. `a > b :: b > c` will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, `[a > 10, b > 5]` will return a list of boolean values.
* it is followed by the `?:` operator, the functional if-else (e.g. ` a > b ? a + 10 : a - 10` will return the result of the if-else).
* next are the logical operators, `and` and `or` (e.g. `a > b or b > c` will return the value of the test)
* next are the comparison operators (i.e. `>`, `<`, `<=`, `>=`, `=`, `!=`)
* next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)
* next the unary operators `-` and `!`
* next the access operators `.` and `[]` (e.g. `{1,2,3}.x > 20 + {4,5,6}.y` will return the result of the comparison between the x and y ordinates of the two points)
* and finally the functional operators, which have the highest priority of all.

----

## Using actions as operators

Actions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand.

For instance, if the following species is defined:

```
species spec1 {
        int min(int x, int y) {
                return x > y ? x : y;
        }
}
```

Any agent instance of spec1 can use `min` as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:

```
global {
        init {
                create spec1;
                spec1 my_agent <- spec1[0];
                int the_min <- my_agent min(10,20); // or min(my_agent, 10, 20);
        }
}
```

If the action doesn't have any operands, the syntax to use is `my_agent the_action()`. Finally, if it does not return a value, it might still be used but is considering as returning a value of type `unknown` (e.g. `unknown result <- my_agent the_action(op1, op2);`).

Note that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).

	

----

## Table of Contents

----

## Operators by categories
	

----

### 3D


----

### Casting operators
[as](OperatorsAC#as), [as_int](OperatorsAC#as_int), [as_matrix](OperatorsAC#as_matrix), [font](OperatorsDM#font), [is](OperatorsDM#is), [is_skill](OperatorsDM#is_skill), [list_with](OperatorsDM#list_with), [matrix_with](OperatorsDM#matrix_with), [species](OperatorsNZ#species), [to_gaml](OperatorsNZ#to_gaml), [topology](OperatorsNZ#topology), 

----

### Color-related operators
[-](OperatorsAC#-), [/](OperatorsAC#/), [*](OperatorsAC#*), [+](OperatorsAC#+), [blend](OperatorsAC#blend), [brewer_colors](OperatorsAC#brewer_colors), [brewer_palettes](OperatorsAC#brewer_palettes), [grayscale](OperatorsDM#grayscale), [hsb](OperatorsDM#hsb), [mean](OperatorsDM#mean), [median](OperatorsDM#median), [rgb](OperatorsNZ#rgb), [rnd_color](OperatorsNZ#rnd_color), [sum](OperatorsNZ#sum), 

----

### Comparison operators
[!=](OperatorsAC#!=), [<](OperatorsAC#<), [<=](OperatorsAC#<=), [=](OperatorsAC#=), [>](OperatorsAC#>), [>=](OperatorsAC#>=), [between](OperatorsAC#between), 

----

### Containers-related operators
[-](OperatorsAC#-), [::](OperatorsAC#::), [+](OperatorsAC#+), [accumulate](OperatorsAC#accumulate), [among](OperatorsAC#among), [at](OperatorsAC#at), [collect](OperatorsAC#collect), [contains](OperatorsAC#contains), [contains_all](OperatorsAC#contains_all), [contains_any](OperatorsAC#contains_any), [count](OperatorsAC#count), [distinct](OperatorsDM#distinct), [empty](OperatorsDM#empty), [every](OperatorsDM#every), [first](OperatorsDM#first), [first_with](OperatorsDM#first_with), [get](OperatorsDM#get), [group_by](OperatorsDM#group_by), [in](OperatorsDM#in), [index_by](OperatorsDM#index_by), [inter](OperatorsDM#inter), [interleave](OperatorsDM#interleave), [internal_at](OperatorsDM#internal_at), [internal_integrated_value](OperatorsDM#internal_integrated_value), [last](OperatorsDM#last), [last_with](OperatorsDM#last_with), [length](OperatorsDM#length), [max](OperatorsDM#max), [max_of](OperatorsDM#max_of), [mean](OperatorsDM#mean), [mean_of](OperatorsDM#mean_of), [median](OperatorsDM#median), [min](OperatorsDM#min), [min_of](OperatorsDM#min_of), [mul](OperatorsDM#mul), [one_of](OperatorsNZ#one_of), [product_of](OperatorsNZ#product_of), [range](OperatorsNZ#range), [reverse](OperatorsNZ#reverse), [shuffle](OperatorsNZ#shuffle), [sort_by](OperatorsNZ#sort_by), [sum](OperatorsNZ#sum), [sum_of](OperatorsNZ#sum_of), [union](OperatorsNZ#union), [variance_of](OperatorsNZ#variance_of), [where](OperatorsNZ#where), [with_max_of](OperatorsNZ#with_max_of), [with_min_of](OperatorsNZ#with_min_of), 

----

### Date-related operators
[-](OperatorsAC#-), [!=](OperatorsAC#!=), [+](OperatorsAC#+), [<](OperatorsAC#<), [<=](OperatorsAC#<=), [=](OperatorsAC#=), [>](OperatorsAC#>), [>=](OperatorsAC#>=), [after](OperatorsAC#after), [before](OperatorsAC#before), [between](OperatorsAC#between), [every](OperatorsDM#every), [milliseconds_between](OperatorsDM#milliseconds_between), [minus_days](OperatorsDM#minus_days), [minus_hours](OperatorsDM#minus_hours), [minus_minutes](OperatorsDM#minus_minutes), [minus_months](OperatorsDM#minus_months), [minus_ms](OperatorsDM#minus_ms), [minus_weeks](OperatorsDM#minus_weeks), [minus_years](OperatorsDM#minus_years), [months_between](OperatorsDM#months_between), [plus_days](OperatorsNZ#plus_days), [plus_hours](OperatorsNZ#plus_hours), [plus_minutes](OperatorsNZ#plus_minutes), [plus_months](OperatorsNZ#plus_months), [plus_ms](OperatorsNZ#plus_ms), [plus_weeks](OperatorsNZ#plus_weeks), [plus_years](OperatorsNZ#plus_years), [since](OperatorsNZ#since), [to](OperatorsNZ#to), [until](OperatorsNZ#until), [years_between](OperatorsNZ#years_between), 

----

### Dates


----

### EDP-related operators
[diff](OperatorsDM#diff), [diff2](OperatorsDM#diff2), [internal_zero_order_equation](OperatorsDM#internal_zero_order_equation), 

----

### Files-related operators
[file](OperatorsDM#file), [file_exists](OperatorsDM#file_exists), [folder](OperatorsDM#folder), [get](OperatorsDM#get), [new_folder](OperatorsNZ#new_folder), [osm_file](OperatorsNZ#osm_file), [read](OperatorsNZ#read), [writable](OperatorsNZ#writable), 

----

### Graphs-related operators
[edge](OperatorsDM#edge), [edges](OperatorsDM#edges), [generate_barabasi_albert](OperatorsDM#generate_barabasi_albert), [generate_complete_graph](OperatorsDM#generate_complete_graph), [generate_watts_strogatz](OperatorsDM#generate_watts_strogatz), [node](OperatorsNZ#node), [nodes](OperatorsNZ#nodes), [sum](OperatorsNZ#sum), 

----

### Grid-related operators
[grid_at](OperatorsDM#grid_at), 

----

### Iterator operators
[accumulate](OperatorsAC#accumulate), [as_map](OperatorsAC#as_map), [collect](OperatorsAC#collect), [count](OperatorsAC#count), [create_map](OperatorsAC#create_map), [first_with](OperatorsDM#first_with), [frequency_of](OperatorsDM#frequency_of), [group_by](OperatorsDM#group_by), [index_by](OperatorsDM#index_by), [last_with](OperatorsDM#last_with), [max_of](OperatorsDM#max_of), [mean_of](OperatorsDM#mean_of), [min_of](OperatorsDM#min_of), [product_of](OperatorsNZ#product_of), [sort_by](OperatorsNZ#sort_by), [sum_of](OperatorsNZ#sum_of), [variance_of](OperatorsNZ#variance_of), [where](OperatorsNZ#where), [with_max_of](OperatorsNZ#with_max_of), [with_min_of](OperatorsNZ#with_min_of), 

----

### List-related operators
[copy_between](OperatorsAC#copy_between), [index_of](OperatorsDM#index_of), [last_index_of](OperatorsDM#last_index_of), 

----

### Logical operators
[:](OperatorsAC#:), [!](OperatorsAC#!), [?](OperatorsAC#?), [and](OperatorsAC#and), [or](OperatorsNZ#or), 

----

### Map comparaison operators
[fuzzy_kappa](OperatorsDM#fuzzy_kappa), [fuzzy_kappa_sim](OperatorsDM#fuzzy_kappa_sim), [kappa](OperatorsDM#kappa), [kappa_sim](OperatorsDM#kappa_sim), [percent_absolute_deviation](OperatorsNZ#percent_absolute_deviation), 

----

### Map-related operators
[as_map](OperatorsAC#as_map), [create_map](OperatorsAC#create_map), [index_of](OperatorsDM#index_of), [last_index_of](OperatorsDM#last_index_of), 

----

### Material
[material](OperatorsDM#material), 

----

### Matrix-related operators
[-](OperatorsAC#-), [/](OperatorsAC#/), [.](OperatorsAC#.), [*](OperatorsAC#*), [+](OperatorsAC#+), [append_horizontally](OperatorsAC#append_horizontally), [append_vertically](OperatorsAC#append_vertically), [column_at](OperatorsAC#column_at), [columns_list](OperatorsAC#columns_list), [determinant](OperatorsDM#determinant), [eigenvalues](OperatorsDM#eigenvalues), [index_of](OperatorsDM#index_of), [inverse](OperatorsDM#inverse), [last_index_of](OperatorsDM#last_index_of), [row_at](OperatorsNZ#row_at), [rows_list](OperatorsNZ#rows_list), [shuffle](OperatorsNZ#shuffle), [trace](OperatorsNZ#trace), [transpose](OperatorsNZ#transpose), 

----

### multicriteria operators
[electre_DM](OperatorsDM#electre_dm), [evidence_theory_DM](OperatorsDM#evidence_theory_dm), [fuzzy_choquet_DM](OperatorsDM#fuzzy_choquet_dm), [promethee_DM](OperatorsNZ#promethee_dm), [weighted_means_DM](OperatorsNZ#weighted_means_dm), 

----

### Path-related operators


----

### Points-related operators
[-](OperatorsAC#-), [/](OperatorsAC#/), [*](OperatorsAC#*), [+](OperatorsAC#+), [<](OperatorsAC#<), [<=](OperatorsAC#<=), [>](OperatorsAC#>), [>=](OperatorsAC#>=), [grid_at](OperatorsDM#grid_at), [norm](OperatorsNZ#norm), [point](OperatorsNZ#point), 

----

### Random operators
[binomial](OperatorsAC#binomial), [flip](OperatorsDM#flip), [gauss](OperatorsDM#gauss), [poisson](OperatorsNZ#poisson), [rnd](OperatorsNZ#rnd), [rnd_choice](OperatorsNZ#rnd_choice), [sample](OperatorsNZ#sample), [shuffle](OperatorsNZ#shuffle), [skew_gauss](OperatorsNZ#skew_gauss), [truncated_gauss](OperatorsNZ#truncated_gauss), 

----

### Shape


----

### Spatial operators
[gini](OperatorsDM#gini), [round](OperatorsNZ#round), [with_precision](OperatorsNZ#with_precision), 

----

### Spatial properties operators


----

### Spatial queries operators


----

### Species-related operators
[index_of](OperatorsDM#index_of), [last_index_of](OperatorsDM#last_index_of), [of_generic_species](OperatorsNZ#of_generic_species), [of_species](OperatorsNZ#of_species), 

----

### Statistical operators
[build](OperatorsAC#build), [corR](OperatorsAC#corr), [dbscan](OperatorsDM#dbscan), [frequency_of](OperatorsDM#frequency_of), [gamma_rnd](OperatorsDM#gamma_rnd), [geometric_mean](OperatorsDM#geometric_mean), [gini](OperatorsDM#gini), [harmonic_mean](OperatorsDM#harmonic_mean), [kmeans](OperatorsDM#kmeans), [kurtosis](OperatorsDM#kurtosis), [max](OperatorsDM#max), [mean](OperatorsDM#mean), [mean_deviation](OperatorsDM#mean_deviation), [meanR](OperatorsDM#meanr), [median](OperatorsDM#median), [min](OperatorsDM#min), [mul](OperatorsDM#mul), [predict](OperatorsNZ#predict), [skewness](OperatorsNZ#skewness), [standard_deviation](OperatorsNZ#standard_deviation), [sum](OperatorsNZ#sum), [variance](OperatorsNZ#variance), 

----

### Strings-related operators
[+](OperatorsAC#+), [<](OperatorsAC#<), [<=](OperatorsAC#<=), [>](OperatorsAC#>), [>=](OperatorsAC#>=), [at](OperatorsAC#at), [char](OperatorsAC#char), [contains](OperatorsAC#contains), [contains_all](OperatorsAC#contains_all), [contains_any](OperatorsAC#contains_any), [copy_between](OperatorsAC#copy_between), [date](OperatorsDM#date), [empty](OperatorsDM#empty), [first](OperatorsDM#first), [in](OperatorsDM#in), [indented_by](OperatorsDM#indented_by), [index_of](OperatorsDM#index_of), [is_number](OperatorsDM#is_number), [last](OperatorsDM#last), [last_index_of](OperatorsDM#last_index_of), [length](OperatorsDM#length), [lower_case](OperatorsDM#lower_case), [replace](OperatorsNZ#replace), [replace_regex](OperatorsNZ#replace_regex), [reverse](OperatorsNZ#reverse), [shuffle](OperatorsNZ#shuffle), [split_with](OperatorsNZ#split_with), [string](OperatorsNZ#string), [upper_case](OperatorsNZ#upper_case), 

----

### System
[.](OperatorsAC#.), [command](OperatorsAC#command), [copy](OperatorsAC#copy), [dead](OperatorsDM#dead), [eval_gaml](OperatorsDM#eval_gaml), [every](OperatorsDM#every), [user_input](OperatorsNZ#user_input), 

----

### Time-related operators
[date](OperatorsDM#date), [string](OperatorsNZ#string), 

----

### Types-related operators


----

### User control operators
[user_input](OperatorsNZ#user_input), 
	
----

## Operators
	
    	
----

[//]: # (keyword|operator_-)
### `-`

#### Possible use: 
  *  **`-`** (`point`) --->  `point`
  * `point` **`-`** `point` --->  `point`
  *  **`-`** (`point` , `point`) --->  `point`
  * `map` **`-`** `map` --->  `map`
  *  **`-`** (`map` , `map`) --->  `map`
  * `matrix` **`-`** `matrix` --->  `matrix`
  *  **`-`** (`matrix` , `matrix`) --->  `matrix`
  * `matrix` **`-`** `float` --->  `matrix`
  *  **`-`** (`matrix` , `float`) --->  `matrix`
  * `container` **`-`** `container` --->  `container`
  *  **`-`** (`container` , `container`) --->  `container`
  * `point` **`-`** `int` --->  `point`
  *  **`-`** (`point` , `int`) --->  `point`
  * `map` **`-`** `pair` --->  `map`
  *  **`-`** (`map` , `pair`) --->  `map`
  * `rgb` **`-`** `rgb` --->  `rgb`
  *  **`-`** (`rgb` , `rgb`) --->  `rgb`
  * `point` **`-`** `float` --->  `point`
  *  **`-`** (`point` , `float`) --->  `point`
  * `date` **`-`** `int` --->  `date`
  *  **`-`** (`date` , `int`) --->  `date`
  * `matrix` **`-`** `int` --->  `matrix`
  *  **`-`** (`matrix` , `int`) --->  `matrix`
  * `date` **`-`** `date` --->  `float`
  *  **`-`** (`date` , `date`) --->  `float`
  * `rgb` **`-`** `int` --->  `rgb`
  *  **`-`** (`rgb` , `int`) --->  `rgb`
  * `species` **`-`** `agent` --->  `container`
  *  **`-`** (`species` , `agent`) --->  `container`
  * `container` **`-`** `unknown` --->  `container`
  *  **`-`** (`container` , `unknown`) --->  `container`
  * `date` **`-`** `float` --->  `date`
  *  **`-`** (`date` , `float`) --->  `date` 

#### Result: 
Returns a point with coordinate resulting from the first operand minus the second operand.
returns a new map containing all the elements of the first operand not present in the second operand
returns a new list in which all the elements of the right operand have been removed from the left one
Returns a point with coordinate resulting from the first operand minus the second operand.
Returns a point with coordinate resulting from the negation of the operand
returns a new map containing all the elements of the first operand without the one of the second operand
a new color resulting from the subtraction of the two operands, component by component
Returns a point with coordinate resulting from the first operand minus the second operand.


a new color resulting from the subtraction of each component of the color with the right operand


Removes a duration from a date. The duration is expected to be in seconds (so that removing 0.5, for instance, will add 500ms)  

#### Comment: 
The behavior of the operator depends on the type of the operands.

#### Special cases:     
  * if both operands are containers and the right operand is empty, - returns the left operand    
  * if the left operand is a species and the right operand is an agent of the species, - returns a list containing all the agents of the species minus this agent    
  * if both operands are points, returns their difference (coordinates per coordinates). 
  
```
point var6 <- {1, 2} - {4, 5}; 	// var6 equals {-3.0, -3.0}

``` 

    
  * if both operands are containers, returns a new list in which all the elements of the right operand have been removed from the left one 
  
```
list<int> var7 <- [1,2,3,4,5,6] - [2,4,9]; 	// var7 equals [1,3,5,6]
list<int> var8 <- [1,2,3,4,5,6] - [0,8]; 	// var8 equals [1,2,3,4,5,6]

``` 

    
  * if both operands are colors, returns a new color resulting from the subtraction of the two operands, component by component 
  
```
rgb var9 <- rgb([255, 128, 32]) - rgb('red'); 	// var9 equals rgb([0,128,32])

``` 

    
  * if left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the difference of the operand coordinate with this number. 
  
```
point var10 <- {1, 2} - 4.5; 	// var10 equals {-3.5, -2.5, -4.5}
point var11 <- {1, 2} - 4; 	// var11 equals {-3.0,-2.0,-4.0}

``` 

    
  * if one of the operands is a date and the other a number, returns a date corresponding to the date minus the given number as duration (in seconds) 
  
```
date1 - 200

``` 

    
  * if both operands are dates, returns the duration in seconds between  date2 and date1. To obtain a more precise duration, in milliseconds, use milliseconds_between(date1, date2) 
  
```
float var13 <- date1 - date2; 	// var13 equals 598

``` 

    
  * if one operand is a color and the other an integer, returns a new color resulting from the subtraction of each component of the color with the right operand 
  
```
rgb var14 <- rgb([255, 128, 32]) - 3; 	// var14 equals rgb([252,125,29])

``` 

    
  * if the left operand is a list and the right operand is an object of any type (except list), - returns a list containing the elements of the left operand minus all the occurrences of this object 
  
```
list<int> var15 <- [1,2,3,4,5,6] - 2; 	// var15 equals [1,3,4,5,6]
list<int> var16 <- [1,2,3,4,5,6] - 0; 	// var16 equals [1,2,3,4,5,6]

``` 



#### Examples: 
```
map var0 <- ['a'::1,'b'::2] - ['b'::2]; 	// var0 equals ['a'::1]
map var1 <- ['a'::1,'b'::2] - ['b'::2,'c'::3]; 	// var1 equals ['a'::1]
point var2 <- -{3.0,5.0}; 	// var2 equals {-3.0,-5.0}
point var3 <- -{1.0,6.0,7.0}; 	// var3 equals {-1.0,-6.0,-7.0}
map var4 <- ['a'::1,'b'::2] - ('b'::2); 	// var4 equals ['a'::1]
map var5 <- ['a'::1,'b'::2] - ('c'::3); 	// var5 equals ['a'::1,'b'::2]
```
      

#### See also: 
[-](OperatorsAC#-), [+](OperatorsAC#+), [milliseconds_between](OperatorsDM#milliseconds_between), 
    	
----

[//]: # (keyword|operator_:)
### `:`

#### Possible use: 
  * `unknown` **`:`** `unknown` --->  `unknown`
  *  **`:`** (`unknown` , `unknown`) --->  `unknown`    

#### See also: 
[?](OperatorsAC#?), 
    	
----

[//]: # (keyword|operator_::)
### `::`

#### Possible use: 
  * `any expression` **`::`** `any expression` --->  `pair`
  *  **`::`** (`any expression` , `any expression`) --->  `pair` 

#### Result: 
produces a new pair combining the left and the right operands

#### Special cases:     
  * nil is not acceptable as a key (although it is as a value). If such a case happens, :: will throw an appropriate error
    	
----

[//]: # (keyword|operator_!)
### `!`

#### Possible use: 
  *  **`!`** (`bool`) --->  `bool` 

#### Result: 
opposite boolean value.

#### Special cases:     
  * if the parameter is not boolean, it is casted to a boolean value.

#### Examples: 
```
bool var0 <- ! (true); 	// var0 equals false
```
      

#### See also: 
[bool](OperatorsAC#bool), [and](OperatorsAC#and), [or](OperatorsNZ#or), 
    	
----

[//]: # (keyword|operator_!=)
### `!=`

#### Possible use: 
  * `float` **`!=`** `float` --->  `bool`
  *  **`!=`** (`float` , `float`) --->  `bool`
  * `float` **`!=`** `int` --->  `bool`
  *  **`!=`** (`float` , `int`) --->  `bool`
  * `unknown` **`!=`** `unknown` --->  `bool`
  *  **`!=`** (`unknown` , `unknown`) --->  `bool`
  * `date` **`!=`** `date` --->  `bool`
  *  **`!=`** (`date` , `date`) --->  `bool`
  * `int` **`!=`** `float` --->  `bool`
  *  **`!=`** (`int` , `float`) --->  `bool` 

#### Result: 
true if both operands are different, false otherwise

#### Examples: 
```
bool var0 <- 3.0 != 3.0; 	// var0 equals false
bool var1 <- 4.0 != 4.7; 	// var1 equals true
bool var2 <- 3.0 != 3; 	// var2 equals false
bool var3 <- 4.7 != 4; 	// var3 equals true
bool var4 <- [2,3] != [2,3]; 	// var4 equals false
bool var5 <- [2,4] != [2,3]; 	// var5 equals true
#now != #now minus_hours 1 :- true
bool var7 <- 3 != 3.0; 	// var7 equals false
bool var8 <- 4 != 4.7; 	// var8 equals true
```
      

#### See also: 
[=](OperatorsAC#=), [>](OperatorsAC#>), [<](OperatorsAC#<), [>=](OperatorsAC#>=), [<=](OperatorsAC#<=), 
    	
----

[//]: # (keyword|operator_?)
### `?`

#### Possible use: 
  * `bool` **`?`** `any expression` --->  `unknown`
  *  **`?`** (`bool` , `any expression`) --->  `unknown` 

#### Result: 
It is used in combination with the : operator: if the left-hand operand evaluates to true, returns the value of the left-hand operand of the :, otherwise that of the right-hand operand of the :  

#### Comment: 
These functional tests can be combined together.

#### Examples: 
```
list<string> var0 <- [10, 19, 43, 12, 7, 22] collect ((each > 20) ? 'above' : 'below'); 	// var0 equals ['below', 'below', 'above', 'below', 'below', 'above']
rgb color <- (flip(0.3) ? #red : (flip(0.9) ? #blue : #green));
```
      

#### See also: 
[:](OperatorsAC#:), 
    	
----

[//]: # (keyword|operator_/)
### `/`

#### Possible use: 
  * `rgb` **`/`** `float` --->  `rgb`
  *  **`/`** (`rgb` , `float`) --->  `rgb`
  * `point` **`/`** `int` --->  `point`
  *  **`/`** (`point` , `int`) --->  `point`
  * `point` **`/`** `float` --->  `point`
  *  **`/`** (`point` , `float`) --->  `point`
  * `rgb` **`/`** `int` --->  `rgb`
  *  **`/`** (`rgb` , `int`) --->  `rgb`
  * `matrix` **`/`** `int` --->  `matrix`
  *  **`/`** (`matrix` , `int`) --->  `matrix`
  * `matrix` **`/`** `float` --->  `matrix`
  *  **`/`** (`matrix` , `float`) --->  `matrix`
  * `matrix` **`/`** `matrix` --->  `matrix`
  *  **`/`** (`matrix` , `matrix`) --->  `matrix` 

#### Result: 
a new color resulting from the division of each component of the color by the right operand. The result on each component is then truncated.
Returns a point with coordinates divided by the number
Returns a point with coordinates divided by the number
a new color resulting from the division of each component of the color by the right operand

#### Special cases:     
  * if one operand is a color and the other a double, returns a new color resulting from the division of each component of the color by the right operand. The result on each component is then truncated. 
  
```
rgb var0 <- rgb([255, 128, 32]) / 2.5; 	// var0 equals rgb([102,51,13])

``` 

    
  * if the left operand is a point, returns a new point with coordinates divided by the right operand 
  
```
point var1 <- {5, 7.5} / 2.5; 	// var1 equals {2, 3}
point var2 <- {2,5} / 4; 	// var2 equals {0.5,1.25}

``` 

    
  * if one operand is a color and the other an integer, returns a new color resulting from the division of each component of the color by the right operand 
  
```
rgb var3 <- rgb([255, 128, 32]) / 2; 	// var3 equals rgb([127,64,16])

``` 


    	
----

[//]: # (keyword|operator_.)
### `.`

#### Possible use: 
  * `matrix` **`.`** `matrix` --->  `matrix`
  *  **`.`** (`matrix` , `matrix`) --->  `matrix`
  * `agent` **`.`** `any expression` --->  `unknown`
  *  **`.`** (`agent` , `any expression`) --->  `unknown` 

#### Result: 
It has two different uses: it can be the dot product between 2 matrices or return an evaluation of the expression (right-hand operand) in the scope the given agent.

#### Special cases:     
  * if the agent is nil or dead, throws an exception    
  * if both operands are matrix, returns the dot product of them 
  
```
matrix var0 <- matrix([[1,1],[1,2]]) . matrix([[1,1],[1,2]]); 	// var0 equals matrix([[2,3],[3,5]])

``` 

    
  * if the left operand is an agent, it evaluates of the expression (right-hand operand) in the scope the given agent 
  
```
unknown var1 <- agent1.location; 	// var1 equals the location of the agent agent1
map(nil).keys

``` 


    	
----

[//]: # (keyword|operator_@)
### `@`
Same signification as [at](OperatorsAC#at)
    	
----

[//]: # (keyword|operator_*)
### `*`

#### Possible use: 
  * `rgb` **`*`** `int` --->  `rgb`
  *  **`*`** (`rgb` , `int`) --->  `rgb`
  * `point` **`*`** `float` --->  `point`
  *  **`*`** (`point` , `float`) --->  `point`
  * `point` **`*`** `point` --->  `float`
  *  **`*`** (`point` , `point`) --->  `float`
  * `matrix` **`*`** `matrix` --->  `matrix`
  *  **`*`** (`matrix` , `matrix`) --->  `matrix`
  * `matrix` **`*`** `int` --->  `matrix`
  *  **`*`** (`matrix` , `int`) --->  `matrix`
  * `point` **`*`** `int` --->  `point`
  *  **`*`** (`point` , `int`) --->  `point`
  * `matrix` **`*`** `float` --->  `matrix`
  *  **`*`** (`matrix` , `float`) --->  `matrix` 

#### Result: 
a new color resulting from the product of each component of the color with the right operand
Returns a point with coordinates multiplied by a number.
Returns the scalar product of two points.
Returns a point with coordinates multiplied by a number.

#### Special cases:     
  * if one operand is a color and the other an integer, returns a new color resulting from the product of each component of the color with the right operand (with a maximum value at 255) 
  
```
rgb var0 <- rgb([255, 128, 32]) * 2; 	// var0 equals rgb([255,255,64])

``` 

    
  * if both operands are points, returns their scalar product 
  
```
float var1 <- {2,5} * {4.5, 5}; 	// var1 equals 34.0

``` 

    
  * if the left-hand operator is a point and the right-hand a number, returns a point with coordinates multiplied by the number 
  
```
point var2 <- {2,5} * 4; 	// var2 equals {8.0, 20.0}
point var3 <- {2, 4} * 2.5; 	// var3 equals {5.0, 10.0}

``` 


    	
----

[//]: # (keyword|operator_+)
### `+`

#### Possible use: 
  * `container` **`+`** `container` --->  `container`
  *  **`+`** (`container` , `container`) --->  `container`
  * `string` **`+`** `string` --->  `string`
  *  **`+`** (`string` , `string`) --->  `string`
  * `rgb` **`+`** `rgb` --->  `rgb`
  *  **`+`** (`rgb` , `rgb`) --->  `rgb`
  * `map` **`+`** `pair` --->  `map`
  *  **`+`** (`map` , `pair`) --->  `map`
  * `string` **`+`** `unknown` --->  `string`
  *  **`+`** (`string` , `unknown`) --->  `string`
  * `date` **`+`** `float` --->  `date`
  *  **`+`** (`date` , `float`) --->  `date`
  * `date` **`+`** `string` --->  `string`
  *  **`+`** (`date` , `string`) --->  `string`
  * `point` **`+`** `int` --->  `point`
  *  **`+`** (`point` , `int`) --->  `point`
  * `matrix` **`+`** `float` --->  `matrix`
  *  **`+`** (`matrix` , `float`) --->  `matrix`
  * `point` **`+`** `point` --->  `point`
  *  **`+`** (`point` , `point`) --->  `point`
  * `map` **`+`** `map` --->  `map`
  *  **`+`** (`map` , `map`) --->  `map`
  * `matrix` **`+`** `int` --->  `matrix`
  *  **`+`** (`matrix` , `int`) --->  `matrix`
  * `container` **`+`** `unknown` --->  `container`
  *  **`+`** (`container` , `unknown`) --->  `container`
  * `point` **`+`** `float` --->  `point`
  *  **`+`** (`point` , `float`) --->  `point`
  * `matrix` **`+`** `matrix` --->  `matrix`
  *  **`+`** (`matrix` , `matrix`) --->  `matrix`
  * `rgb` **`+`** `int` --->  `rgb`
  *  **`+`** (`rgb` , `int`) --->  `rgb`
  * `date` **`+`** `int` --->  `date`
  *  **`+`** (`date` , `int`) --->  `date` 

#### Result: 
returns a new list containing all the elements of both operands
A new color resulting from the sum of the two operands, component by component
returns a new map containing all the elements of both operands

Add a duration to a date. The duration is supposed to be in seconds (so that adding 0.5, for instance, will add 500ms)
returns the resulting string from the addition of a date and a string
Returns a point with coordinate summing of the two operands.
Returns a point with coordinate summing of the two operands.
returns a new map containing all the elements of both operands

Returns a point with coordinate summing of the two operands.
A new color resulting from the sum of each component of the color with the right operand

#### Special cases:     
  * if one of the operands is nil, + throws an error    
  * if both operands are species, returns a special type of list called meta-population    
  * if both operands are list, +returns the concatenation of both lists. 
  
```
list<int> var4 <- [1,2,3,4,5,6] + [2,4,9]; 	// var4 equals [1,2,3,4,5,6,2,4,9]
list<int> var5 <- [1,2,3,4,5,6] + [0,8]; 	// var5 equals [1,2,3,4,5,6,0,8]

``` 

    
  * if both operands are colors, returns a new color resulting from the sum of the two operands, component by component 
  
```
rgb var6 <- rgb([255, 128, 32]) + rgb('red'); 	// var6 equals rgb([255,128,32])

``` 

    
  * if the left-hand operand is a string, returns the concatenation of the two operands (the left-hand one beind casted into a string) 
  
```
string var7 <- "hello " + 12; 	// var7 equals "hello 12"

``` 

    
  * if both operands are points, returns their sum. 
  
```
point var8 <- {1, 2} + {4, 5}; 	// var8 equals {5.0, 7.0}

``` 

    
  * if the right operand is an object of any type (except a container), + returns a list of the elements of the left operand, to which this object has been added 
  
```
list<int> var9 <- [1,2,3,4,5,6] + 2; 	// var9 equals [1,2,3,4,5,6,2]
list<int> var10 <- [1,2,3,4,5,6] + 0; 	// var10 equals [1,2,3,4,5,6,0]

``` 

    
  * if the left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the sum of the operand coordinate with this number. 
  
```
point var11 <- {1, 2} + 4; 	// var11 equals {5.0, 6.0,4.0}
point var12 <- {1, 2} + 4.5; 	// var12 equals {5.5, 6.5,4.5}

``` 

    
  * if one operand is a color and the other an integer, returns a new color resulting from the sum of each component of the color with the right operand 
  
```
rgb var13 <- rgb([255, 128, 32]) + 3; 	// var13 equals rgb([255,131,35])

``` 

    
  * if one of the operands is a date and the other a number, returns a date corresponding to the date plus the given number as duration (in seconds) 
  
```
date1 + 200

``` 



#### Examples: 
```
map var0 <- ['a'::1,'b'::2] + ('c'::3); 	// var0 equals ['a'::1,'b'::2,'c'::3]
map var1 <- ['a'::1,'b'::2] + ('c'::3); 	// var1 equals ['a'::1,'b'::2,'c'::3]
map var2 <- ['a'::1,'b'::2] + ['c'::3]; 	// var2 equals ['a'::1,'b'::2,'c'::3]
map var3 <- ['a'::1,'b'::2] + [5::3.0]; 	// var3 equals ['a'::1.0,'b'::2.0,5::3.0]
```
      

#### See also: 
[-](OperatorsAC#-), 
    	
----

[//]: # (keyword|operator_<)
### `<`

#### Possible use: 
  * `string` **`<`** `string` --->  `bool`
  *  **`<`** (`string` , `string`) --->  `bool`
  * `float` **`<`** `float` --->  `bool`
  *  **`<`** (`float` , `float`) --->  `bool`
  * `float` **`<`** `int` --->  `bool`
  *  **`<`** (`float` , `int`) --->  `bool`
  * `date` **`<`** `date` --->  `bool`
  *  **`<`** (`date` , `date`) --->  `bool`
  * `point` **`<`** `point` --->  `bool`
  *  **`<`** (`point` , `point`) --->  `bool`
  * `int` **`<`** `int` --->  `bool`
  *  **`<`** (`int` , `int`) --->  `bool`
  * `int` **`<`** `float` --->  `bool`
  *  **`<`** (`int` , `float`) --->  `bool` 

#### Result: 
true if the left-hand operand is less than the right-hand operand, false otherwise.

#### Special cases:     
  * if one of the operands is nil, returns false    
  * if both operands are String, uses a lexicographic comparison of two strings 
  
```
bool var0 <- 'abc' < 'aeb'; 	// var0 equals true

``` 

    
  * if both operands are points, returns true if and only if the left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one. 
  
```
bool var1 <- {5,7} < {4,6}; 	// var1 equals false
bool var2 <- {5,7} < {4,8}; 	// var2 equals false

``` 



#### Examples: 
```
bool var3 <- 3.5 < 7.6; 	// var3 equals true
bool var4 <- 3.5 < 7; 	// var4 equals true
#now < #now minus_hours 1 :- false
bool var6 <- 3 < 7; 	// var6 equals true
bool var7 <- 3 < 2.5; 	// var7 equals false
```
      

#### See also: 
[>](OperatorsAC#>), [>=](OperatorsAC#>=), [<=](OperatorsAC#<=), [=](OperatorsAC#=), [!=](OperatorsAC#!=), 
    	
----

[//]: # (keyword|operator_<=)
### `<=`

#### Possible use: 
  * `float` **`<=`** `int` --->  `bool`
  *  **`<=`** (`float` , `int`) --->  `bool`
  * `int` **`<=`** `int` --->  `bool`
  *  **`<=`** (`int` , `int`) --->  `bool`
  * `int` **`<=`** `float` --->  `bool`
  *  **`<=`** (`int` , `float`) --->  `bool`
  * `point` **`<=`** `point` --->  `bool`
  *  **`<=`** (`point` , `point`) --->  `bool`
  * `date` **`<=`** `date` --->  `bool`
  *  **`<=`** (`date` , `date`) --->  `bool`
  * `float` **`<=`** `float` --->  `bool`
  *  **`<=`** (`float` , `float`) --->  `bool`
  * `string` **`<=`** `string` --->  `bool`
  *  **`<=`** (`string` , `string`) --->  `bool` 

#### Result: 
true if the left-hand operand is less or equal than the right-hand operand, false otherwise.

#### Special cases:     
  * if one of the operands is nil, returns false    
  * if both operands are points, returns true if and only if the left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one. 
  
```
bool var5 <- {5,7} <= {4,6}; 	// var5 equals false
bool var6 <- {5,7} <= {4,8}; 	// var6 equals false

``` 

    
  * if both operands are String, uses a lexicographic comparison of two strings 
  
```
bool var7 <- 'abc' <= 'aeb'; 	// var7 equals true

``` 



#### Examples: 
```
bool var0 <- 7.0 <= 7; 	// var0 equals true
bool var1 <- 3 <= 7; 	// var1 equals true
bool var2 <- 3 <= 2.5; 	// var2 equals false
#now <= #now minus_hours 1 :- false
bool var4 <- 3.5 <= 3.5; 	// var4 equals true
```
      

#### See also: 
[>](OperatorsAC#>), [<](OperatorsAC#<), [>=](OperatorsAC#>=), [=](OperatorsAC#=), [!=](OperatorsAC#!=), 
    	
----

[//]: # (keyword|operator_<>)
### `<>`
Same signification as [!=](OperatorsAC#!=)
    	
----

[//]: # (keyword|operator_=)
### `=`

#### Possible use: 
  * `unknown` **`=`** `unknown` --->  `bool`
  *  **`=`** (`unknown` , `unknown`) --->  `bool`
  * `int` **`=`** `int` --->  `bool`
  *  **`=`** (`int` , `int`) --->  `bool`
  * `float` **`=`** `float` --->  `bool`
  *  **`=`** (`float` , `float`) --->  `bool`
  * `float` **`=`** `int` --->  `bool`
  *  **`=`** (`float` , `int`) --->  `bool`
  * `date` **`=`** `date` --->  `bool`
  *  **`=`** (`date` , `date`) --->  `bool`
  * `int` **`=`** `float` --->  `bool`
  *  **`=`** (`int` , `float`) --->  `bool` 

#### Result: 
returns true if both operands are equal, false otherwise
returns true if both operands are equal, false otherwise

#### Special cases:     
  * if both operands are any kind of objects, returns true if they are identical (i.e., the same object) or equal (comparisons between nil values are permitted) 
  
```
bool var0 <- [2,3] = [2,3]; 	// var0 equals true

``` 



#### Examples: 
```
bool var1 <- 4 = 5; 	// var1 equals false
bool var2 <- 4.5 = 4.7; 	// var2 equals false
bool var3 <- 4.7 = 4; 	// var3 equals false
#now = #now minus_hours 1 :- false
bool var5 <- 3 = 3.0; 	// var5 equals true
bool var6 <- 4 = 4.7; 	// var6 equals false
```
      

#### See also: 
[!=](OperatorsAC#!=), [>](OperatorsAC#>), [<](OperatorsAC#<), [>=](OperatorsAC#>=), [<=](OperatorsAC#<=), 
    	
----

[//]: # (keyword|operator_>)
### `>`

#### Possible use: 
  * `string` **`>`** `string` --->  `bool`
  *  **`>`** (`string` , `string`) --->  `bool`
  * `int` **`>`** `float` --->  `bool`
  *  **`>`** (`int` , `float`) --->  `bool`
  * `float` **`>`** `float` --->  `bool`
  *  **`>`** (`float` , `float`) --->  `bool`
  * `point` **`>`** `point` --->  `bool`
  *  **`>`** (`point` , `point`) --->  `bool`
  * `float` **`>`** `int` --->  `bool`
  *  **`>`** (`float` , `int`) --->  `bool`
  * `int` **`>`** `int` --->  `bool`
  *  **`>`** (`int` , `int`) --->  `bool`
  * `date` **`>`** `date` --->  `bool`
  *  **`>`** (`date` , `date`) --->  `bool` 

#### Result: 
true if the left-hand operand is greater than the right-hand operand, false otherwise.

#### Special cases:     
  * if one of the operands is nil, returns false    
  * if both operands are String, uses a lexicographic comparison of two strings 
  
```
bool var0 <- 'abc' > 'aeb'; 	// var0 equals false

``` 

    
  * if both operands are points, returns true if and only if the left component (x) of the left operand if greater than x of the right one and if the right component (y) of the left operand is greater than y of the right one. 
  
```
bool var1 <- {5,7} > {4,6}; 	// var1 equals true
bool var2 <- {5,7} > {4,8}; 	// var2 equals false

``` 



#### Examples: 
```
bool var3 <- 3 > 2.5; 	// var3 equals true
bool var4 <- 3.5 > 7.6; 	// var4 equals false
bool var5 <- 3.5 > 7; 	// var5 equals false
bool var6 <- 3 > 7; 	// var6 equals false
#now > #now minus_hours 1 :- true
```
      

#### See also: 
[<](OperatorsAC#<), [>=](OperatorsAC#>=), [<=](OperatorsAC#<=), [=](OperatorsAC#=), [!=](OperatorsAC#!=), 
    	
----

[//]: # (keyword|operator_>=)
### `>=`

#### Possible use: 
  * `int` **`>=`** `int` --->  `bool`
  *  **`>=`** (`int` , `int`) --->  `bool`
  * `float` **`>=`** `float` --->  `bool`
  *  **`>=`** (`float` , `float`) --->  `bool`
  * `date` **`>=`** `date` --->  `bool`
  *  **`>=`** (`date` , `date`) --->  `bool`
  * `string` **`>=`** `string` --->  `bool`
  *  **`>=`** (`string` , `string`) --->  `bool`
  * `int` **`>=`** `float` --->  `bool`
  *  **`>=`** (`int` , `float`) --->  `bool`
  * `point` **`>=`** `point` --->  `bool`
  *  **`>=`** (`point` , `point`) --->  `bool`
  * `float` **`>=`** `int` --->  `bool`
  *  **`>=`** (`float` , `int`) --->  `bool` 

#### Result: 
true if the left-hand operand is greater or equal than the right-hand operand, false otherwise.

#### Special cases:     
  * if one of the operands is nil, returns false    
  * if both operands are string, uses a lexicographic comparison of the two strings 
  
```
bool var0 <- 'abc' >= 'aeb'; 	// var0 equals false
bool var1 <- 'abc' >= 'abc'; 	// var1 equals true

``` 

    
  * if both operands are points, returns true if and only if the left component (x) of the left operand if greater or equal than x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one. 
  
```
bool var2 <- {5,7} >= {4,6}; 	// var2 equals true
bool var3 <- {5,7} >= {4,8}; 	// var3 equals false

``` 



#### Examples: 
```
bool var4 <- 3 >= 7; 	// var4 equals false
bool var5 <- 3.5 >= 3.5; 	// var5 equals true
#now >= #now minus_hours 1 :- true
bool var7 <- 3 >= 2.5; 	// var7 equals true
bool var8 <- 3.5 >= 7; 	// var8 equals false
```
      

#### See also: 
[>](OperatorsAC#>), [<](OperatorsAC#<), [<=](OperatorsAC#<=), [=](OperatorsAC#=), [!=](OperatorsAC#!=), 
    	
----

[//]: # (keyword|operator_accumulate)
### `accumulate`

#### Possible use: 
  * `container` **`accumulate`** `any expression` --->  `container`
  *  **`accumulate`** (`container` , `any expression`) --->  `container` 

#### Result: 
returns a new flat list, in which each element is the evaluation of the right-hand operand. If this evaluation returns a list, the elements of this result are added directly to the list returned  

#### Comment: 
accumulate is dedicated to the application of a same computation on each element of a container (and returns a list). In the right-hand operand, the keyword each can be used to represent, in turn, each of the left-hand operand elements.

#### Examples: 
```
container var0 <- [a1,a2,a3] accumulate (each neighbors_at 10); 	// var0 equals a flat list of all the neighbors of these three agents
list<int> var1 <- [1,2,4] accumulate ([2,4]); 	// var1 equals [2,4,2,4,2,4]
list<int> var2 <- [1,2,4] accumulate (each * 2); 	// var2 equals [2,4,8]
```
      

#### See also: 
[collect](OperatorsAC#collect), 
    	
----

[//]: # (keyword|operator_action)
### `action`

#### Possible use: 
  *  **`action`** (`any`) --->  `action` 

#### Result: 
Casts the operand into the type action
    	
----

[//]: # (keyword|operator_add_days)
### `add_days`
Same signification as [plus_days](OperatorsNZ#plus_days)
    	
----

[//]: # (keyword|operator_add_hours)
### `add_hours`
Same signification as [plus_hours](OperatorsNZ#plus_hours)
    	
----

[//]: # (keyword|operator_add_minutes)
### `add_minutes`
Same signification as [plus_minutes](OperatorsNZ#plus_minutes)
    	
----

[//]: # (keyword|operator_add_months)
### `add_months`
Same signification as [plus_months](OperatorsNZ#plus_months)
    	
----

[//]: # (keyword|operator_add_ms)
### `add_ms`
Same signification as [plus_ms](OperatorsNZ#plus_ms)
    	
----

[//]: # (keyword|operator_add_seconds)
### `add_seconds`
Same signification as [+](OperatorsAC#+)
    	
----

[//]: # (keyword|operator_add_weeks)
### `add_weeks`
Same signification as [plus_weeks](OperatorsNZ#plus_weeks)
    	
----

[//]: # (keyword|operator_add_years)
### `add_years`
Same signification as [plus_years](OperatorsNZ#plus_years)
    	
----

[//]: # (keyword|operator_after)
### `after`

#### Possible use: 
  *  **`after`** (`date`) --->  `bool`
  * `any expression` **`after`** `date` --->  `bool`
  *  **`after`** (`any expression` , `date`) --->  `bool` 

#### Result: 
Returns true if the current_date of the model is strictly after the date passed in argument. Synonym of 'current_date > argument'. Can be used in its composed form with 2 arguments to express the lower boundary for the computation of a frequency. Note that only dates strictly after this one will be tested against the frequency

#### Examples: 
```
reflex when: after(starting_date) {} -: will always be run after the first step
reflex when: false after(starting date + #10days) {} -: will not be run after this date. Better to use 'until' or 'before' in that case
every(2#days) after (starting_date + 1#day) // the computation will return true every two days (using the starting_date of the model as the starting point) only for the dates strictly after this starting_date + 1#day
```
  
    	
----

[//]: # (keyword|operator_agent)
### `agent`

#### Possible use: 
  *  **`agent`** (`any`) --->  `agent` 

#### Result: 
Casts the operand into the type agent
    	
----

[//]: # (keyword|operator_among)
### `among`

#### Possible use: 
  * `int` **`among`** `container` --->  `container`
  *  **`among`** (`int` , `container`) --->  `container` 

#### Result: 
Returns a list of length the value of the left-hand operand, containing random elements from the right-hand operand. As of GAMA 1.6, the order in which the elements are returned can be different than the order in which they appear in the right-hand container

#### Special cases:     
  * if the right-hand operand is empty, among returns a new empty list. If it is nil, it throws an error.    
  * if the left-hand operand is greater than the length of the right-hand operand, among returns the right-hand operand (converted as a list). If it is smaller or equal to zero, it returns an empty list

#### Examples: 
```
list<int> var0 <- 3 among [1,2,4,3,5,7,6,8]; 	// var0 equals [1,2,8] (for example)
container var1 <- 3 among g2; 	// var1 equals [node6,node11,node7]
container var2 <- 3 among list(node); 	// var2 equals [node1,node11,node4]
list<int> var3 <- 1 among [1::2,3::4]; 	// var3 equals 2 or 4
```
  
    	
----

[//]: # (keyword|operator_and)
### `and`

#### Possible use: 
  * `bool` **`and`** `any expression` --->  `bool`
  *  **`and`** (`bool` , `any expression`) --->  `bool` 

#### Result: 
a bool value, equal to the logical and between the left-hand operand and the right-hand operand.  

#### Comment: 
both operands are always casted to bool before applying the operator. Thus, an expression like (1 and 0) is accepted and returns false.    

#### See also: 
[bool](OperatorsAC#bool), [or](OperatorsNZ#or), [!](OperatorsAC#!), 
    	
----

[//]: # (keyword|operator_any)
### `any`
Same signification as [one_of](OperatorsNZ#one_of)
    	
----

[//]: # (keyword|operator_append_horizontally)
### `append_horizontally`

#### Possible use: 
  * `matrix` **`append_horizontally`** `matrix` --->  `matrix`
  *  **`append_horizontally`** (`matrix` , `matrix`) --->  `matrix` 

#### Result: 
A matrix resulting from the concatenation of the rows of the two given matrices. If not both numerical or both object matrices, returns the first matrix.

#### Examples: 
```
matrix var0 <- matrix([[1.0,2.0],[3.0,4.0]]) append_horizontally matrix([[1,2],[3,4]]); 	// var0 equals matrix([[1.0,2.0],[3.0,4.0],[1.0,2.0],[3.0,4.0]])
```
  
    	
----

[//]: # (keyword|operator_append_vertically)
### `append_vertically`

#### Possible use: 
  * `matrix` **`append_vertically`** `matrix` --->  `matrix`
  *  **`append_vertically`** (`matrix` , `matrix`) --->  `matrix` 

#### Result: 
A matrix resulting from the concatenation of the columns  of the two given matrices. If not both numerical or both object matrices, returns the first matrix.

#### Examples: 
```
matrix var0 <- matrix([[1,2],[3,4]]) append_vertically matrix([[1,2],[3,4]]); 	// var0 equals matrix([[1,2,1,2],[3,4,3,4]])
```
  
    	
----

[//]: # (keyword|operator_as)
### `as`

#### Possible use: 
  * `unknown` **`as`** `msi.gaml.types.IType` --->  `unknown`
  *  **`as`** (`unknown` , `msi.gaml.types.IType`) --->  `unknown` 

#### Result: 
casting of the first argument into a given type  

#### Comment: 
It is equivalent to the application of the type operator on the left operand.

#### Examples: 
```
int var0 <- 3.5 as int; 	// var0 equals int(3.5)
```
  
    	
----

[//]: # (keyword|operator_as_int)
### `as_int`

#### Possible use: 
  * `string` **`as_int`** `int` --->  `int`
  *  **`as_int`** (`string` , `int`) --->  `int` 

#### Result: 
parses the string argument as a signed integer in the radix specified by the second argument.

#### Special cases:     
  * if the left operand is nil or empty, as_int returns 0    
  * if the left operand does not represent an integer in the specified radix, as_int throws an exception 

#### Examples: 
```
int var0 <- '20' as_int 10; 	// var0 equals 20
int var1 <- '20' as_int 8; 	// var1 equals 16
int var2 <- '20' as_int 16; 	// var2 equals 32
int var3 <- '1F' as_int 16; 	// var3 equals 31
int var4 <- 'hello' as_int 32; 	// var4 equals 18306744
```
      

#### See also: 
[int](OperatorsDM#int), 
    	
----

[//]: # (keyword|operator_as_map)
### `as_map`

#### Possible use: 
  * `container` **`as_map`** `any expression` --->  `map`
  *  **`as_map`** (`container` , `any expression`) --->  `map` 

#### Result: 
produces a new map from the evaluation of the right-hand operand for each element of the left-hand operand  

#### Comment: 
the right-hand operand should be a pair

#### Special cases:     
  * if the left-hand operand is nil, as_map throws an error.

#### Examples: 
```
map<int,int> var0 <- [1,2,3,4,5,6,7,8] as_map (each::(each * 2)); 	// var0 equals [1::2, 2::4, 3::6, 4::8, 5::10, 6::12, 7::14, 8::16]
map<int,int> var1 <- [1::2,3::4,5::6] as_map (each::(each * 2)); 	// var1 equals [2::4, 4::8, 6::12] 
```
  
    	
----

[//]: # (keyword|operator_as_matrix)
### `as_matrix`

#### Possible use: 
  * `unknown` **`as_matrix`** `point` --->  `matrix`
  *  **`as_matrix`** (`unknown` , `point`) --->  `matrix` 

#### Result: 
casts the left operand into a matrix with right operand as preferred size  

#### Comment: 
This operator is very useful to cast a file containing raster data into a matrix.Note that both components of the right operand point should be positive, otherwise an exception is raised.The operator as_matrix creates a matrix of preferred size. It fills in it with elements of the left operand until the matrix is full If the size is to short, some elements will be omitted. Matrix remaining elements will be filled in by nil.

#### Special cases:     
  * if the right operand is nil, as_matrix is equivalent to the matrix operator    

#### See also: 
[matrix](OperatorsDM#matrix), 
    	
----

[//]: # (keyword|operator_at)
### `at`

#### Possible use: 
  * `container<KeyType,ValueType>` **`at`** `KeyType` --->  `ValueType`
  *  **`at`** (`container<KeyType,ValueType>` , `KeyType`) --->  `ValueType`
  * `string` **`at`** `int` --->  `string`
  *  **`at`** (`string` , `int`) --->  `string` 

#### Result: 
the element at the right operand index of the container  

#### Comment: 
The first element of the container is located at the index 0. In addition, if the user tries to get the element at an index higher or equals than the length of the container, he will get an IndexOutOfBoundException.The at operator behavior depends on the nature of the operand

#### Special cases:     
  * if it is a file, at returns the element of the file content at the index specified by the right operand    
  * if it is a population, at returns the agent at the index specified by the right operand    
  * if it is a graph and if the right operand is a node, at returns the in and out edges corresponding to that node    
  * if it is a graph and if the right operand is an edge, at returns the pair node_out::node_in of the edge    
  * if it is a graph and if the right operand is a pair node1::node2, at returns the edge from node1 to node2 in the graph    
  * if it is a list or a matrix, at returns the element at the index specified by the right operand 
  
```
int var0 <- [1, 2, 3] at 2; 	// var0 equals 3
point var1 <- [{1,2}, {3,4}, {5,6}] at 0; 	// var1 equals {1.0,2.0}

``` 



#### Examples: 
```
string var2 <- 'abcdef' at 0; 	// var2 equals 'a'
```
      

#### See also: 
[contains_all](OperatorsAC#contains_all), [contains_any](OperatorsAC#contains_any), 
    	
----

[//]: # (keyword|operator_attributes)
### `attributes`

#### Possible use: 
  *  **`attributes`** (`any`) --->  `attributes` 

#### Result: 
Casts the operand into the type attributes
    	
----

[//]: # (keyword|operator_before)
### `before`

#### Possible use: 
  *  **`before`** (`date`) --->  `bool`
  * `any expression` **`before`** `date` --->  `bool`
  *  **`before`** (`any expression` , `date`) --->  `bool` 

#### Result: 
Returns true if the current_date of the model is strictly before the date passed in argument. Synonym of 'current_date < argument'

#### Examples: 
```
reflex when: before(starting_date) {} -: will never be run
```
  
    	
----

[//]: # (keyword|operator_between)
### `between`

#### Possible use: 
  * `date` **`between`** `date` --->  `bool`
  *  **`between`** (`date` , `date`) --->  `bool`
  *  **`between`** (`date`, `date`, `date`) --->  `bool`
  *  **`between`** (`any expression`, `date`, `date`) --->  `bool`
  *  **`between`** (`float`, `float`, `float`) --->  `bool`
  *  **`between`** (`int`, `int`, `int`) --->  `bool` 

#### Result: 
returns true if the first float operand is bigger than the second float operand and smaller than the third float operand
returns true the first integer operand is bigger than the second integer operand and smaller than the third integer operand

#### Special cases:     
  * returns true if the first operand is between the two dates passed in arguments (both exclusive). Can be combined with 'every' to express a frequency between two dates 
  
```
(date('2016-01-01') between(date('2000-01-01'), date('2020-02-02') -: true
every #day between(date('2000-01-01'), date('2020-02-02') // will return true every new day between these two dates, taking the first one as the starting point

``` 

    
  * returns true if the first operand is between the two dates passed in arguments (both exclusive). The version with 2 arguments compares the current_date with the 2 others 
  
```
(date('2016-01-01') between(date('2000-01-01'), date('2020-02-02') -: true
between(date('2000-01-01'), date('2020-02-02') // will return true if the current_date of the model is in_between the 2

``` 



#### Examples: 
```
bool var0 <- between(5.0, 1.0, 10.0); 	// var0 equals true
bool var1 <- between(5, 1, 10); 	// var1 equals true
```
  
    	
----

[//]: # (keyword|operator_binomial)
### `binomial`

#### Possible use: 
  * `int` **`binomial`** `float` --->  `int`
  *  **`binomial`** (`int` , `float`) --->  `int` 

#### Result: 
A value from a random variable following a binomial distribution. The operands represent the number of experiments n and the success probability p.  

#### Comment: 
The binomial distribution is the discrete probability distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields success with probability p, cf. Binomial distribution on Wikipedia.

#### Examples: 
```
int var0 <- binomial(15,0.6); 	// var0 equals a random positive integer
```
      

#### See also: 
[poisson](OperatorsNZ#poisson), [gauss](OperatorsDM#gauss), 
    	
----

[//]: # (keyword|operator_blend)
### `blend`

#### Possible use: 
  * `rgb` **`blend`** `rgb` --->  `rgb`
  *  **`blend`** (`rgb` , `rgb`) --->  `rgb`
  *  **`blend`** (`rgb`, `rgb`, `float`) --->  `rgb` 

#### Result: 
Blend two colors with an optional ratio (c1 `*` r + c2 `*` (1 - r)) between 0 and 1

#### Special cases:     
  * If the ratio is omitted, an even blend is done 
  
```
rgb var1 <- blend(#red, #blue); 	// var1 equals to a color very close to the purple

``` 



#### Examples: 
```
rgb var3 <- blend(#red, #blue, 0.3); 	// var3 equals to a color between the purple and the blue
```
      

#### See also: 
[rgb](OperatorsNZ#rgb), [hsb](OperatorsDM#hsb), 
    	
----

[//]: # (keyword|operator_bool)
### `bool`

#### Possible use: 
  *  **`bool`** (`any`) --->  `bool` 

#### Result: 
Casts the operand into the type bool
    	
----

[//]: # (keyword|operator_brewer_colors)
### `brewer_colors`

#### Possible use: 
  *  **`brewer_colors`** (`string`) --->  `list<rgb>`
  * `string` **`brewer_colors`** `int` --->  `list<rgb>`
  *  **`brewer_colors`** (`string` , `int`) --->  `list<rgb>` 

#### Result: 
Build a list of colors of a given type (see website http://colorbrewer2.org/)
Build a list of colors of a given type (see website http://colorbrewer2.org/) with a given number of classes

#### Examples: 
```
list<rgb> var0 <- list<rgb> colors <- brewer_colors("OrRd");; 	// var0 equals a list of 6 blue colors
list<rgb> var1 <- list<rgb> colors <- brewer_colors("Pastel1", 10);; 	// var1 equals a list of 10 sequential colors
```
      

#### See also: 
[brewer_palettes](OperatorsAC#brewer_palettes), 
    	
----

[//]: # (keyword|operator_brewer_palettes)
### `brewer_palettes`

#### Possible use: 
  *  **`brewer_palettes`** (`int`) --->  `list<string>`
  * `int` **`brewer_palettes`** `int` --->  `list<string>`
  *  **`brewer_palettes`** (`int` , `int`) --->  `list<string>` 

#### Result: 
returns the list a palette with a given min number of classes and max number of classes)
returns the list a palette with a given min number of classes and max number of classes)

#### Examples: 
```
list<string> var0 <- list<rgb> colors <- brewer_palettes();; 	// var0 equals a list of palettes that are composed of a min of 5 colors
list<string> var1 <- list<rgb> colors <- brewer_palettes(5,10);; 	// var1 equals a list of palettes that are composed of a min of 5 colors and a max of 10 colors
```
      

#### See also: 
[brewer_colors](OperatorsAC#brewer_colors), 
    	
----

[//]: # (keyword|operator_build)
### `build`

#### Possible use: 
  *  **`build`** (`matrix<float>`) --->  `regression`
  * `matrix<float>` **`build`** `string` --->  `regression`
  *  **`build`** (`matrix<float>` , `string`) --->  `regression` 

#### Result: 
returns the regression build from the matrix data (a row = an instance, the last value of each line is the y value) while using the given ordinary least squares method. Usage: build(data)
returns the regression build from the matrix data (a row = an instance, the last value of each line is the y value) while using the given method ("GLS" or "OLS"). Usage: build(data,method)

#### Examples: 
```
matrix([[1,2,3,4],[2,3,4,2]])
build(matrix([[1,2,3,4],[2,3,4,2]]),"GLS")
```
  
    	
----

[//]: # (keyword|operator_char)
### `char`

#### Possible use: 
  *  **`char`** (`int`) --->  `string`

#### Special cases:     
  * converts ACSII integer value to character 
  
```
string var0 <- char (34); 	// var0 equals '"'

``` 


    	
----

[//]: # (keyword|operator_collect)
### `collect`

#### Possible use: 
  * `container` **`collect`** `any expression` --->  `container`
  *  **`collect`** (`container` , `any expression`) --->  `container` 

#### Result: 
returns a new list, in which each element is the evaluation of the right-hand operand.  

#### Comment: 
collect is similar to accumulate except that accumulate always produces flat lists if the right-hand operand returns a list.In addition, collect can be applied to any container.

#### Special cases:     
  * if the left-hand operand is nil, collect throws an error

#### Examples: 
```
container var0 <- [1,2,4] collect (each *2); 	// var0 equals [2,4,8]
container var1 <- [1,2,4] collect ([2,4]); 	// var1 equals [[2,4],[2,4],[2,4]]
container var2 <- [1::2, 3::4, 5::6] collect (each + 2); 	// var2 equals [4,6,8]
container var3 <- (list(node) collect (node(each).location.x * 2); 	// var3 equals the list of nodes with their x multiplied by 2
```
      

#### See also: 
[accumulate](OperatorsAC#accumulate), 
    	
----

[//]: # (keyword|operator_column_at)
### `column_at`

#### Possible use: 
  * `matrix` **`column_at`** `int` --->  `list`
  *  **`column_at`** (`matrix` , `int`) --->  `list` 

#### Result: 
returns the column at a num_col (right-hand operand)

#### Examples: 
```
list var0 <- matrix([["el11","el12","el13"],["el21","el22","el23"],["el31","el32","el33"]]) column_at 2; 	// var0 equals ["el31","el32","el33"]
```
      

#### See also: 
[row_at](OperatorsNZ#row_at), [rows_list](OperatorsNZ#rows_list), 
    	
----

[//]: # (keyword|operator_columns_list)
### `columns_list`

#### Possible use: 
  *  **`columns_list`** (`matrix`) --->  `list<list>` 

#### Result: 
returns a list of the columns of the matrix, with each column as a list of elements

#### Examples: 
```
list<list> var0 <- columns_list(matrix([["el11","el12","el13"],["el21","el22","el23"],["el31","el32","el33"]])); 	// var0 equals [["el11","el12","el13"],["el21","el22","el23"],["el31","el32","el33"]]
```
      

#### See also: 
[rows_list](OperatorsNZ#rows_list), 
    	
----

[//]: # (keyword|operator_command)
### `command`

#### Possible use: 
  *  **`command`** (`string`) --->  `string`
  * `string` **`command`** `string` --->  `string`
  *  **`command`** (`string` , `string`) --->  `string`
  *  **`command`** (`string`, `string`, `msi.gama.util.GamaMap<java.lang.String,java.lang.String>`) --->  `string` 

#### Result: 
command allows GAMA to issue a system command using the system terminal or shell and to receive a string containing the outcome of the command or script executed. By default, commands are blocking the agent calling them, unless the sequence ' &' is used at the end. In this case, the result of the operator is an empty string. The basic form with only one string in argument uses the directory of the model and does not set any environment variables. Two other forms (with a directory and a map<string, string> of environment variables) are available.
command allows GAMA to issue a system command using the system terminal or shell and to receive a string containing the outcome of the command or script executed. By default, commands are blocking the agent calling them, unless the sequence ' &' is used at the end. In this case, the result of the operator is an empty string
command allows GAMA to issue a system command using the system terminal or shell and to receive a string containing the outcome of the command or script executed. By default, commands are blocking the agent calling them, unless the sequence ' &' is used at the end. In this case, the result of the operator is an empty string. The basic form with only one string in argument uses the directory of the model and does not set any environment variables. Two other forms (with a directory and a map<string, string> of environment variables) are available.
    	
----

[//]: # (keyword|operator_contains)
### `contains`

#### Possible use: 
  * `container<KeyType,ValueType>` **`contains`** `unknown` --->  `bool`
  *  **`contains`** (`container<KeyType,ValueType>` , `unknown`) --->  `bool`
  * `string` **`contains`** `string` --->  `bool`
  *  **`contains`** (`string` , `string`) --->  `bool` 

#### Result: 
true, if the container contains the right operand, false otherwise  

#### Comment: 
the contains operator behavior depends on the nature of the operand

#### Special cases:     
  * if it is a map, contains returns true if the operand is a key of the map    
  * if it is a file, contains returns true it the operand is contained in the file content    
  * if it is a population, contains returns true if the operand is an agent of the population, false otherwise    
  * if it is a graph, contains returns true if the operand is a node or an edge of the graph, false otherwise    
  * if both operands are strings, returns true if the right-hand operand contains the right-hand pattern;    
  * if it is a list or a matrix, contains returns true if the list or matrix contains the right operand 
  
```
bool var0 <- [1, 2, 3] contains 2; 	// var0 equals true
bool var1 <- [{1,2}, {3,4}, {5,6}] contains {3,4}; 	// var1 equals true

``` 



#### Examples: 
```
bool var2 <- 'abcded' contains 'bc'; 	// var2 equals true
```
      

#### See also: 
[contains_all](OperatorsAC#contains_all), [contains_any](OperatorsAC#contains_any), 
    	
----

[//]: # (keyword|operator_contains_all)
### `contains_all`

#### Possible use: 
  * `string` **`contains_all`** `list` --->  `bool`
  *  **`contains_all`** (`string` , `list`) --->  `bool`
  * `container` **`contains_all`** `container` --->  `bool`
  *  **`contains_all`** (`container` , `container`) --->  `bool` 

#### Result: 
true if the left operand contains all the elements of the right operand, false otherwise  

#### Comment: 
the definition of contains depends on the container

#### Special cases:     
  * if the right operand is nil or empty, contains_all returns true    
  * if the left-operand is a string, test whether the string contains all the element of the list; 
  
```
bool var0 <- "abcabcabc" contains_all ["ca","xy"]; 	// var0 equals false

``` 



#### Examples: 
```
bool var1 <- [1,2,3,4,5,6] contains_all [2,4]; 	// var1 equals true 
bool var2 <- [1,2,3,4,5,6] contains_all [2,8]; 	// var2 equals false
bool var3 <- [1::2, 3::4, 5::6] contains_all [1,3]; 	// var3 equals false 
bool var4 <- [1::2, 3::4, 5::6] contains_all [2,4]; 	// var4 equals true
```
      

#### See also: 
[contains](OperatorsAC#contains), [contains_any](OperatorsAC#contains_any), 
    	
----

[//]: # (keyword|operator_contains_any)
### `contains_any`

#### Possible use: 
  * `container` **`contains_any`** `container` --->  `bool`
  *  **`contains_any`** (`container` , `container`) --->  `bool`
  * `string` **`contains_any`** `list` --->  `bool`
  *  **`contains_any`** (`string` , `list`) --->  `bool` 

#### Result: 
true if the left operand contains one of the elements of the right operand, false otherwise  

#### Comment: 
the definition of contains depends on the container

#### Special cases:     
  * if the right operand is nil or empty, contains_any returns false

#### Examples: 
```
bool var0 <- [1,2,3,4,5,6] contains_any [2,4]; 	// var0 equals true 
bool var1 <- [1,2,3,4,5,6] contains_any [2,8]; 	// var1 equals true
bool var2 <- [1::2, 3::4, 5::6] contains_any [1,3]; 	// var2 equals false
bool var3 <- [1::2, 3::4, 5::6] contains_any [2,4]; 	// var3 equals true
bool var4 <- "abcabcabc" contains_any ["ca","xy"]; 	// var4 equals true
```
      

#### See also: 
[contains](OperatorsAC#contains), [contains_all](OperatorsAC#contains_all), 
    	
----

[//]: # (keyword|operator_copy)
### `copy`

#### Possible use: 
  *  **`copy`** (`unknown`) --->  `unknown` 

#### Result: 
returns a copy of the operand.
    	
----

[//]: # (keyword|operator_copy_between)
### `copy_between`

#### Possible use: 
  *  **`copy_between`** (`container`, `int`, `int`) --->  `container`
  *  **`copy_between`** (`string`, `int`, `int`) --->  `string` 

#### Result: 
Returns a copy of the first operand between the indexes determined by the second (inclusive) and third operands (exclusive)

#### Special cases:     
  * If the first operand is empty, returns an empty object of the same type    
  * If the second operand is greater than or equal to the third operand, return an empty object of the same type    
  * If the first operand is nil, raises an error

#### Examples: 
```
container var0 <-  copy_between ([4, 1, 6, 9 ,7], 1, 3); 	// var0 equals [1, 6]
string var1 <- copy_between("abcabcabc", 2,6); 	// var1 equals "cabc"
```
  
    	
----

[//]: # (keyword|operator_corR)
### `corR`

#### Possible use: 
  * `container` **`corR`** `container` --->  `unknown`
  *  **`corR`** (`container` , `container`) --->  `unknown` 

#### Result: 
returns the Pearson correlation coefficient of two given vectors (right-hand operands) in given variable  (left-hand operand).

#### Special cases:     
  * if the lengths of two vectors in the right-hand aren't equal, returns 0

#### Examples: 
```
list X <- [1, 2, 3];
list Y <- [1, 2, 4];
unknown var2 <- corR(X, Y); 	// var2 equals 0.981980506061966
```
  
    	
----

[//]: # (keyword|operator_count)
### `count`

#### Possible use: 
  * `container` **`count`** `any expression` --->  `int`
  *  **`count`** (`container` , `any expression`) --->  `int` 

#### Result: 
returns an int, equal to the number of elements of the left-hand operand that make the right-hand operand evaluate to true.  

#### Comment: 
in the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.

#### Special cases:     
  * if the left-hand operand is nil, count throws an error

#### Examples: 
```
int var0 <- [1,2,3,4,5,6,7,8] count (each > 3); 	// var0 equals 5
// Number of nodes of graph g2 without any out edge
graph g2 <- graph([]);
int var3 <- g2 count (length(g2 out_edges_of each) = 0  ) ; 	// var3 equals the total number of out edges
// Number of agents node with x > 32
int n <- (list(node) count (round(node(each).location.x) > 32);
int var6 <- [1::2, 3::4, 5::6] count (each > 4); 	// var6 equals 1
```
      

#### See also: 
[group_by](OperatorsDM#group_by), 
    	
----

[//]: # (keyword|operator_create_map)
### `create_map`

#### Possible use: 
  * `container` **`create_map`** `container` --->  `map`
  *  **`create_map`** (`container` , `container`) --->  `map` 

#### Result: 
returns a new map using the left operand as keys for the right operand

#### Special cases:     
  * if the left operand contains duplicates, create_map throws an error.    
  * if both operands have different lengths, choose the minimum length between the two operandsfor the size of the map

#### Examples: 
```
map<int,string> var0 <- create_map([0,1,2],['a','b','c']); 	// var0 equals [0::'a',1::'b',2;;'c']
map<int,float> var1 <- create_map([0,1],[0.1,0.2,0.3]); 	// var1 equals [0::0.1,1::0.2]
map<string,float> var2 <- create_map(['a','b','c','d'],[1.0,2.0,3.0]); 	// var2 equals ['a'::1.0,'b'::2.0,'c'::3.0]
```
  
    	
----

[//]: # (keyword|operator_csv_file)
### `csv_file`

#### Possible use: 
  *  **`csv_file`** (`string`) --->  `file` 

#### Result: 
Constructs a file of type csv. Allowed extensions are limited to csv, tsv
    	
----

[//]: # (keyword|operator_R_correlation)
### `R_correlation`
Same signification as [corR](OperatorsAC#corR)
    	
----

[//]: # (keyword|operator_R_mean)
### `R_mean`
Same signification as [meanR](OperatorsDM#meanR)
    	
----

[//]: # (keyword|operator_TGauss)
### `TGauss`
Same signification as [truncated_gauss](OperatorsNZ#truncated_gauss)
    	
----

[//]: # (keyword|operator_URL_file)
### `URL_file`

#### Possible use: 
  *  **`URL_file`** (`string`) --->  `file` 

#### Result: 
Constructs a file of type URL. Allowed extensions are limited to url
=======
#Operators (A to C)
 	
----

**This file is automatically generated from java files. Do Not Edit It.**

----

## Definition 

Operators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function. 

Most of them use a classical prefixed functional syntax (i.e. `operator_name(operand1, operand2, operand3)`, see below), with the exception of arithmetic (e.g. `+`, `/`), logical (`and`, `or`), comparison (e.g. `>`, `<`), access (`.`, `[..]`) and pair (`::`) operators, which require an infixed notation (i.e. `operand1 operator_symbol operand1`). 

The ternary functional if-else operator, `? :`, uses a special infixed syntax composed with two symbols (e.g. `operand1 ? operand2 : operand3`). Two unary operators (`-` and `!`) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g. ` - 10`, `! (operand1 or operand2)`). 

Finally, special constructor operators (`{...}` for constructing points, `[...]` for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. `{1,2,3}`, `[operand1, operand2, ..., operandn]` or `[key1::value1, key2::value2... keyn::valuen]`).

With the exception of these special cases above, the following rules apply to the syntax of operators:
* if they only have one operand, the functional prefixed syntax is mandatory (e.g. `operator_name(operand1)`)
* if they have two arguments, either the functional prefixed syntax (e.g. `operator_name(operand1, operand2)`) or the infixed syntax (e.g. `operand1 operator_name operand2`) can be used.
* if they have more than two arguments, either the functional prefixed syntax (e.g. `operator_name(operand1, operand2, ..., operand)`) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. `operand1 operator_name(operand2, ..., operand)`) can be used.

All of these alternative syntaxes are completely equivalent.

Operators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the `shuffle` operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.

<br/>
----

## Priority between operators

The priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first.

GAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely:
* the constructor operators, like `::`, used to compose pairs of operands, have the lowest priority of all operators (e.g. `a > b :: b > c` will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, `[a > 10, b > 5]` will return a list of boolean values.
* it is followed by the `?:` operator, the functional if-else (e.g. ` a > b ? a + 10 : a - 10` will return the result of the if-else).
* next are the logical operators, `and` and `or` (e.g. `a > b or b > c` will return the value of the test)
* next are the comparison operators (i.e. `>`, `<`, `<=`, `>=`, `=`, `!=`)
* next the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)
* next the unary operators `-` and `!`
* next the access operators `.` and `[]` (e.g. `{1,2,3}.x > 20 + {4,5,6}.y` will return the result of the comparison between the x and y ordinates of the two points)
* and finally the functional operators, which have the highest priority of all.

----

## Using actions as operators

Actions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand.

For instance, if the following species is defined:

```
species spec1 {
        int min(int x, int y) {
                return x > y ? x : y;
        }
}
```

Any agent instance of spec1 can use `min` as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:

```
global {
        init {
                create spec1;
                spec1 my_agent <- spec1[0];
                int the_min <- my_agent min(10,20); // or min(my_agent, 10, 20);
        }
}
```

If the action doesn't have any operands, the syntax to use is `my_agent the_action()`. Finally, if it does not return a value, it might still be used but is considering as returning a value of type `unknown` (e.g. `unknown result <- my_agent the_action(op1, op2);`).

Note that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).

	

----

## Table of Contents

----

## Operators by categories
	

----

### Types-related operators

	
----

## Operators
	
>>>>>>> 6d5ac2b29e0fe2ee0379e7f09c6dffd05787945c
