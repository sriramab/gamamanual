<html><!-- Online page at https://github.com/gama-platform/gama/wiki/References/ModelLibrary/Features/Multi-Level Usage/Multi-Level Usage Balls, Groups and Clouds --><head><meta charset="utf-8"><title>Multi Level Usage Balls, Groups and Clouds</title><script src="../../../../../dash_resources/highlight.all.js"></script><link rel="stylesheet" type="text/css" href="../../../../../dash_resources/github-markdown.css"><link rel="stylesheet" type="text/css" href="../../../../../dash_resources/highlightjs.github.css"></head><body class="markdown-body" style="padding-bottom:20px; margin: 8px 13px;"><h1 id="multi-level-usage-balls-groups-and-clouds">Multi Level Usage Balls, Groups and Clouds</h1>
<h1 id="balls-groups-and-clouds-multilevel-architecture">Balls, Groups and Clouds Multilevel Architecture</h1>
<p>_Author : _</p>
<p>This model shows how to use multi-level architecture to group agents, and regroup groups. The operators capture is used to capture an agent by a group and change its species as a species contained by the group and defined in the group species section. The operator release is used to release contained agents and change them into an other species. The experiment shows ball moving randomly, and following other balls. When they are close to each other, they generate a group of balls with its own behavior. A group of group agents generate a cloud in the same way. When the number of balls contained inside the group is too high, the group disappears and releases all its balls repulsively. </p>
<p>Code of the model : </p>
<pre><code class="hljs zephir">
model balls_groups_clouds

<span class="hljs-keyword">global</span> { 
    <span class="hljs-comment">// Parameters</span>
    <span class="hljs-keyword">bool</span> create_group &lt;- <span class="hljs-keyword">true</span>; 
    <span class="hljs-keyword">bool</span> create_cloud &lt;- <span class="hljs-keyword">false</span>; 
    
    <span class="hljs-comment">// Environment</span>
    point environment_bounds &lt;- {<span class="hljs-number">500</span>, <span class="hljs-number">500</span>}; 
    geometry shape &lt;- rectangle(environment_bounds) ;       
    
    <span class="hljs-comment">//Define a inner environment smaller inside the environment</span>
    <span class="hljs-keyword">int</span> inner_bounds_x &lt;- (<span class="hljs-keyword">int</span>((environment_bounds.x) / <span class="hljs-number">20</span>))  ;
    <span class="hljs-keyword">int</span> inner_bounds_y &lt;- (<span class="hljs-keyword">int</span>((environment_bounds.y) / <span class="hljs-number">20</span>))  ;
    <span class="hljs-keyword">int</span> xmin &lt;- inner_bounds_x ;
    <span class="hljs-keyword">int</span> ymin &lt;- inner_bounds_y ;       
    <span class="hljs-keyword">int</span> xmax &lt;- <span class="hljs-keyword">int</span>((environment_bounds.x) - inner_bounds_x) ;
    <span class="hljs-keyword">int</span> ymax &lt;- <span class="hljs-keyword">int</span>((environment_bounds.y) - inner_bounds_y) ;
    
    <span class="hljs-keyword">float</span> MAX_DISTANCE &lt;- environment_bounds.x + environment_bounds.y  ;
    
    <span class="hljs-comment">//Global variables for ball agents</span>
    rgb ball_color &lt;- <span class="hljs-comment">#green; </span>
    rgb chaos_ball_color &lt;- <span class="hljs-comment">#red;</span>
    <span class="hljs-keyword">float</span> ball_size &lt;- <span class="hljs-keyword">float</span>(<span class="hljs-number">3</span>);  
    <span class="hljs-keyword">float</span> ball_speed &lt;- <span class="hljs-keyword">float</span>(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">float</span> chaos_ball_speed &lt;- <span class="hljs-number">8</span> * ball_speed;  
    <span class="hljs-keyword">int</span> ball_number &lt;- <span class="hljs-number">200</span> min: <span class="hljs-number">2</span> max: <span class="hljs-number">1000</span>;  
    geometry ball_shape &lt;- circle (ball_size) ;
    <span class="hljs-keyword">float</span> ball_separation &lt;- <span class="hljs-number">6</span> * ball_size; 
    
    <span class="hljs-comment">//Global variables for group agents</span>
    <span class="hljs-keyword">int</span> group_creation_distance &lt;- <span class="hljs-keyword">int</span>(ball_separation + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">int</span> min_group_member &lt;- <span class="hljs-number">3</span>;
    <span class="hljs-keyword">int</span> group_base_speed &lt;- (<span class="hljs-keyword">int</span>(ball_speed * <span class="hljs-number">1.5</span>));
    <span class="hljs-keyword">int</span> base_perception_range &lt;- <span class="hljs-keyword">int</span> (environment_bounds.x / <span class="hljs-number">100</span>) min: <span class="hljs-number">1</span> ;  
    <span class="hljs-keyword">int</span> creation_frequency &lt;- <span class="hljs-number">3</span>;
    <span class="hljs-keyword">int</span> update_frequency &lt;- <span class="hljs-number">3</span>;
    <span class="hljs-keyword">int</span> merge_frequency &lt;- <span class="hljs-number">3</span>;
    <span class="hljs-keyword">float</span> merge_possibility &lt;- <span class="hljs-number">0.3</span>;
    
    <span class="hljs-comment">//Global variables for Clouds Agents</span>
    <span class="hljs-keyword">int</span> cloud_creation_distance &lt;- <span class="hljs-number">30</span> <span class="hljs-keyword">const</span>: <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">int</span> min_cloud_member &lt;- <span class="hljs-number">3</span> <span class="hljs-keyword">const</span>: <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">int</span> cloud_speed &lt;- <span class="hljs-number">3</span> <span class="hljs-keyword">const</span>: <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">int</span> cloud_perception_range &lt;- base_perception_range <span class="hljs-keyword">const</span>: <span class="hljs-keyword">true</span> ; 
    
    init {
        create ball number: ball_number ;
        create group_agents_viewer;
        create cloud_agents_viewer;
    }
    
    <span class="hljs-comment">//The simulation will try to create group at each frequence cycle</span>
    reflex create_groups when: ( create_group <span class="hljs-keyword">and</span> ((cycle mod creation_frequency) = <span class="hljs-number">0</span>) ) {
        <span class="hljs-comment">//create a list from all balls following the nearest ball</span>
        <span class="hljs-keyword">list</span>&lt;ball&gt; free_balls &lt;- ball where ((each.state) = <span class="hljs-string">'follow_nearest_ball'</span>) ;

        <span class="hljs-keyword">if</span> (length (free_balls) &gt; <span class="hljs-number">1</span>) {
            <span class="hljs-comment">//Clustering of the balls according to their distance with at least a minimal number of balls in a group</span>
            <span class="hljs-keyword">list</span>&lt;<span class="hljs-keyword">list</span>&lt;ball&gt;&gt; satisfying_ball_groups &lt;- (free_balls simple_clustering_by_distance group_creation_distance) where ( (length (each)) &gt; min_group_member ) ;
            
            
            loop one_group over: satisfying_ball_groups {
                create group returns: new_groups;
                
                <span class="hljs-comment">//Capture by the new groups created of the different balls present in the list one_group</span>
                ask (new_groups at <span class="hljs-number">0</span>) <span class="hljs-keyword">as</span>: group {
                    capture one_group <span class="hljs-keyword">as</span>: ball_in_group; 
                }
            }
        }
    }
    
    <span class="hljs-comment">//The simulation will try to create clouds at each frequence cycle</span>
    reflex create_clouds when: (create_cloud <span class="hljs-keyword">and</span> ((cycle mod creation_frequency) = <span class="hljs-number">0</span>) ) {
        <span class="hljs-comment">//A cloud can be created only using group with a number of balls inside greater than 5% of the total ball number</span>
        <span class="hljs-keyword">list</span>&lt;group&gt; candidate_groups &lt;- group where (length(each.members) &gt; (<span class="hljs-number">0.05</span> * ball_number) );
        
        <span class="hljs-comment">//A cloud can be created also only using group which aren't too far away </span>
        <span class="hljs-keyword">list</span>&lt;<span class="hljs-keyword">list</span>&lt;group&gt;&gt; satisfying_groups &lt;- (candidate_groups simple_clustering_by_distance cloud_creation_distance) where (length(each) &gt;= min_cloud_member);
        
        <span class="hljs-comment">//Creation of the different clouds using the groups satisfying both conditions</span>
        loop one_group over: satisfying_groups {
            create cloud returns: rets;         
            cloud newCloud &lt;- rets at <span class="hljs-number">0</span>; 
            ask newCloud <span class="hljs-keyword">as</span>: cloud {
                capture one_group <span class="hljs-keyword">as</span>: group_delegation;
            }

            loop gd over: (newCloud.members) {
                ask gd <span class="hljs-keyword">as</span> group_delegation {
                    migrate ball_in_group target: ball_in_cloud;
                }
            } 
            
            newCloud.color &lt;- ((group_delegation(one_of(newCloud.members))).color).darker;
        }
    }
}
    <span class="hljs-comment">//Base species with just the skills moving and all built-in variables and operators derivated from it</span>
    species base skills: [moving] ;
    
    <span class="hljs-comment">//Species with a specified type of control architecture, here the final state machine FSM</span>
    species ball <span class="hljs-keyword">parent</span>: base control: fsm  { 
        
        <span class="hljs-keyword">float</span> speed &lt;- ball_speed; 
        rgb color &lt;- ball_color;
        <span class="hljs-keyword">int</span> beginning_chaos_time; 
        <span class="hljs-keyword">int</span> time_in_chaos_state;
        
        <span class="hljs-comment">//create the ball in a certain way to not make balls intersect each other</span>
        init {
            <span class="hljs-keyword">bool</span> continue_loop &lt;- <span class="hljs-keyword">true</span> ; 
            loop <span class="hljs-keyword">while</span>: continue_loop {
                point tmp_location &lt;- {(rnd (xmax - xmin)) + xmin, (rnd (ymax - ymin)) + ymin} ;
                geometry potential_geom &lt;- ball_shape at_location tmp_location ; 
                
                <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">empty</span> ( ball where  ( each intersects potential_geom ) ) )  {
                    location &lt;- tmp_location ;
                    continue_loop &lt;- <span class="hljs-keyword">false</span> ;
                }
            }
        }
        
        <span class="hljs-comment">//Action used to separate the balls and make them repulsive for the other balls of the group</span>
        action separation (<span class="hljs-keyword">list</span>&lt;ball&gt; nearby_balls) {
            <span class="hljs-keyword">float</span> repulsive_dx &lt;- <span class="hljs-number">0.0</span> ;
            <span class="hljs-keyword">float</span> repulsive_dy &lt;- <span class="hljs-number">0.0</span> ;
            loop nb over: nearby_balls { 
                <span class="hljs-keyword">float</span> repulsive_distance &lt;- ball_separation - ( location distance_to ( nb).location ) ;
                <span class="hljs-keyword">int</span> repulsive_direction &lt;- ((nb).location) towards (location) ;
                repulsive_dx &lt;- repulsive_dx + (repulsive_distance * (cos (repulsive_direction))) ;
                repulsive_dy &lt;- repulsive_dy + (repulsive_distance * (sin (repulsive_direction))) ;
            }
            location &lt;- location + {repulsive_dx, repulsive_dy} ;
        }
        
        <span class="hljs-keyword">bool</span> in_bounds (point a_point) {
            <span class="hljs-keyword">return</span> ( !(a_point.x &lt; xmin) <span class="hljs-keyword">and</span> !(a_point.x &gt; xmax) <span class="hljs-keyword">and</span> !(a_point.y &lt; ymin) <span class="hljs-keyword">and</span> !(a_point.y &gt; ymax) ) ;
        }
         
        <span class="hljs-comment">//State that will make the agent follows the closest ball if it is not in the chaos state anymore</span>
        state follow_nearest_ball initial: <span class="hljs-keyword">true</span> {
            enter {   
                color &lt;- ball_color ;
                speed &lt;- ball_speed ;
            }
            <span class="hljs-keyword">list</span>&lt;ball&gt; free_balls &lt;- (<span class="hljs-keyword">list</span> (ball) - <span class="hljs-keyword">self</span>) where ((each.state) = <span class="hljs-string">'follow_nearest_ball'</span>) ;
            ball nearest_free_ball &lt;- free_balls closest_to <span class="hljs-keyword">self</span>;
            <span class="hljs-keyword">if</span> nearest_free_ball != nil {
                heading &lt;- <span class="hljs-keyword">self</span> towards (nearest_free_ball) ; 
                <span class="hljs-keyword">float</span> step_distance &lt;- speed * step ;
                <span class="hljs-keyword">float</span> step_x &lt;- step_distance * (cos (heading)) ;
                <span class="hljs-keyword">float</span> step_y &lt;- step_distance * (sin (heading)) ; 
                point tmp_location &lt;- location + {step_x, step_y} ;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> in_bounds (tmp_location) ) {
                    location &lt;- tmp_location ;
                    <span class="hljs-keyword">do</span> separation (((ball overlapping (shape + ball_separation)) - <span class="hljs-keyword">self</span>));
                }
            }
        }
        
        <span class="hljs-comment">//Make the ball move randomly during a certain time</span>
        state chaos {
            enter {
                beginning_chaos_time &lt;- <span class="hljs-keyword">int</span>(time) ;
                time_in_chaos_state &lt;- <span class="hljs-number">10</span> + (rnd(<span class="hljs-number">10</span>)) ;
                color &lt;- chaos_ball_color ;
                speed &lt;- chaos_ball_speed ;
                heading &lt;- rnd(<span class="hljs-number">359</span>) ;
            }
            
            <span class="hljs-keyword">float</span> step_distance &lt;- speed * step ;
            <span class="hljs-keyword">float</span> step_x &lt;- step_distance * (cos (heading)) ;
            <span class="hljs-keyword">float</span> step_y &lt;- step_distance * (sin (heading)) ;
            point tmp_location &lt;- location + {step_x, step_y} ;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> in_bounds (tmp_location)) {
                location &lt;- tmp_location ;
                <span class="hljs-keyword">do</span> separation (nearby_balls: (ball overlapping (shape + ball_separation)) - <span class="hljs-keyword">self</span>);
            }
            
            transition to: follow_nearest_ball when: time &gt; (beginning_chaos_time + time_in_chaos_state) ;
        }
        
        aspect <span class="hljs-keyword">default</span> {
            draw ball_shape color: color size: ball_size at:<span class="hljs-keyword">self</span>.location;
        }
    }
    
    <span class="hljs-comment">//Species representing the group of balls</span>
    species group <span class="hljs-keyword">parent</span>: base { 
        
        rgb color &lt;- rgb ([ rnd(<span class="hljs-number">255</span>), rnd(<span class="hljs-number">255</span>), rnd(<span class="hljs-number">255</span>) ]) ;
        geometry shape &lt;- polygon (ball_in_group) buffer  <span class="hljs-number">10</span> ;
        <span class="hljs-keyword">float</span> speed update: <span class="hljs-keyword">float</span>(group_base_speed) ;
        
        <span class="hljs-comment">//Parameter to capture the balls contains in the perception range</span>
        <span class="hljs-keyword">float</span> perception_range update: <span class="hljs-keyword">float</span>(base_perception_range + (rnd(<span class="hljs-number">5</span>))) ;
        
        ball nearest_free_ball update: ( ball where ( (each.state = <span class="hljs-string">'follow_nearest_ball'</span>) ) ) closest_to <span class="hljs-keyword">self</span> ;
        group nearest_smaller_group update: ( ( (group <span class="hljs-keyword">as</span> <span class="hljs-keyword">list</span>) - <span class="hljs-keyword">self</span> ) where ( (length (each.members)) &lt; (length (members)) ) ) closest_to <span class="hljs-keyword">self</span> ;
        base target update: (<span class="hljs-keyword">self</span> get_nearer_target []) depends_on: [nearest_free_ball, nearest_smaller_group] ;
         
        <span class="hljs-comment">//Function to return the closest ball or small group of balls that the agent could capture</span>
        base get_nearer_target {
            <span class="hljs-keyword">if</span>  (nearest_free_ball = nil) <span class="hljs-keyword">and</span> (nearest_smaller_group = nil) {
                <span class="hljs-keyword">return</span> nil ;
            }
            
            <span class="hljs-keyword">float</span> distance_to_ball &lt;- (nearest_free_ball != nil) ? (<span class="hljs-keyword">self</span> distance_to nearest_free_ball) : MAX_DISTANCE ;
            <span class="hljs-keyword">float</span> distance_to_group &lt;- (nearest_smaller_group != nil) ? (<span class="hljs-keyword">self</span> distance_to nearest_smaller_group) : MAX_DISTANCE ;
            <span class="hljs-keyword">if</span> (distance_to_ball &lt; distance_to_group) {
                <span class="hljs-keyword">return</span> nearest_free_ball ;
            }
             
            <span class="hljs-keyword">return</span> nearest_smaller_group ;
        }
        
        <span class="hljs-comment">//Action to use when the group of balls explode</span>
        action separate_components {
            loop com over: (<span class="hljs-keyword">list</span> (ball_in_group)) {
                <span class="hljs-keyword">list</span>&lt;ball_in_group&gt; nearby_balls &lt;-  ((ball_in_group overlapping (com.shape + ball_separation)) - com) where (each in members) ;
                <span class="hljs-keyword">float</span> repulsive_dx &lt;- <span class="hljs-number">0.0</span> ;
                <span class="hljs-keyword">float</span> repulsive_dy &lt;- <span class="hljs-number">0.0</span> ;
                loop nb over: nearby_balls { 
                    <span class="hljs-keyword">float</span> repulsive_distance &lt;- ball_separation - ( (ball_in_group (com)).location distance_to nb.location ) ;
                    <span class="hljs-keyword">int</span> repulsive_direction &lt;- (nb.location) direction_to ((ball_in_group (com)).location) ;
                    repulsive_dx &lt;- repulsive_dx + (repulsive_distance * (cos (repulsive_direction))) ;
                    repulsive_dy &lt;- repulsive_dy + (repulsive_distance * (sin (repulsive_direction))) ;
                }
                
                (ball_in_group (com)).location &lt;- (ball_in_group (com)).location + {repulsive_dx, repulsive_dy} ;
            }
        }
        
        <span class="hljs-comment">//Species that will represent the balls captured by the group agent</span>
        species ball_in_group <span class="hljs-keyword">parent</span>: ball topology: topology((world).shape)  {
            
            <span class="hljs-keyword">float</span> my_age &lt;- <span class="hljs-number">1.0</span> update: my_age + <span class="hljs-number">0.01</span>;
             
            state follow_nearest_ball initial: <span class="hljs-keyword">true</span> { }
            
            state chaos { }
            
            aspect <span class="hljs-keyword">default</span> {
                draw circle(my_age) color: ((host <span class="hljs-keyword">as</span> group).color).darker ;
            }
        }
        
        <span class="hljs-comment">//Reflex to capture all the balls close to the group agent</span>
        reflex capture_nearby_free_balls when: (cycle mod update_frequency) = <span class="hljs-number">0</span> {
            <span class="hljs-keyword">list</span>&lt;ball&gt; nearby_free_balls &lt;- (ball overlapping (shape + perception_range)) where (each.state = <span class="hljs-string">'follow_nearest_ball'</span>);
            <span class="hljs-keyword">if</span> !(<span class="hljs-keyword">empty</span> (nearby_free_balls)) {
                capture nearby_free_balls <span class="hljs-keyword">as</span>: ball_in_group;
            }
        }
        
        <span class="hljs-comment">//Action to do when the group is disaggregated</span>
        action disaggregate {
            release members <span class="hljs-keyword">as</span>: ball in: world {
                 state &lt;- <span class="hljs-string">'chaos'</span> ;
            }
            
            <span class="hljs-keyword">do</span> <span class="hljs-keyword">die</span> ;
        }
        
        <span class="hljs-comment">//Reflex to merge the group close to the agent when the cycle is in the frequency of merging</span>
        reflex merge_nearby_groups when: (cycle mod merge_frequency) = <span class="hljs-number">0</span> {
            <span class="hljs-keyword">if</span> ( (target != nil) <span class="hljs-keyword">and</span> ((species_of (target)) = group) ) {
                <span class="hljs-keyword">list</span>&lt;group&gt; nearby_groups &lt;- (group overlapping (shape + perception_range)) - <span class="hljs-keyword">self</span> ;
                
                <span class="hljs-keyword">if</span> target in nearby_groups {
                    <span class="hljs-keyword">if</span> (rnd(<span class="hljs-number">10</span>)) &lt; (merge_possibility * <span class="hljs-number">10</span>) {
                        <span class="hljs-keyword">list</span>&lt;ball_in_group&gt; target_coms &lt;- <span class="hljs-keyword">list</span>&lt;ball_in_group&gt;(target.members) ;
                        <span class="hljs-keyword">list</span>&lt;ball&gt; released_balls ;
                        ask target {
                            release target_coms <span class="hljs-keyword">as</span>: ball in: world returns: released_coms;
                            released_balls &lt;- <span class="hljs-keyword">list</span>(released_coms);
                            <span class="hljs-keyword">do</span> <span class="hljs-keyword">die</span> ;
                        }
                        capture released_balls <span class="hljs-keyword">as</span>: ball_in_group; 
                    }
                <span class="hljs-keyword">else</span> { ask target <span class="hljs-keyword">as</span> group {<span class="hljs-keyword">do</span> disaggregate ;} }
                }
            }
        }
        
        <span class="hljs-comment">//Reflex to chase a target agent </span>
        reflex chase_target when: (target != nil) {
            <span class="hljs-keyword">int</span> direction_to_nearest_ball &lt;- (<span class="hljs-keyword">self</span> towards (target)) ;
            <span class="hljs-keyword">float</span> step_distance &lt;- speed * step ;
            <span class="hljs-keyword">float</span> dx &lt;- step_distance * (cos (direction_to_nearest_ball)) ;
            <span class="hljs-keyword">float</span> dy &lt;- step_distance * (sin (direction_to_nearest_ball)) ;
            geometry envelope &lt;- shape.envelope ;
            point topleft_point &lt;- (envelope.points) at <span class="hljs-number">0</span> ;
            point bottomright_point &lt;- (envelope.points) at <span class="hljs-number">0</span> ;
            
            loop p over: envelope.points {
                <span class="hljs-keyword">if</span> ( (p.x &lt;= topleft_point.x) <span class="hljs-keyword">and</span> (p.y &lt;= topleft_point.y) ) {
                    topleft_point &lt;- p ;
                }
                
                <span class="hljs-keyword">if</span> ( (p.x &gt;= bottomright_point.x) <span class="hljs-keyword">and</span> (p.y &gt;= bottomright_point.y) ) {
                    bottomright_point &lt;- p ;
                }
            }
            
            <span class="hljs-keyword">if</span> ( (dx + topleft_point.x) &lt; <span class="hljs-number">0</span> ) {
                <span class="hljs-keyword">float</span> tmp_dx &lt;- dx + topleft_point.x ;
                dx &lt;- dx - tmp_dx ;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (dx + bottomright_point.x) &gt; (environment_bounds.x) {
                    <span class="hljs-keyword">float</span> tmp_dx &lt;- (dx + bottomright_point.x) - environment_bounds.x ;
                    dx &lt;- dx - tmp_dx ;
                }
            }
            
            <span class="hljs-keyword">if</span> (dy + topleft_point.y) &lt; <span class="hljs-number">0</span> {
                <span class="hljs-keyword">float</span> tmp_dy &lt;- dy + topleft_point.y ;
                dy &lt;- dy - tmp_dy ;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (dy + topleft_point.y) &gt; (environment_bounds.y) {
                    <span class="hljs-keyword">float</span> tmp_dy &lt;- (dy + bottomright_point.y) - (environment_bounds.y) ;
                    dy &lt;- dy - tmp_dy ;
                }
            }
            
            loop com over: (<span class="hljs-keyword">list</span> (ball_in_group)) {
                (ball_in_group (com)).location &lt;- (ball_in_group (com)).location + {dx, dy} ;
            }
            
            shape &lt;- convex_hull((polygon ((<span class="hljs-keyword">list</span> (ball_in_group)) collect (ball_in_group (each)).location)) + <span class="hljs-number">2.0</span>) ;
        }
        <span class="hljs-comment">//Reflex to disaggregate the group if it is too important ie the number of balls is greater than 80% of the total ball number</span>
        reflex self_disaggregate {
            <span class="hljs-keyword">if</span> ( ( length (members) ) &gt; ( <span class="hljs-number">0.8</span> * (ball_number) ) ) {
                <span class="hljs-keyword">do</span> disaggregate ;
            }
        }
        
        aspect <span class="hljs-keyword">default</span> {
            draw shape color: color;
        }
    }
    
    <span class="hljs-comment">//Species cloud that will be created by an agglomeration of groups.</span>
    species cloud <span class="hljs-keyword">parent</span>: base {
        geometry shape &lt;- convex_hull(polygon(members collect (((group_delegation(each)).shape).location))) update: convex_hull(polygon(members collect (((group_delegation(each)).shape).location)));

        rgb color;
        
        <span class="hljs-comment">//Species contained in the cloud to represent the groups captured by the cloud agent</span>
        species group_delegation <span class="hljs-keyword">parent</span>: group topology: (topology(world.shape)) {
            geometry shape &lt;- convex_hull( (polygon ( (<span class="hljs-keyword">list</span> (ball_in_cloud)) collect (each.location) )) ) buffer <span class="hljs-number">10</span> update: convex_hull( (polygon ( (<span class="hljs-keyword">list</span> (ball_in_cloud)) collect (each.location) )) ) buffer  <span class="hljs-number">10</span> ;

            reflex capture_nearby_free_balls when: <span class="hljs-keyword">false</span> {
            }
            
            reflex merge_nearby_groups when: <span class="hljs-keyword">false</span> {
            }
            
            reflex chase_target when: <span class="hljs-keyword">false</span> {
            }
            
            reflex self_disaggregate {
            }
            
            action move2 (<span class="hljs-keyword">float</span> with_heading, <span class="hljs-keyword">float</span> with_speed) {

                loop m over: members {
                    ask m <span class="hljs-keyword">as</span> ball_in_cloud {
                        <span class="hljs-keyword">do</span> move2 (with_heading,with_speed);
                    }
                }
            }
             
            species ball_in_cloud <span class="hljs-keyword">parent</span>: ball_in_group topology: (world.shape) <span class="hljs-keyword">as</span> topology control: fsm {
                
                action move2 (<span class="hljs-keyword">float</span> with_heading, <span class="hljs-keyword">float</span> with_speed) {
                    <span class="hljs-keyword">float</span> dx &lt;- cos(with_heading) * with_speed;
                    <span class="hljs-keyword">float</span> dy &lt;- sin(with_heading) * with_speed;
                    location &lt;- { ( (location.x) + dx ), ( (location.y) + dy )};
                }
                
                aspect <span class="hljs-keyword">default</span> {}               
            }
        }
        
        group target_group;
    
        <span class="hljs-comment">//The cloud try to look for small groups to capture them</span>
        reflex chase_group {
            <span class="hljs-keyword">if</span> ( (target_group = nil) <span class="hljs-keyword">or</span> (dead(target_group)) ) {
                target_group &lt;- one_of(group);
            }
            
            <span class="hljs-keyword">if</span> (target_group != nil) {
                <span class="hljs-keyword">int</span> direction_target &lt;- <span class="hljs-keyword">self</span> towards(target_group);
                
                loop m over: members {
                    ask m <span class="hljs-keyword">as</span> group_delegation {
                        <span class="hljs-keyword">do</span> move2 with: [ with_heading :: <span class="hljs-keyword">float</span>(direction_target), with_speed :: <span class="hljs-keyword">float</span>(cloud_speed) ];
                    }               
                }
            }
        }
        
        <span class="hljs-comment">//Operator to know if a cloud can capture a group overlapping the cloud agent. </span>
        <span class="hljs-keyword">bool</span> can_capture (group a_group) {
            
            <span class="hljs-keyword">if</span> (shape overlaps a_group.shape) { <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; }
            
            loop gd over: members {
                <span class="hljs-keyword">if</span> ( (a_group.shape) overlaps ( ( group_delegation(gd)).shape ) ) { <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; }
            }
            
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        }
        
        <span class="hljs-comment">//Reflex to capture group</span>
        reflex capture_group {
            <span class="hljs-keyword">if</span> ( (target_group != nil) <span class="hljs-keyword">and</span> !(dead(target_group)) ) {
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> can_capture [ a_group :: target_group]) {

                    capture target_group <span class="hljs-keyword">as</span>: group_delegation returns: gds;
    
                    ask (gds at <span class="hljs-number">0</span>) <span class="hljs-keyword">as</span>: group_delegation {
                        migrate ball_in_group target: ball_in_cloud;
                    }
                }
            }
        }
        
        <span class="hljs-comment">//Reflex to disaggregate the clouds when they are no more group to capture</span>
        reflex disaggregate when: (<span class="hljs-keyword">empty</span>(<span class="hljs-keyword">list</span>(group))) {
            loop m over: members {
                ask group_delegation(m) <span class="hljs-keyword">as</span>: group_delegation {
                    migrate ball_in_cloud target: ball_in_group;
                }
            }
            
            release members <span class="hljs-keyword">as</span>: group in: world returns: r_groups;
            
            loop rg over: r_groups {
                ask rg <span class="hljs-keyword">as</span>: group { <span class="hljs-keyword">do</span> disaggregate; }
            }
            
            <span class="hljs-keyword">do</span> <span class="hljs-keyword">die</span>; 
        }
         
        aspect <span class="hljs-keyword">default</span> {
            draw shape color: color <span class="hljs-keyword">empty</span>: <span class="hljs-keyword">true</span>;
            draw (name + <span class="hljs-string">' with '</span> + (string(length(members))) + <span class="hljs-string">' groups.'</span>) size: <span class="hljs-number">15</span> color: color  at: {location.x - <span class="hljs-number">65</span>, location.y};
        }
    }
    
    species group_agents_viewer  { 
        aspect <span class="hljs-keyword">default</span> {
            draw (<span class="hljs-string">'Number of groups: '</span> + (string (length (world.agents of_generic_species group)))) at: {(environment_bounds.x)/<span class="hljs-number">2</span> - <span class="hljs-number">210</span>, (environment_bounds.y)/<span class="hljs-number">2</span>} color: <span class="hljs-comment">#blue size: 40  ;</span>
        }
    }

    species cloud_agents_viewer  { 
        aspect <span class="hljs-keyword">default</span> {
            draw (<span class="hljs-string">'Number of clouds: '</span> + (string (length (<span class="hljs-keyword">list</span>(cloud))))) at: {(environment_bounds.x)/<span class="hljs-number">2</span> - <span class="hljs-number">210</span>, (environment_bounds.y)/<span class="hljs-number">2</span>} color: <span class="hljs-comment">#green size: 40 ;</span>
        }
    } 


experiment group_experiment type: gui {
    parameter <span class="hljs-string">'Create groups?'</span> <span class="hljs-keyword">var</span>: create_group &lt;- <span class="hljs-keyword">true</span>;
    parameter <span class="hljs-string">'Create clouds?'</span> <span class="hljs-keyword">var</span>: create_cloud &lt;- <span class="hljs-keyword">false</span>;
        
    output {
        display <span class="hljs-string">'Standard display'</span> {
            species ball aspect: <span class="hljs-keyword">default</span> transparency: <span class="hljs-number">0.5</span> ;
            
            species group aspect: <span class="hljs-keyword">default</span> transparency: <span class="hljs-number">0.5</span> {
                species ball_in_group;
            }
        }
        
        display <span class="hljs-string">'Ball display'</span> {
            species ball;
        }
        
        display <span class="hljs-string">'Group display'</span> {
            species group;
            species group_agents_viewer;
        }
    }
}

experiment cloud_experiment type: gui {

    parameter <span class="hljs-string">'Create groups?'</span> <span class="hljs-keyword">var</span>: create_group &lt;- <span class="hljs-keyword">true</span>;
    parameter <span class="hljs-string">'Create clouds?'</span> <span class="hljs-keyword">var</span>: create_cloud &lt;- <span class="hljs-keyword">true</span>;
        
    output {
        display <span class="hljs-string">'Standard display'</span> {
            species ball aspect: <span class="hljs-keyword">default</span> transparency: <span class="hljs-number">0.5</span> ;
            
            species group aspect: <span class="hljs-keyword">default</span> transparency: <span class="hljs-number">0.5</span> {
                species ball_in_group;
            }
            
            species cloud aspect: <span class="hljs-keyword">default</span> {
                species group_delegation transparency: <span class="hljs-number">0.9</span> {
                    species ball_in_cloud;
                    species ball_in_group;
                }
            }
        }
        
        display <span class="hljs-string">'Ball display'</span> {
            species ball;
        }
        
        display <span class="hljs-string">'Group display'</span> {
            species group;
            species group_agents_viewer;
        }

        display <span class="hljs-string">'Cloud display'</span> {
            species cloud;
        }
        
        monitor <span class="hljs-string">"Balls"</span> value: length(ball);
        monitor <span class="hljs-string">"Groups"</span> value: length(group);
        monitor <span class="hljs-string">"Clouds"</span> value: length(cloud);
    }
}
</code></pre>
<script>hljs.initHighlightingOnLoad();</script></body></html>