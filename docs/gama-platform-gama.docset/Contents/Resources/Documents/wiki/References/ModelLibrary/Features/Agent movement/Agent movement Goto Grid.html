<html><!-- Online page at https://github.com/gama-platform/gama/wiki/References/ModelLibrary/Features/Agent movement/Agent movement Goto Grid --><head><meta charset="utf-8"><title>Agent movement Goto Grid</title><script src="../../../../../dash_resources/highlight.all.js"></script><link rel="stylesheet" type="text/css" href="../../../../../dash_resources/github-markdown.css"><link rel="stylesheet" type="text/css" href="../../../../../dash_resources/highlightjs.github.css"></head><body class="markdown-body" style="padding-bottom:20px; margin: 8px 13px;"><h1 id="agent-movement-goto-grid">Agent movement Goto Grid</h1>
<h1 id="movement-on-a-grid-of-cells">Movement on a Grid of Cells</h1>
<p><em>Author :  Patrick Taillandier</em></p>
<p>Model to represent how the agents move from one point to a target agent on a grid of cells with obstacles, following the shortest path and coloring in magenta the cells intersecting the path of an agent</p>
<p>Code of the model : </p>
<pre><code class="hljs sqf">
model Grid

global {
    init {    
        create goal{
            <span class="hljs-built_in">location</span> &lt;- (one_of (cell where <span class="hljs-built_in">not</span> each.is_obstacle)).<span class="hljs-built_in">location</span>;
        }
        create people number: <span class="hljs-number">10</span> {
            target &lt;- one_of (goal);
            <span class="hljs-built_in">location</span> &lt;-  (one_of (cell where <span class="hljs-built_in">not</span> each.is_obstacle)).<span class="hljs-built_in">location</span>;
        }
    } 
}

grid cell width: <span class="hljs-number">50</span> height: <span class="hljs-number">50</span> neighbors: <span class="hljs-number">4</span> {
    bool is_obstacle &lt;- flip(<span class="hljs-number">0.2</span>);
    rgb color &lt;- is_obstacle ? <span class="hljs-meta">#black : #white;</span>
} 
     
species goal {
    aspect <span class="hljs-keyword">default</span> { 
        draw circle(<span class="hljs-number">0.5</span>) color: <span class="hljs-meta">#red;</span>
    }
}  
    
      
species people skills: [moving] {
    goal target;
    float <span class="hljs-built_in">speed</span> &lt;- float(<span class="hljs-number">3</span>);
    
    aspect <span class="hljs-keyword">default</span> {
        draw circle(<span class="hljs-number">0.5</span>) color: <span class="hljs-meta">#green;</span>
    }
    
    reflex <span class="hljs-built_in">move</span> when: <span class="hljs-built_in">location</span> != target{
        <span class="hljs-comment">//Neighs contains all the neighbours cells that are reachable by the agent plus the cell where it's located</span>
        <span class="hljs-built_in">list</span>&lt;cell&gt; neighs &lt;- (cell(<span class="hljs-built_in">location</span>) neighbors_at <span class="hljs-built_in">speed</span>) + cell(<span class="hljs-built_in">location</span>); 
        
        <span class="hljs-comment">//We restrain the movements of the agents only at the grid of cells that are not obstacle using the on facet of the goto operator and we return the path</span>
        <span class="hljs-comment">//followed by the agent</span>
        <span class="hljs-comment">//the recompute_path is used to precise that we do not need to recompute the shortest path at each movement (gain of computation time): the obtsacles on the grid never change.</span>
        path followed_path &lt;- self <span class="hljs-built_in">goto</span> (on:(cell where <span class="hljs-built_in">not</span> each.is_obstacle), target:target, <span class="hljs-built_in">speed</span>:<span class="hljs-built_in">speed</span>, return_path:<span class="hljs-literal">true</span>, recompute_path: <span class="hljs-literal">false</span>);
        
        <span class="hljs-comment">//As a side note, it is also possible to use the path_between operator and follow action with a grid</span>
        <span class="hljs-comment">//Add a my_path attribute of type path to the people species</span>
        <span class="hljs-comment">//if my_path = nil {my_path &lt;- path_between((cell where not each.is_obstacle), location, target);}</span>
        <span class="hljs-comment">//path followed_path &lt;- self follow (path: my_path,  return_path:true);</span>
        
        <span class="hljs-keyword">if</span> (followed_path != <span class="hljs-literal">nil</span>) <span class="hljs-built_in">and</span> <span class="hljs-built_in">not</span> empty(followed_path.segments) {
            geometry path_geom &lt;- geometry(followed_path.segments);
            
            <span class="hljs-comment">//The cells intersecting the path followed by the agent are colored in magenta</span>
            ask (neighs where (each.shape intersects path_geom)) { color &lt;- <span class="hljs-meta">#magenta;}</span>
        }   
    }
}

experiment goto_grid <span class="hljs-built_in">type</span>: gui {
    output {
        display objects_display {
            grid cell lines: <span class="hljs-meta">#black;</span>
            species goal aspect: <span class="hljs-keyword">default</span> ;
            species people aspect: <span class="hljs-keyword">default</span> ;
        }
    }
}
</code></pre>
<script>hljs.initHighlightingOnLoad();</script></body></html>