<html><!-- Online page at https://github.com/gama-platform/gama/wiki/References/ModelLibrary/Features/Multi-Level Usage/Multi-Level Usage Corridor --><head><meta charset="utf-8"><title>Multi Level Usage Corridor</title><script src="../../../../../dash_resources/highlight.all.js"></script><link rel="stylesheet" type="text/css" href="../../../../../dash_resources/github-markdown.css"><link rel="stylesheet" type="text/css" href="../../../../../dash_resources/highlightjs.github.css"></head><body class="markdown-body" style="padding-bottom:20px; margin: 8px 13px;"><h1 id="multi-level-usage-corridor">Multi Level Usage Corridor</h1>
<h1 id="corridor-multi-level-architecture">Corridor Multi-Level Architecture</h1>
<p>_Author : _</p>
<p>This model shows how to use multi-level architecture. A corridor can capture pedestrians going from left to right side if they are inside the corridor. This will result in changing their species from pedestrian to captured_pedestrian which will not be displayed. Once they pass enought time to consider they reach the exit of the corridor, they will be released by the corridor agent as pedestrians, letting them been displayed and going to their target. </p>
<p>Code of the model : </p>
<pre><code class="hljs processing">
model corridor

global {    
    <span class="hljs-comment">//Capture pedestrians parameter to define if wall will capture pedestrians</span>
    bool capture_pedestrians &lt;- <span class="hljs-keyword">false</span> parameter: <span class="hljs-string">'Capture pedestrians?'</span>;
    
    <span class="hljs-built_in">int</span> environment_size init: <span class="hljs-number">2000</span>;
    <span class="hljs-built_in">point</span> environment_bounds init: {environment_size, environment_size} ;
    geometry <span class="hljs-built_in">shape</span> &lt;- rectangle(environment_bounds) ;       
    
    <span class="hljs-comment">//Pedestrians parameters</span>
    <span class="hljs-built_in">float</span> pedestrian_size init: <span class="hljs-number">1.0</span>;
    geometry pedestrian_shape &lt;- circle (pedestrian_size);
    rgb pedestrian_color &lt;- #<span class="hljs-built_in">green</span>; 
    <span class="hljs-built_in">float</span> pedestrian_speed &lt;- <span class="hljs-number">2.0</span>;
    
    
    <span class="hljs-comment">//Wall parameters</span>
    rgb corridor_wall_color &lt;- #black;
    <span class="hljs-built_in">int</span> corridor_wall_width &lt;- <span class="hljs-built_in">int</span>(environment_size / <span class="hljs-number">2</span>);
    <span class="hljs-built_in">int</span> corridor_wall_height &lt;- <span class="hljs-number">200</span>;
    geometry corridor_wall_0_shape &lt;- rectangle ( {corridor_wall_width, corridor_wall_height} ) at_location {environment_size / <span class="hljs-number">2</span>, corridor_wall_height / <span class="hljs-number">2</span>};
    geometry corridor_wall_1_shape &lt;- rectangle ( {corridor_wall_width, corridor_wall_height} ) at_location {environment_size / <span class="hljs-number">2</span>, environment_size - (corridor_wall_height / <span class="hljs-number">2</span>)};
    
    <span class="hljs-comment">//Corridor parameters</span>
    rgb corridor_color &lt;- #<span class="hljs-built_in">blue</span>;
    <span class="hljs-built_in">int</span> corridor_width &lt;- <span class="hljs-built_in">int</span>(environment_size / <span class="hljs-number">2</span>) ;
    <span class="hljs-built_in">int</span> corridor_height &lt;- environment_size ;
    <span class="hljs-built_in">point</span> corridor_location &lt;- {environment_size / <span class="hljs-number">2</span>, environment_size / <span class="hljs-number">2</span>} ;
    geometry corridor_shape &lt;- ( (rectangle ({corridor_width, corridor_height})) at_location corridor_location) - (corridor_wall_0_shape + corridor_wall_1_shape);
    <span class="hljs-built_in">int</span> corridor_left_bounds &lt;- (<span class="hljs-built_in">int</span>(corridor_location.x - (corridor_width / <span class="hljs-number">2</span>))) ;
    <span class="hljs-built_in">int</span> corridor_right_bounds &lt;- (<span class="hljs-built_in">int</span>(corridor_location.x + (corridor_width / <span class="hljs-number">2</span>))) ;
    
    <span class="hljs-comment">//Generation of new pedestrians parameters</span>
    <span class="hljs-built_in">int</span> new_pedestrian_rate &lt;- <span class="hljs-number">10</span>;
    <span class="hljs-built_in">int</span> new_pedestian_generate_frequency &lt;- <span class="hljs-number">1</span>;
    <span class="hljs-built_in">int</span> new_pedestrian_y_distance &lt;- <span class="hljs-built_in">int</span>(environment_size / new_pedestrian_rate);
    
    list&lt;pedestrian&gt; pedestrians  update: list(pedestrian); 
    <span class="hljs-built_in">float</span> start_time &lt;- machine_time;
    
    init {
        create corridor;
         
        create corridor_wall number: <span class="hljs-number">2</span> returns: corridor_walls; 
        (corridor_walls at <span class="hljs-number">0</span>).<span class="hljs-built_in">shape</span> &lt;- corridor_wall_0_shape;
        (corridor_walls at <span class="hljs-number">1</span>).<span class="hljs-built_in">shape</span> &lt;- corridor_wall_1_shape;
        
    }
    
    <span class="hljs-comment">//Reflex to generate new pedestrians according to the frequency generation parameter</span>
    reflex generate_pedestrians when: ((cycle mod new_pedestian_generate_frequency) = <span class="hljs-number">0</span>) {
        create pedestrian number: new_pedestrian_rate returns: new_pedestrians; 
        
        <span class="hljs-built_in">int</span> loop_times &lt;- <span class="hljs-number">0</span>;
        <span class="hljs-built_in">loop</span> p over: new_pedestrians {
            <span class="hljs-built_in">int</span> y_coor &lt;- rnd (new_pedestrian_y_distance);
            ask p as: pedestrian {
                do init_location loc: { <span class="hljs-number">0</span>, (loop_times * new_pedestrian_y_distance) + y_coor };
            }
            loop_times &lt;- loop_times + <span class="hljs-number">1</span>;
        }
    }

} 

<span class="hljs-comment">//Species pedestrian which will move from one side of the experiments to another and destroy itself once the other side is reached</span>
species pedestrian skills: [moving] topology: ( topology (<span class="hljs-built_in">shape</span> - (corridor_wall_0_shape + corridor_wall_1_shape)) ){
    geometry <span class="hljs-built_in">shape</span> &lt;-  circle (pedestrian_size);
    <span class="hljs-built_in">point</span> initial_location;
    <span class="hljs-built_in">point</span> target_location;
    <span class="hljs-built_in">int</span> heading;
    <span class="hljs-built_in">float</span> speed &lt;- <span class="hljs-number">2.0</span>;
    
    action init_location (<span class="hljs-built_in">point</span> loc) {
        location &lt;- loc;
        initial_location &lt;- loc;
        target_location &lt;- {environment_size, loc.y};
        heading &lt;- (self) towards (target_location);
    }
    
    <span class="hljs-comment">//Reflex to make the agent move to its target_location</span>
    reflex move_left {
        <span class="hljs-built_in">int</span> update_heading &lt;- (self) towards (target_location);
        
        <span class="hljs-built_in">point</span> current_location &lt;- location;
        
        do move heading: update_heading ;
        
        <span class="hljs-comment">//Conditions to know if the agent doesn't move, in this case we take care if it is bcause of the walls </span>
        <span class="hljs-keyword">if</span> (current_location = location) {
            <span class="hljs-keyword">if</span> ( (location.y &lt;= corridor_wall_height) or (location.y &gt;= environment_size - corridor_wall_height) ) {
                do move heading: self towards {(environment_size / <span class="hljs-number">2</span>) - (corridor_width / <span class="hljs-number">2</span>), environment_size / <span class="hljs-number">2</span>}; 
            } <span class="hljs-keyword">else</span> {
                do move heading: self towards {environment_size / <span class="hljs-number">2</span>, environment_size / <span class="hljs-number">2</span>}; 
            }
        }
        
        <span class="hljs-keyword">if</span>( (target_location.x - location.x) &lt;= speed ) { 
            do die;
        }
    }
     
    aspect my_aspect {
        <span class="hljs-title">draw</span> <span class="hljs-built_in">shape</span> <span class="hljs-built_in">color</span>: pedestrian_color;
    }
}

<span class="hljs-comment">//Species which represents the corridor</span>
species corridor  {
    geometry <span class="hljs-built_in">shape</span> &lt;- corridor_shape;
    
    <span class="hljs-comment">//Subspecies for the multi-level architectures : captured pedestrians in this case</span>
    species captured_pedestrian parent: pedestrian schedules: [] {
        <span class="hljs-built_in">float</span> released_time;
        
        aspect my_aspect { }
    }
    
    init {
        create corridor_info_drawer number: <span class="hljs-number">1</span> with: [target :: self];
    }
    
    <span class="hljs-comment">//Reflex to capture pedestrians if the parameter is checked</span>
    reflex aggregate when: capture_pedestrians {
        <span class="hljs-comment">//List to get all the pedestrians inside the corridor</span>
        list&lt;pedestrian&gt; tobe_captured_pedestrians &lt;- (pedestrian overlapping <span class="hljs-built_in">shape</span>);
        
        <span class="hljs-comment">//If we have pedestrians inside the corridor, we capture them</span>
        <span class="hljs-keyword">if</span> !(empty (tobe_captured_pedestrians)) {
            capture tobe_captured_pedestrians as: captured_pedestrian returns: cps;
            
            <span class="hljs-comment">//We update the time during which a pedestrian is captured according to the time the pedestrian</span>
            <span class="hljs-comment">// should need to pass through the corridor if it wasn't captured</span>
            <span class="hljs-built_in">loop</span> cp over: cps {
                cp.released_time &lt;- time + ( ( corridor_width - ( (((cp).location).x) - ((environment_size / <span class="hljs-number">2</span>) - (corridor_width / <span class="hljs-number">2</span>)) ) ) / pedestrian_speed) ;
            }
        }
    }
    
    <span class="hljs-comment">//Reflex to release pedestrians which have already passed enough time in the corridor</span>
    <span class="hljs-comment">// which means if they weren't captured by the corridor, they would have finish passing through it</span>
    reflex disaggregate  {
        list tobe_released_pedestrians &lt;- members where (time &gt;= (captured_pedestrian (each)).released_time);
        <span class="hljs-keyword">if</span> !(empty (tobe_released_pedestrians)) {
            release tobe_released_pedestrians as: pedestrian in: world {
                location &lt;- {((environment_size / <span class="hljs-number">2</span>) + (corridor_width / <span class="hljs-number">2</span>)) + (<span class="hljs-number">2</span> * pedestrian_size), (location).y};
            }
        }
    }
    
    aspect my_aspect {
        <span class="hljs-title">draw</span> <span class="hljs-built_in">shape</span> <span class="hljs-built_in">color</span>: corridor_color;
    }
}

species corridor_wall {
    init {
        create corridor_wall_info_drawer number: <span class="hljs-number">1</span> with: [target :: self];
    }
    
    aspect  my_aspect {
        <span class="hljs-title">draw</span> <span class="hljs-built_in">shape</span> <span class="hljs-built_in">color</span>: corridor_wall_color;
    }
}

species corridor_info_drawer {
    corridor target;
    
    aspect my_aspect {
        <span class="hljs-title">draw</span>  <span class="hljs-string">'Captured pedestrians: '</span> + (string (length (target.members))) <span class="hljs-built_in">color</span>: rgb (<span class="hljs-string">'blue'</span>) <span class="hljs-built_in">size</span>: <span class="hljs-number">12</span>°px at: {(target.location).x - <span class="hljs-number">480</span>, (target.location).y};
        <span class="hljs-title">draw</span>  <span class="hljs-string">'Pedestrians: '</span> + (string (length (list (pedestrian)))) <span class="hljs-built_in">color</span>: rgb (<span class="hljs-string">'blue'</span>) <span class="hljs-built_in">size</span>: <span class="hljs-number">12</span>°px at: {(target.location).x - <span class="hljs-number">135</span>, (target.location).y + <span class="hljs-number">100</span>};
    }
}

species corridor_wall_info_drawer {
    corridor_wall target;
    
    init {
        location &lt;- target.location;
    }
    
    aspect my_aspect { 
        <span class="hljs-title">draw</span> <span class="hljs-string">'WALL'</span> <span class="hljs-built_in">color</span>: rgb (<span class="hljs-string">'green'</span>) <span class="hljs-built_in">size</span>: <span class="hljs-number">15</span>°px at: {(location).x - <span class="hljs-number">40</span>, (location).y};
    }
}


experiment corridor_expr type: gui{
    output {
        display defaut_display {
            species pedestrian;
            
            species corridor aspect: my_aspect transparency: <span class="hljs-number">0.8</span> {
                species captured_pedestrian;
            }
            
            species corridor_wall aspect: my_aspect transparency: <span class="hljs-number">0.7</span>;
            species corridor_info_drawer aspect: my_aspect;
            species corridor_wall_info_drawer aspect: my_aspect;
        }

        display Execution_Time refresh: every(<span class="hljs-number">25</span>) {
            chart <span class="hljs-string">'Simulation step length'</span> type: series <span class="hljs-built_in">background</span>: #white {
                data <span class="hljs-string">'simulation_step_length_in_mili_second'</span> value: machine_time - start_time <span class="hljs-built_in">color</span>: (rgb (<span class="hljs-string">'green'</span>));
            }
        }
        
        display Captured_Pedestrians refresh: every(<span class="hljs-number">25</span>){
            chart <span class="hljs-string">'Captured Pedestrian'</span> type: series <span class="hljs-built_in">background</span>: #white {
                data <span class="hljs-string">'captured_pedestrians'</span> value: length ( ((list (corridor)) at <span class="hljs-number">0</span>).members ) <span class="hljs-built_in">color</span>: rgb (<span class="hljs-string">'blue'</span>);
                data <span class="hljs-string">'pedestrians'</span> value: length (list (pedestrian)) <span class="hljs-built_in">color</span>: rgb (<span class="hljs-string">'white'</span>);  
            }
        }
    }
}
</code></pre>
<script>hljs.initHighlightingOnLoad();</script></body></html>