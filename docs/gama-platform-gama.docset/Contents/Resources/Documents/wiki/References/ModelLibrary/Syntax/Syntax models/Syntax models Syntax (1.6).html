<html><!-- Online page at https://github.com/gama-platform/gama/wiki/References/ModelLibrary/Syntax/Syntax models/Syntax models Syntax (1.6) --><head><meta charset="utf-8"><title>Syntax models Syntax (1.6)</title><script src="../../../../../dash_resources/highlight.all.js"></script><link rel="stylesheet" type="text/css" href="../../../../../dash_resources/github-markdown.css"><link rel="stylesheet" type="text/css" href="../../../../../dash_resources/highlightjs.github.css"></head><body class="markdown-body" style="padding-bottom:20px; margin: 8px 13px;"><h1 id="syntax-models-syntax-16">Syntax models Syntax (1.6)</h1>
<h1 id="syntax">Syntax</h1>
<p><em>Author : Alexis Drogoul</em></p>
<p>An overview of the new syntactic constructs that have been introduced in GAMA 1.6</p>
<p>Code of the model : </p>
<pre><code class="hljs groovy">
<span class="hljs-meta">@no</span>_warning
model syntax

<span class="hljs-comment">/**
 * The global section can now sport skills and control, just like other agents. 
 * The example below shows a potentially moving world that can be controlled by a finite state machine.
 */</span>
global <span class="hljs-string">skills:</span> [moving] <span class="hljs-string">control:</span> fsm {

<span class="hljs-comment">/**
 * EQUATIONS
 */</span> 
    <span class="hljs-keyword">float</span> x;
    <span class="hljs-keyword">float</span> y;
    <span class="hljs-keyword">float</span> t;
    equation eq {
        diff(x, t) = x / <span class="hljs-number">2</span>;
        diff(y, t) = x + y * <span class="hljs-number">2</span>;
    }

    reflex solving {solve eq <span class="hljs-string">step:</span> <span class="hljs-number">1</span> <span class="hljs-string">method:</span> rk4;}

    <span class="hljs-comment">/** 
 * ATTRIBUTES
 */</span>

<span class="hljs-comment">// Attributes can be declared in different ways, ranging from "classic"...</span>
    list&lt;<span class="hljs-keyword">int</span>&gt; a1 <span class="hljs-string">const:</span> <span class="hljs-literal">true</span> &lt;- [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-string">of:</span> <span class="hljs-keyword">int</span>;
    list a2 &lt;- [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-string">of:</span> <span class="hljs-keyword">int</span>;
    <span class="hljs-comment">// ... to "compact" Java-like syntax.</span>
    list&lt;<span class="hljs-keyword">int</span>&gt; a3 &lt;- [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

    <span class="hljs-comment">// The declaration of a default size/value in containers is now working correctly</span>
    list&lt;<span class="hljs-keyword">float</span>&gt; f &lt;- list_with(<span class="hljs-number">2000</span>,<span class="hljs-number">0.0</span>);

    <span class="hljs-comment">// Functions can be declared using the regular facet "-&gt;" / "function:" </span>
    <span class="hljs-keyword">int</span> b1 -&gt; { <span class="hljs-number">100</span> + length(a1) };
    <span class="hljs-keyword">int</span> b2 <span class="hljs-string">function:</span> { <span class="hljs-number">100</span> + length(a1) };
    <span class="hljs-comment">// ... or using a block (like a statement -- note the absence of semi-column at the end)</span>
    <span class="hljs-keyword">int</span> b3 {
        <span class="hljs-number">100</span> + length(a1)
    }
    state first_state <span class="hljs-string">initial:</span> <span class="hljs-literal">true</span> {
    <span class="hljs-comment">//...</span>

    }
    init {
        create species0 <span class="hljs-string">number:</span> <span class="hljs-number">20</span>;
    }
    

    <span class="hljs-comment">/**
     * UNITS
     */</span>
<span class="hljs-comment">// The usage of units is improved ( "#" being replaced by "°"), and they can be combined</span>
    <span class="hljs-keyword">float</span> c &lt;- <span class="hljs-number">10</span> °meter;
    <span class="hljs-keyword">float</span> speed &lt;- <span class="hljs-number">10</span> °meter / °sec;

    <span class="hljs-comment">// Attributes can (finally!) be named after unit names</span>
    <span class="hljs-keyword">float</span> meter &lt;- <span class="hljs-number">10.0</span>;

    <span class="hljs-comment">// Some mathematical constants have been introduced alongside units</span>
    <span class="hljs-keyword">float</span> pi_4 &lt;- °pi / <span class="hljs-number">4</span>;
    <span class="hljs-keyword">float</span> e &lt;- °e;

    <span class="hljs-comment">/**
      * ACTIONS
      */</span>
    <span class="hljs-comment">// Actions can also be declared in different ways. Classic:</span>
    action dummy1 <span class="hljs-string">type:</span> list <span class="hljs-string">of:</span> <span class="hljs-keyword">int</span> {
        arg a <span class="hljs-string">type:</span> <span class="hljs-keyword">int</span> <span class="hljs-string">default:</span> <span class="hljs-number">100</span>;
        arg b <span class="hljs-string">type:</span> <span class="hljs-keyword">float</span>;
        <span class="hljs-keyword">return</span> [a, <span class="hljs-keyword">int</span>(b)];
    }
    <span class="hljs-comment">// Semi-classic (prefixed by the type)</span>
    list dummy2 <span class="hljs-string">of:</span> <span class="hljs-keyword">int</span> {
        arg a <span class="hljs-string">type:</span> <span class="hljs-keyword">int</span> <span class="hljs-string">default:</span> <span class="hljs-number">100</span>;
        arg b <span class="hljs-string">type:</span> <span class="hljs-keyword">float</span>;
        <span class="hljs-keyword">return</span> [a, <span class="hljs-keyword">int</span>(b)];
    }
    <span class="hljs-comment">//Compact</span>
    list&lt;<span class="hljs-keyword">int</span>&gt; dummy1 (<span class="hljs-keyword">int</span> a &lt;- <span class="hljs-number">100</span>, <span class="hljs-keyword">float</span> b) {
        <span class="hljs-keyword">return</span> [a, <span class="hljs-keyword">int</span>(b)];
    }

    <span class="hljs-comment">// An action that returns nothing can still be called "action"</span>
    action dummy_void {
        write <span class="hljs-string">"dummy_void"</span>;
    }

    <span class="hljs-comment">/**
     * DEALING WITH VARIABLES
     */</span>
    reflex variables {

    <span class="hljs-comment">// Temporary variables can use the same syntax as attributes. The classic form:</span>
        <span class="hljs-comment">//let name: t1 type: int value: length(a1);</span>
        <span class="hljs-comment">// is equivalent to the more compact one:</span>
        <span class="hljs-keyword">int</span> t2 &lt;- length(a1);

        <span class="hljs-comment">// Assigning a value to variables is also sporting a new syntax </span>
        set t2 <span class="hljs-string">value:</span> <span class="hljs-number">100</span>;
        <span class="hljs-comment">// ... can be replaced by </span>
        set t2 &lt;- <span class="hljs-number">100</span>;
        <span class="hljs-comment">// ... or even by</span>
        t2 &lt;- <span class="hljs-number">100</span>;

        <span class="hljs-comment">// Species can now act as direct containers of their agents..</span>
        list&lt;species0&gt; spec_with_location &lt;- species0 select (each.location = { <span class="hljs-number">0</span>, <span class="hljs-number">0</span> });
        species0 agent0 &lt;- species0[<span class="hljs-number">10</span>];
        write string(agent0);

        <span class="hljs-comment">// ...  and agents as direct containers of their attributes (mimicking the internal attributes map). This "virtual map" will now contain, in addition to the attributes, </span>
        <span class="hljs-comment">// all the variables loaded from CSV, SQL or shape files (some stored in the agent itself, others in the shape).</span>
        agent0[<span class="hljs-string">"departure"</span>] &lt;- { <span class="hljs-number">0</span>, <span class="hljs-number">0</span> };
        write string(agent0);

        <span class="hljs-comment">// Keys are not necessarily strings, by the way ! A warning is emitted in such cases, but it is just a warning.</span>
        agent0[<span class="hljs-number">0</span>] &lt;- <span class="hljs-number">0</span>;

        <span class="hljs-comment">// Accesses can be combined</span>
        species0[<span class="hljs-number">10</span>].name &lt;- <span class="hljs-string">"A new name"</span>; <span class="hljs-comment">// which is equivalent to (spec at 10).name = "A new name";</span>

        <span class="hljs-comment">// Points can be used (with or without curly parentheses) to access agents in species</span>
        species0 agent1 &lt;- species0[<span class="hljs-number">10</span>, <span class="hljs-number">10</span>]; <span class="hljs-comment">// returns the agent closest to point {10,10} for a "regular" species</span>
        <span class="hljs-comment">// The behavior is a bit tweaked for grids, to allow for a "natural" access</span>
        my_grid cell0 &lt;- my_grid[<span class="hljs-number">10</span>, <span class="hljs-number">10</span>]; <span class="hljs-comment">// Here, it is the cell at {10, 10} in the matrix of cells</span>

        <span class="hljs-comment">// Shapes also act as containers of CVS/Shapefile attributes (in case they are loaded without being attributed to an agent), as well as 3D properties (for the display).</span>
        agent0.name &lt;- string(agent0.shape[<span class="hljs-string">"ID"</span>]);
        geometry geom &lt;- square(<span class="hljs-number">100</span>);
        geom[<span class="hljs-string">"type"</span>] &lt;- <span class="hljs-string">"cube"</span>;
        
        
        <span class="hljs-comment">// All these attributes can be accessed using the casting of agents to map</span>
        write string(map(agent0));

        <span class="hljs-comment">//This access can be used everywhere, easing the use of shape files (and data files in general)</span>
        list&lt;geometry&gt; shapes &lt;- list&lt;geometry&gt;(file(<span class="hljs-string">"something.shp"</span>));

        <span class="hljs-comment">// If we suppose val1, val2, etc. are defined in the shape file</span>
        <span class="hljs-keyword">float</span> max &lt;- min(shapes collect <span class="hljs-keyword">float</span>(each[<span class="hljs-string">"val1"</span>]));

        <span class="hljs-comment">//To allow for an easier access in case the modeler only uses agents, agents' attributes can "pass through" towards their shape's attributes </span>
        <span class="hljs-comment">//(in case the same attribute has not been defined in the agent, of course)</span>
        create species0 <span class="hljs-string">from:</span> shapes;
        max &lt;- min(species0 collect <span class="hljs-keyword">float</span>(each[<span class="hljs-string">"val1"</span>])); <span class="hljs-comment">// equivalent to each.shape["val1"]. </span>
        <span class="hljs-comment">//This last sentence only works, however, for *reading* values.</span>
        any(species0)[<span class="hljs-string">"val1"</span>] &lt;- <span class="hljs-number">100</span>; <span class="hljs-comment">// will result in the creation of a new attribute in the agent (not in its shape)</span>
        any(species0).shape[<span class="hljs-string">"val1"</span>] &lt;- <span class="hljs-number">100</span>; <span class="hljs-comment">// will be correct in that case</span>

        <span class="hljs-comment">// Container variables have seen their usability clearly improved </span>
        map m &lt;- map([]);
        list&lt;<span class="hljs-keyword">int</span>&gt; l &lt;- [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];

        <span class="hljs-comment">// Adding a value</span>
        add <span class="hljs-number">1</span> <span class="hljs-string">to:</span> l;
        <span class="hljs-comment">// ... can now be written</span>
        l &lt;+ <span class="hljs-number">1</span>;

        <span class="hljs-comment">// Removing a value</span>
        remove <span class="hljs-number">1</span> <span class="hljs-string">from:</span> l;
        remove <span class="hljs-string">"type"</span> <span class="hljs-string">from:</span> geom;

        <span class="hljs-comment">// ... can now be written</span>
        l &gt;- <span class="hljs-number">1</span>;
        geom &gt;- <span class="hljs-string">"type"</span>;
        any(species0)[] &gt;- <span class="hljs-string">"name"</span>; <span class="hljs-comment">// removes the "name" attribute from a random agent. Can be dangerous in some cases... </span>

        <span class="hljs-comment">// Setting/putting a value</span>
        put <span class="hljs-string">"a"</span> <span class="hljs-string">at:</span> <span class="hljs-string">'key'</span> <span class="hljs-string">in:</span> m;
        put <span class="hljs-number">1</span> <span class="hljs-string">at:</span> <span class="hljs-number">0</span> <span class="hljs-string">in:</span> l;
        <span class="hljs-comment">// ... can now be written</span>
        m[<span class="hljs-string">'key'</span>] &lt;- <span class="hljs-string">"a"</span>;
        l[<span class="hljs-number">0</span>] &lt;- <span class="hljs-number">1</span>;
        list&lt;list&gt; ll &lt;- [];
        ll &lt;+ []; <span class="hljs-comment">// [[]]</span>
        ll[<span class="hljs-number">0</span>] &lt;+ <span class="hljs-number">10</span>; <span class="hljs-comment">// [[10]]</span>

    }

    <span class="hljs-comment">// TODO Species can now be written within the "global" section (to enforce the idea that the top-level species are indeed contained in the world)</span>
    species inside_global {
    }

    <span class="hljs-comment">/**
      * INVOCATION OF ACTIONS
      */</span>
    reflex calling_actions {
    <span class="hljs-comment">// IN IMPERATIVE MODE (i.e. in a statement)</span>
    <span class="hljs-comment">// The classic way</span>
        do dummy1 <span class="hljs-string">with:</span> [<span class="hljs-string">a:</span>:<span class="hljs-number">10</span>, <span class="hljs-string">b:</span>:<span class="hljs-number">100.0</span>];

        <span class="hljs-comment">// Another by distributing the arguments</span>
        do dummy1 <span class="hljs-string">a:</span> <span class="hljs-number">10</span> <span class="hljs-string">b:</span> <span class="hljs-number">100.0</span>;

        <span class="hljs-comment">// The new alternative one </span>
        do dummy1(<span class="hljs-string">a:</span> <span class="hljs-number">10</span>, <span class="hljs-string">b:</span> <span class="hljs-number">100.0</span>);
        ask any(species1) {
            do goto(<span class="hljs-string">target:</span> { <span class="hljs-number">10</span>, <span class="hljs-number">10</span> }, <span class="hljs-string">speed:</span> <span class="hljs-number">100</span>);
        }
        <span class="hljs-comment">// ... which has been introduced to unify the functional/imperative use of actions.</span>

        <span class="hljs-comment">// And finally the new functional way, probably reserved to simple calls (as all the arguments must be passed).</span>
        do dummy1(<span class="hljs-number">10</span>, <span class="hljs-number">100.0</span>);

        <span class="hljs-comment">// IN FUNCTIONAL MODE (i.e. as part of expressions)</span>
        <span class="hljs-comment">// The "classic" way of calling actions. Note that in that case, dummy1 is used like a binary operator (callee on the left, argument map on the right)</span>
        list d1 &lt;- self dummy1 [<span class="hljs-string">a:</span>:<span class="hljs-number">10</span>, <span class="hljs-string">b:</span>:<span class="hljs-number">100.0</span>];

        <span class="hljs-comment">// First improvement, argument maps can now be simplified, which results in a functional syntax with named arguments</span>
        list d2 &lt;- self dummy1 (<span class="hljs-string">b:</span> <span class="hljs-number">100.0</span>); <span class="hljs-comment">// a is not passed as it has a default value.</span>

        <span class="hljs-comment">// To improve the readability of this way of calling actions, the dotted notation is now allowed as well </span>
        list d3 &lt;- self.dummy1(<span class="hljs-string">a:</span> <span class="hljs-number">100</span>, <span class="hljs-string">b:</span> <span class="hljs-number">100.0</span>);
        <span class="hljs-keyword">float</span> s &lt;- any(species1).compute_speed_using_an_action(<span class="hljs-string">max:</span> <span class="hljs-number">100</span>);

        <span class="hljs-comment">// Finally, the functional syntax is also introduced. In that case, all the arguments need to be passed as they are not named.</span>
        <span class="hljs-comment">// This unifies the way of calling operators and actions furthermore. </span>

        <span class="hljs-comment">// The action can be called as a n_ary operator, and in that case, the callee is implicitely the agent that executes the call</span>
        list d4 &lt;- dummy1(<span class="hljs-number">10</span>, <span class="hljs-number">100.0</span>);

        <span class="hljs-comment">// And it can also be called using the "dotted" syntax, in which case the callee needs to be explicit (can be "self" of course)</span>
        path p &lt;- world.move(<span class="hljs-number">100</span>, <span class="hljs-number">45</span>, shape); <span class="hljs-comment">// speed, heading, bounds</span>


        <span class="hljs-comment">/**
         *  As a summary, the syntaxes kept for future developments of models will likely be: 
         */</span>

<span class="hljs-comment">// CALLING WITH NAMED ARGUMENTS + OPTIONAL DOTTED SYNTAX IN EXPRESSIONS + IMPLICIT CALLEE IN CASE OF SELF</span>
        <span class="hljs-comment">// This method is convenient as it allows to pass only some arguments (if defaults are defined, which is implicitely the case in primitives), </span>
        <span class="hljs-comment">// but also to pass them in any order</span>
        do wander(<span class="hljs-string">speed:</span> <span class="hljs-number">100</span>, <span class="hljs-string">amplitude:</span> <span class="hljs-number">10</span>);
        path p1 &lt;- path(self.wander(<span class="hljs-string">amplitude:</span> <span class="hljs-number">10</span>, <span class="hljs-string">speed:</span> <span class="hljs-number">100</span>));
        path p2 &lt;- path(self wander (<span class="hljs-string">speed:</span> <span class="hljs-number">100</span>, <span class="hljs-string">bounds:</span> square(<span class="hljs-number">10</span>)));
        path p3 &lt;- path(wander(<span class="hljs-string">speed:</span> <span class="hljs-number">100</span>));
        path p4 &lt;- path(wander());

        <span class="hljs-comment">// CALLING WITH COMPLETE ARGUMENTS + OPTIONAL DOTTED SYNTAX IN EXPRESSIONS + IMPLICIT CALLEE IN CASE OF SELF</span>
        <span class="hljs-comment">// This method is convenient as it follows the functional syntax of operators and then allows to declare "quasi-operators" in species, even to redefine existing ones.</span>
        do wander(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, self.shape); <span class="hljs-comment">// speed, amplitude, bounds as defined in primitive wander</span>
        <span class="hljs-keyword">int</span> d5 &lt;- self.max(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);
        <span class="hljs-keyword">int</span> d6 &lt;- self max (<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);
        <span class="hljs-keyword">int</span> d7 &lt;- max(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);
        list others &lt;- filter(species1);

        <span class="hljs-comment">// As a side note, the new syntax for arguments maps is not only usable in action calls, but also in create, for instance</span>
        create species0 <span class="hljs-string">with:</span> (<span class="hljs-string">location:</span> { <span class="hljs-number">100</span>, <span class="hljs-number">100</span> }, <span class="hljs-string">name:</span> <span class="hljs-string">""</span>);
    }

    <span class="hljs-comment">// The ternary operator "(condition) ? statement_if_condition_true : statement_if_condition_false" can be used as follow :</span>
    <span class="hljs-keyword">int</span> max (<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j) {
        <span class="hljs-keyword">return</span> i &gt; j ? i : j;
    }

    list&lt;agent&gt; filter (container&lt;agent&gt; my_agents) {
        <span class="hljs-keyword">return</span> my_agents where (each.location = nil);
    }

    <span class="hljs-comment">/**
      * USE OF OPERATORS 
      */</span>
    reflex operators {

    <span class="hljs-comment">// All the operators can now be written using a function-like form</span>
    <span class="hljs-comment">// It is true for unary operators (as before)</span>
        bool a &lt;- flip(<span class="hljs-number">0.4</span>);
        <span class="hljs-comment">// .. but also for binary ones (in addition to the classic way)</span>
        <span class="hljs-keyword">int</span> b &lt;- div(<span class="hljs-number">100</span>, <span class="hljs-number">23</span>) + <span class="hljs-number">100</span> div <span class="hljs-number">23</span>;
        geometry c1 &lt;- union(square(<span class="hljs-number">1</span>), circle(<span class="hljs-number">10</span>));
        <span class="hljs-comment">// The only exception to this rule is that of the built-in operators (like "and"/"or") and the ones whose names are not alphanumeric (like "+")</span>

        <span class="hljs-comment">// The big news is that operators are now allowed to be written using any number of parameters (not 1 or 2)</span>
        <span class="hljs-comment">// Here is an example with the "between" operator (written specially in Java to test this feature)</span>
        <span class="hljs-comment">// @operator(value = "between", can_be_const = true)</span>
        <span class="hljs-comment">// public static Boolean between(final Integer a, final Integer inf, final Integer sup) {</span>
        <span class="hljs-comment">//      if ( inf &gt; sup ) { return false; }</span>
        <span class="hljs-comment">//      return a &gt;= sup ? false : a &gt; inf; </span>
        <span class="hljs-comment">// }</span>
        bool e1 &lt;- between(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>);
    }
    <span class="hljs-comment">/**
      * DEFINITION OF ASPECTS
      */</span>
    aspect <span class="hljs-keyword">default</span> {
    <span class="hljs-comment">// draw now accepts any kind of arguments and decides what to do based on the type of the argument</span>
        draw circle(<span class="hljs-number">1</span>);
        draw name;
        draw file(<span class="hljs-string">"image.jpg"</span>);

        <span class="hljs-comment">// special units (that take a value in the drawing scope) have been introduced to allow for a better control of the display</span>
        <span class="hljs-comment">// This statement will draw a circle of radius 10 pixels, whatever the level of zoom and size of the display</span>
        draw circle(<span class="hljs-number">10</span> °px);
        draw <span class="hljs-string">"Display dimensions: "</span> + °display_width + <span class="hljs-string">" "</span> + °display_height;
    }

}

<span class="hljs-comment">/** Species can "mirror" a list of agents (or another species). That is, their population is dynamically computed after the list or species mirrored.
* Their instances, which are actually "proxy" agents, possess an attribute called "target" that points towards the agent they mirror. Very useful for building graphs, for instance.
* The update of the population tries to preserve, as much as possible, the existing mapping (that is, proxy agents do not change targets if they do not die or disappear from the list) */</span>
species species0 {
    <span class="hljs-keyword">float</span> speed &lt;- <span class="hljs-keyword">float</span>(rnd(<span class="hljs-number">1000</span>));
}

species species1 <span class="hljs-string">mirrors:</span> species0 <span class="hljs-string">skills:</span> [moving] {
    point location <span class="hljs-string">update:</span> target.location + { <span class="hljs-number">10</span>, <span class="hljs-number">10</span> };
    <span class="hljs-keyword">float</span> speed1 <span class="hljs-string">update:</span> self compute_speed_using_an_action (); <span class="hljs-comment">// No parameter as "max" is defaulted</span>
    <span class="hljs-keyword">float</span> speed2 <span class="hljs-string">update:</span> compute_speed_using_a_functional_attribute;
    <span class="hljs-keyword">float</span> compute_speed_using_a_functional_attribute {
        speed of target
    }
    <span class="hljs-keyword">float</span> compute_speed_using_an_action (<span class="hljs-keyword">int</span> max &lt;- <span class="hljs-number">100</span>) {
        <span class="hljs-keyword">return</span> min([max, <span class="hljs-keyword">int</span>(speed of target)]);
    }

    init {
        write <span class="hljs-string">"I am "</span> + self.name + <span class="hljs-string">" and my target is "</span> + target.name;
    }

}

grid my_grid <span class="hljs-string">width:</span> <span class="hljs-number">100</span> <span class="hljs-string">height:</span> <span class="hljs-number">100</span> {
}

experiment exp1 <span class="hljs-string">type:</span> gui {
    output {
        display Display <span class="hljs-string">type:</span> opengl {
        <span class="hljs-comment">// Layers include a new keyword, "graphics", that allows to draw arbitrary shapes using the syntax found in the aspects of species</span>
        <span class="hljs-comment">// The same capability will be soon added to species/agents layers (in order to define on-the-fly aspects without changing the species itself)</span>
            graphics <span class="hljs-string">'G'</span> {
                draw sphere(<span class="hljs-number">10</span>) <span class="hljs-string">at:</span> { <span class="hljs-number">50</span>, <span class="hljs-number">50</span> };
                <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
                    draw <span class="hljs-string">"true"</span>;
                } <span class="hljs-keyword">else</span> {
                    draw <span class="hljs-string">"false"</span>;
                }

            }

        }

    }

}
</code></pre>
<script>hljs.initHighlightingOnLoad();</script></body></html>