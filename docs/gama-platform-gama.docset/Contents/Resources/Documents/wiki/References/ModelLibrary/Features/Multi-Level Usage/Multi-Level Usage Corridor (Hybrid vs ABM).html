<html><!-- Online page at https://github.com/gama-platform/gama/wiki/References/ModelLibrary/Features/Multi-Level Usage/Multi-Level Usage Corridor (Hybrid vs ABM) --><head><meta charset="utf-8"><title>Multi Level Usage Corridor (Hybrid vs ABM)</title><script src="../../../../../dash_resources/highlight.all.js"></script><link rel="stylesheet" type="text/css" href="../../../../../dash_resources/github-markdown.css"><link rel="stylesheet" type="text/css" href="../../../../../dash_resources/highlightjs.github.css"></head><body class="markdown-body" style="padding-bottom:20px; margin: 8px 13px;"><h1 id="multi-level-usage-corridor-hybrid-vs-abm">Multi Level Usage Corridor (Hybrid vs ABM)</h1>
<h1 id="corridor-multi-level-architecture-with-mathematics-model-and-agent-based-model">Corridor Multi-Level Architecture with Mathematics Model and Agent Based Model</h1>
<p>_Author : _</p>
<p>This model shows how to use multi-level architecture. Two corridors are presented : one which can capture the pedestrians going through it and computing for them the time before releasing them at the end of the corridor, and an other doing nothing, letting the pedestrians moving by themselves in the corridor. </p>
<p>Code of the model : </p>
<pre><code class="hljs processing">
model pedestrian_corridor_Hybrid_vs_ABM

global 
{
    
    <span class="hljs-comment">//Parameters of the environment</span>
    <span class="hljs-built_in">int</span> environment_width &lt;- <span class="hljs-number">200</span> <span class="hljs-keyword">const</span>: <span class="hljs-keyword">true</span>;
    <span class="hljs-built_in">int</span> environment_height &lt;- <span class="hljs-number">200</span> <span class="hljs-keyword">const</span>: <span class="hljs-keyword">true</span>;
    geometry <span class="hljs-built_in">shape</span> &lt;- rectangle(environment_width, environment_height); 
    
    
    <span class="hljs-comment">//Parameters of the pedestrian agents</span>
    rgb pedestrian_green &lt;- #<span class="hljs-built_in">green</span>;
    
    <span class="hljs-built_in">float</span> pedestrian_size &lt;- <span class="hljs-number">1.0</span>;
    geometry pedestrian_shape &lt;- circle (pedestrian_size) ;
    <span class="hljs-built_in">float</span> pedestrian_speed &lt;- <span class="hljs-number">2.0</span>;
 
    <span class="hljs-comment">//Parameters of the corridors</span>
    rgb corridor_color &lt;- rgb (<span class="hljs-string">'blue'</span>);
    <span class="hljs-built_in">int</span> corridor_width &lt;- <span class="hljs-number">160</span> depends_on: [environment_width];
    <span class="hljs-built_in">int</span> corridor_height &lt;- (<span class="hljs-built_in">int</span>(environment_height * <span class="hljs-number">0.05</span>));

    <span class="hljs-built_in">point</span> corridor_location_0 &lt;- {environment_width / <span class="hljs-number">2</span>, environment_height / <span class="hljs-number">4</span>};
    geometry corridor_shape_0 &lt;- ( (rectangle ({corridor_width, corridor_height})) at_location corridor_location_0) ;

    <span class="hljs-built_in">point</span> corridor_location_1 &lt;- {environment_width / <span class="hljs-number">2</span>, environment_height * <span class="hljs-number">0.75</span>};
    geometry corridor_shape_1 &lt;- ( (rectangle ({corridor_width, corridor_height})) at_location corridor_location_1) ;

    <span class="hljs-comment">//Parameters of pedestrian generation</span>
    <span class="hljs-built_in">int</span> new_pedestian_generate_frequency &lt;- <span class="hljs-number">8</span>;
    <span class="hljs-built_in">point</span> pedestrian_source_0 &lt;- {<span class="hljs-number">0</span>, corridor_location_0.y} ;
    <span class="hljs-built_in">point</span> pedestrian_source_1 &lt;- {<span class="hljs-number">0</span>, corridor_location_1.y} ;
     
     
     
    init 
    {
        create corridor number: <span class="hljs-number">2</span> returns: new_corridors;
        
        ask (new_corridors at <span class="hljs-number">0</span>) 
        {
            do init_corridor corridor_shape: corridor_shape_0 is_hybrid: <span class="hljs-keyword">false</span>;
        }

        ask (new_corridors at <span class="hljs-number">1</span>) 
        {
            do init_corridor corridor_shape: corridor_shape_1 is_hybrid: <span class="hljs-keyword">true</span>; 
        }
    }

    <span class="hljs-comment">//Generation of pedestrians according to the frequency of generation : one for each corridor</span>
    reflex generate_pedestrians when: ( (cycle mod new_pedestian_generate_frequency) = <span class="hljs-number">0</span> ) 
    { 
        create pedestrian number: <span class="hljs-number">2</span> returns: new_pedestrians;
        
        ask (new_pedestrians at <span class="hljs-number">0</span>) 
        {
            do init_location loc: pedestrian_source_0;
        }
        
        ask (new_pedestrians at <span class="hljs-number">1</span>) 
        {
            do init_location loc: pedestrian_source_1;
        }
    }   
}


<span class="hljs-comment">//Species for the pedestrians which can move</span>
species pedestrian skills: [moving] {
    geometry <span class="hljs-built_in">shape</span> &lt;- circle(pedestrian_size);
    rgb <span class="hljs-built_in">color</span>;
    corridor last_corridor;
    <span class="hljs-built_in">point</span> target_location;
    <span class="hljs-built_in">float</span> speed &lt;- pedestrian_speed;
    
    <span class="hljs-comment">//Initialisation of the target location according to its generation location</span>
    action init_location (<span class="hljs-built_in">point</span> loc) {
        location &lt;- loc;
        target_location &lt;- {environment_width, location.y};
        heading &lt;- self towards (target_location);
    }

    <span class="hljs-comment">//Reflex to move the agent to its target location and make it die once it reached its target</span>
    reflex move_left 
    {
        do move heading: (self) towards (target_location); 
        
        <span class="hljs-keyword">if</span> ( (target_location.x - location.x) &lt;= speed ) 
        {
            do die;
        }
    }
     
    aspect <span class="hljs-keyword">default</span> 
    {
        <span class="hljs-title">draw</span> <span class="hljs-built_in">shape</span> <span class="hljs-built_in">color</span>: <span class="hljs-built_in">color</span>;
    }
}

<span class="hljs-comment">//Species for the corridor which can capture pedestrians</span>
species corridor  {
    bool capture_pedestrians;
    
    
    action init_corridor (geometry corridor_shape, bool is_hybrid) 
    {
        <span class="hljs-built_in">shape</span> &lt;- corridor_shape;
        capture_pedestrians &lt;- is_hybrid;
    }

    <span class="hljs-built_in">float</span> max_speed &lt;- pedestrian_speed;
    <span class="hljs-built_in">float</span> macro_length <span class="hljs-built_in">min</span>: <span class="hljs-number">0.0</span> &lt;- <span class="hljs-built_in">float</span>(corridor_width); <span class="hljs-comment">// the length of macro_patch</span>
    
    <span class="hljs-comment">//Species to model the pedestrian captured by the corridor</span>
    species captured_pedestrian parent: pedestrian schedules: [] 
    {
        <span class="hljs-built_in">float</span> released_time;  
        
        aspect <span class="hljs-keyword">default</span> { }
    }
    
    init 
    { 
        create corridor_info_drawer number: <span class="hljs-number">1</span> with: [target :: self];
    }
    <span class="hljs-comment">//Reflex to capture the pedestrians overlapping the corridor ie entering the corridor </span>
    reflex aggregate when: capture_pedestrians 
    {
        list&lt;pedestrian&gt; tobe_captured_pedestrians &lt;- (pedestrian overlapping <span class="hljs-built_in">shape</span>) where ( (each.last_corridor != self) and ((each.location).x &lt; (self.location).x) ) ; 
        
        <span class="hljs-keyword">if</span> !(empty (tobe_captured_pedestrians)) 
        {
            capture tobe_captured_pedestrians as: captured_pedestrian returns: cps { 
                last_corridor &lt;- myself;
            }
            <span class="hljs-keyword">if</span> !(empty (cps)) 
            {
                    <span class="hljs-comment">//Computation of the time when the pedestrians captured will be released according to the speed</span>
                    <span class="hljs-comment">// and the time they should make to pass the corridor if they move by themselves</span>
                    <span class="hljs-built_in">float</span> group_outgoing_time &lt;- time + (corridor_width / (pedestrian_speed) ); 
                    <span class="hljs-built_in">loop</span> cp over: cps 
                    {
                            cp.released_time &lt;- group_outgoing_time;
                    }
            }
        
        }
    }
    
    <span class="hljs-comment">//Reflex to release the pedestrians when we consider they were enough time inside the corridor </span>
    reflex disaggregate  
    {
        list tobe_released_pedestrians &lt;- members where (time &gt;= (captured_pedestrian (each)).released_time);
        
        <span class="hljs-keyword">if</span> !(empty (tobe_released_pedestrians)) 
        {
            
            release tobe_released_pedestrians as: pedestrian in: world returns: released_pedestrians;
            
            <span class="hljs-built_in">loop</span> rp over: released_pedestrians 
            {
                rp.speed &lt;- pedestrian_speed;
                rp.location &lt;- {((environment_width / <span class="hljs-number">2</span>) + (corridor_width / <span class="hljs-number">2</span>)), ((corridor_shape_1).location).y};
            }
        }
    }
        
    aspect <span class="hljs-keyword">default</span> 
    {
        <span class="hljs-title">draw</span> <span class="hljs-built_in">shape</span> <span class="hljs-built_in">color</span>: corridor_color;
    }
}
 
species corridor_info_drawer 
{
    corridor target;
    
    aspect base 
    {
        <span class="hljs-keyword">if</span> target.capture_pedestrians 
        {
            <span class="hljs-title">draw</span> <span class="hljs-string">'Hybrid model (coupling: ABM and Mathematical Model)'</span> <span class="hljs-built_in">color</span>: #<span class="hljs-built_in">blue</span> <span class="hljs-built_in">size</span>: <span class="hljs-number">7</span> at: {(target.location).x - <span class="hljs-number">90</span>, (target.location).y - <span class="hljs-number">10</span>};
            <span class="hljs-title">draw</span>  <span class="hljs-string">'Aggregated agents: '</span> + string(length(target.members)) <span class="hljs-built_in">color</span>: #black <span class="hljs-built_in">size</span>: <span class="hljs-number">7</span> at: {(target.location).x - <span class="hljs-number">30</span>, (target.location).y + <span class="hljs-number">2</span>};
        } 
        <span class="hljs-keyword">else</span> 
        {
            <span class="hljs-title">draw</span> <span class="hljs-string">'Agent-Based Model (ABM)'</span> <span class="hljs-built_in">color</span>: #<span class="hljs-built_in">blue</span> <span class="hljs-built_in">size</span>: <span class="hljs-number">7</span> at: {(target.location).x - <span class="hljs-number">40</span>, (target.location).y - <span class="hljs-number">10</span>};
        }
    }
}

experiment default_experiment type: gui 
{
    output 
    {
        display default_display 
        {
            species pedestrian;
            species corridor transparency: <span class="hljs-number">0.8</span>;
            species corridor_info_drawer aspect: base;
        }
    }
}
</code></pre>
<script>hljs.initHighlightingOnLoad();</script></body></html>