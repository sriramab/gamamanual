<html><!-- Online page at https://github.com/gama-platform/gama/wiki/References/ModelLibrary/Additionnal Plugins/Diffusion Statement/Diffusion Statement Blend color in a cuve (Multiple Signals) --><head><meta charset="utf-8"><title>Diffusion Statement Blend color in a cuve (Multiple Signals)</title><script src="../../../../../dash_resources/highlight.all.js"></script><link rel="stylesheet" type="text/css" href="../../../../../dash_resources/github-markdown.css"><link rel="stylesheet" type="text/css" href="../../../../../dash_resources/highlightjs.github.css"></head><body class="markdown-body" style="padding-bottom:20px; margin: 8px 13px;"><h1 id="diffusion-statement-blend-color-in-a-cuve-multiple-signals">Diffusion Statement Blend color in a cuve (Multiple Signals)</h1>
<h1 id="blend-color-in-a-cuve">Blend color in a cuve</h1>
<p><em>Author : Julien Mazars</em></p>
<p>This model is used to show how we can diffuse several variables in the same grid. At the cycle 0, 3 different pheromons are emited in 3 of the 4 corners of the cuve (each one associated to a color). Thanks to the diffusion mechanism, all the 3 colors will blend each other. The process is accelerated by using the facet "cycle_length". The "avoid_mask" facet is used in order to have a constant sum of pheromon. </p>
<p><img src="../../../../../github.com/wiki/gama-platform/gama/References/ModelLibrary/Additionnal Plugins/Diffusion Statement/gm_wiki/resources/images/modelLibraryScreenshots/Additionnal Plugins/Diffusion Statement/Diffusion Statement Blend color in a cuve (Multiple Signals)/a-10.png" alt="Eclipse folder." title="" class="img-responsive"> == $0</p><p>Code of the model : </p>
<pre><code class="hljs q">
model cycle_length

global {
    <span class="hljs-type">int</span> size &lt;- <span class="hljs-number">64</span>; <span class="hljs-comment">// better to have a pow of 2 for the size of the grid</span>
    <span class="hljs-type">int</span> cycle_length &lt;- <span class="hljs-number">5</span>;
    geometry shape &lt;- envelope(square(size));
    list&lt;cells&gt; top_left_cells;
    list&lt;cells&gt; top_right_cells;
    list&lt;cells&gt; bot_left_cells;
    <span class="hljs-comment">// Declare the uniform matrix</span>
    matrix&lt;float&gt; mat_diff &lt;- matrix([
                                    [<span class="hljs-number">1</span>/<span class="hljs-number">9</span>,<span class="hljs-number">1</span>/<span class="hljs-number">9</span>,<span class="hljs-number">1</span>/<span class="hljs-number">9</span>],
                                    [<span class="hljs-number">1</span>/<span class="hljs-number">9</span>,<span class="hljs-number">1</span>/<span class="hljs-number">9</span>,<span class="hljs-number">1</span>/<span class="hljs-number">9</span>],
                                    [<span class="hljs-number">1</span>/<span class="hljs-number">9</span>,<span class="hljs-number">1</span>/<span class="hljs-number">9</span>,<span class="hljs-number">1</span>/<span class="hljs-number">9</span>]]);

    <span class="hljs-comment">// Initialize the emiter cells</span>
    init {
        top_left_cells &lt;- list&lt;cells&gt;(cells <span class="hljs-built_in">where</span> (<span class="hljs-built_in">each</span>.grid_x &lt; location.x
            <span class="hljs-built_in">and</span> <span class="hljs-built_in">each</span>.grid_x &gt; cycle_length
            <span class="hljs-built_in">and</span> <span class="hljs-built_in">each</span>.grid_y &lt; location.y
            <span class="hljs-built_in">and</span> <span class="hljs-built_in">each</span>.grid_y &gt; cycle_length
        ));
        top_right_cells &lt;- list&lt;cells&gt;(cells <span class="hljs-built_in">where</span> (<span class="hljs-built_in">each</span>.grid_x &lt; size-cycle_length
            <span class="hljs-built_in">and</span> <span class="hljs-built_in">each</span>.grid_x &gt; location.x
            <span class="hljs-built_in">and</span> <span class="hljs-built_in">each</span>.grid_y &lt; location.y
            <span class="hljs-built_in">and</span> <span class="hljs-built_in">each</span>.grid_y &gt; cycle_length
        ));
        bot_left_cells &lt;- list&lt;cells&gt;(cells <span class="hljs-built_in">where</span> (<span class="hljs-built_in">each</span>.grid_x &lt; location.x
            <span class="hljs-built_in">and</span> <span class="hljs-built_in">each</span>.grid_x &gt; cycle_length
            <span class="hljs-built_in">and</span> <span class="hljs-built_in">each</span>.grid_y &lt; size-cycle_length
            <span class="hljs-built_in">and</span> <span class="hljs-built_in">each</span>.grid_y &gt; location.y
        ));
    }
    reflex init_value when:cycle=<span class="hljs-number">0</span> {
        ask(top_left_cells){
            phero1 &lt;- <span class="hljs-number">1.0</span>;
        }
        ask(top_right_cells){
            phero2 &lt;- <span class="hljs-number">1.0</span>;
        }
        ask(bot_left_cells){
            phero3 &lt;- <span class="hljs-number">1.0</span>;
        }   
    }

    reflex diff {
        <span class="hljs-comment">// Declare a diffusion on the grid "cells" for each one of the pheromons. </span>
        <span class="hljs-comment">// In order to not loosing phero value, we apply a hand made mask (with the operator "where") and we turn the "avoid_mask" facet to true.</span>
        list cells_where_diffuse &lt;- cells <span class="hljs-built_in">where</span> (<span class="hljs-built_in">each</span>.grid_x &lt; size-cycle_length <span class="hljs-built_in">and</span> <span class="hljs-built_in">each</span>.grid_x &gt; cycle_length <span class="hljs-built_in">and</span> <span class="hljs-built_in">each</span>.grid_y &lt; size-cycle_length <span class="hljs-built_in">and</span> <span class="hljs-built_in">each</span>.grid_y &gt; cycle_length);
        diffuse <span class="hljs-built_in">var</span>: phero1 on: cells_where_diffuse matrix: mat_diff avoid_mask: true method:dot_product cycle_length:cycle_length;
        diffuse <span class="hljs-built_in">var</span>: phero2 on: cells_where_diffuse matrix: mat_diff avoid_mask: true method:dot_product cycle_length:cycle_length;
        diffuse <span class="hljs-built_in">var</span>: phero3 on: cells_where_diffuse matrix: mat_diff avoid_mask: true method:dot_product cycle_length:cycle_length;
    }
}


grid cells height: size width: size {
    <span class="hljs-comment">// "phero1", "phero2", "phero3" are the variables storing the value of the diffusion</span>
    float phero1  &lt;- <span class="hljs-number">0.0</span>;
    float phero2  &lt;- <span class="hljs-number">0.0</span>;
    float phero3  &lt;- <span class="hljs-number">0.0</span>;
    <span class="hljs-comment">// The color of the cell is construct using the 3 pheromons.</span>
    rgb color &lt;- rgb(phero1*<span class="hljs-number">256</span>,phero2*<span class="hljs-number">256</span>,phero3*<span class="hljs-number">256</span>) <span class="hljs-keyword">update</span>: rgb(phero1*<span class="hljs-number">256</span>,phero2*<span class="hljs-number">256</span>,phero3*<span class="hljs-number">256</span>);
} 


experiment diffusion <span class="hljs-built_in">type</span>: gui {
    output {
        display a <span class="hljs-built_in">type</span>: opengl {
            <span class="hljs-comment">// Display the grid with elevation</span>
            grid cells elevation: (phero1+phero2+phero3)*<span class="hljs-number">10</span> triangulation: true;
        }
    }
}
</code></pre>
<script>hljs.initHighlightingOnLoad();</script></body></html>