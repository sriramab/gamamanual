<html><!-- Online page at https://github.com/gama-platform/gama/wiki/GoldMinerModel_step2 --><head><meta charset="utf-8"><title>GoldMinerModel_step2</title><script src="../dash_resources/highlight.all.js"></script><link rel="stylesheet" type="text/css" href="../dash_resources/github-markdown.css"><link rel="stylesheet" type="text/css" href="../dash_resources/highlightjs.github.css"></head><body class="markdown-body" style="padding-bottom:20px; margin: 8px 13px;"><h1 id="goldminermodel_step2">GoldMinerModel_step2</h1>
<a class="dashAnchor" name="//apple_ref/Section/2.%20BDI%20Agents"></a><h1 id="2-bdi-agents">2. BDI Agents</h1>
<p>This second step consists in defining the gold miner agents using the GAMA BDI architecture.</p>
<a class="dashAnchor" name="//apple_ref/Section/Formulation"></a><h2 id="formulation">Formulation</h2>
<ul>
<li>Definition of global predicates
<ul>
<li>Definition of the gold miner species</li>
<li>Definition of the gold miner perceptions</li>
<li>Definition of the gold miner rules</li>
<li>Definition of the gold miner plans</li>
<li>Creation and display of the gold miners</li>
</ul>
</li>
</ul>
<a class="dashAnchor" name="//apple_ref/Section/BDI%20agents"></a><h2 id="bdi-agents">BDI agents</h2>
<p>A classic paradigm to formalize the internal architecture of cognitive agents in Agent-Oriented Software Engineering is the BDI (Belief-Desire-Intention) paradigm. This paradigm, based on the philosophy of action <a href="https://philpapers.org/rec/braipa">(Bratman, 1987)</a>, allows to design expressive and realistic agents. </p>
<p>The concepts of Belief-Desire-Intention can be summarized as follow for the the Gold Miner: the Miner agent has a general desire to find gold. As it is the only thing it wants at the beginning, it is its initial intention (what it is currently doing). To find gold, it wanders around (its plan is to wander). When it perceives some gold nuggets, it stores this information (it has a new belief about the existence and location of this gold nugget), and it adopts a new desire (it wants to extract the gold). When it perceives a gold nugget, the intention to find gold is put on hold and a new intention is selected (to extract gold). To achieve this intention, the plan has two steps, i.e. two new (sub)intentions: to choose a gold nugget to extract (among its known gold nuggets) and to go and take it. And so on.</p>
<p>In GAMA, we propose a control architecture for agents based on this paradigm. This control architecture provides the agents with 3 database linked to the agent cognition:</p>
<ul>
<li><strong>belief_base</strong> (what it knows): the internal knowledge the agent has about the world or about its internal state, updated during the simulation. A belief can concern any type of information (a quantity, a location, a boolean value, etc).</li>
<li><strong>desire_base</strong> (what it wants): objectives that the agent would like to accomplish, also updated during the simulation. Desires can have hierarchical links (sub/super desires) when a desire is created as an intermediary objective.</li>
<li><strong>intention_base</strong> (what it is doing): what the agent has chosen to do. The current intention will determine the selected plan. Intentions can be put on hold (for example when they require a sub-intention to be achieved).</li>
</ul>
<p>In addition, the BDI architecture provides agents with three types of behavior structures</p>
<ul>
<li><strong>Perception</strong>: a perception is a function executed at each iteration to update the agent’s Belief base, to know the changes in its environment (the world, the other agents and itself). The agent can perceive other agents up to a fixed distance or inside a specific geometry. </li>
<li><strong>Rule</strong>: a rule is a function executed at each iteration to infer new desires or beliefs from the agent’s current beliefs and desires, i.e. a new desire or belief can emerge from the existing ones. </li>
<li><strong>Plan</strong>: the agent has a set of plans, which are behaviors defined to accomplish specific intentions. Plans can be instantaneous and/or persistent, and may have a priority value (that can be dynamic), used to select a plan when several possible plans are available to accomplish the same intention.</li>
</ul>
<p>To be more precise on the behavior of BDI agents (what the agent is going to do when activated), this one is composed of 10 steps (see <a href="https://hal.archives-ouvertes.fr/hal-01216165/document">(Caillou et al., 2017)</a> and <a href="https://hal.archives-ouvertes.fr/hal-01391002/document">(Taillandier et al., 2016)</a> for more details):</p>
<ol>
<li><em>Perceive</em>: Perceptions are executed.</li>
<li><em>Rule</em>: Rules are executed.</li>
<li><em>Is one of my intentions achieved?</em>: If one of my intentions is achieved, sets the current plan to nil and removes the intention from the intention base. If the achieved intention’s super-intention is on hold, it is reactivated (its sub-intention just got completed).</li>
<li><em>Do I keep the current intention?</em>: To take into account the environment instability, an intention-persistence coefficient is applied: with this probability, the current intention is removed from the intention stack. </li>
<li><em>Do I have a current plan?</em>: If I have a current plan, just execute it. Similarly to intentions, a plan-persistence coefficient is defined: with this probability, the current plan is just dropped.</li>
<li><em>Choose a desire as new current intention</em>: If the current intention is on hold (or the intention base is empty), choose a desire as new current intention. The new selected intention is the desire with higher priority.</li>
<li><em>Choose a plan as a new current plan</em>: The new current plan is selected among the plans compatible with the current intention (and if their activation condition is checked) and with the highest priority.</li>
<li><em>Execute the plan</em>: The current plan is executed.</li>
<li><em>Is my plan finished?</em>: To allow persistent plans, a plan may have a termination condition. If it is not reached, the same plan will be kept for the next iteration.</li>
<li><em>Was my plan instantaneous?</em>: Most agent based simulation frameworks (GAMA included) are synchronous frameworks using steps. One consequence is that it may be useful to apply several plans during one single step. For example, if a step represents a day or a year, it would be unrealistic for an agent to spend one step to apply a plan like "choose a destination". This kind of plans (mostly reasoning plans) can be defined as instantaneous: in this case a new thinking loop is applied during the same agent step.</li>
</ol>
<p>The architecture introduces two new main types of variables related to cognition: </p>
<ul>
<li><p><strong>predicate</strong>: a predicate unifies the representation of the information about the world. It can represent a situation, an event or an action. </p>
</li>
<li><p><strong>mental_state</strong>: it represents the element (belief, desire, intention) manipulated by the agent and the architecture to take a decision. A mental state is composed of a modality, a predicate or another mental state, a real value and a lifetime. The modality indicates the type of the mental state (e.g. a belief or a desire), the predicate indicates the fact about which is this mental state (a mental state can also be about another mental state like a belief about a belief, etc), the value has a different interpretation depending on the modality and finally, the lifetime indicate the duration of the mental state (it can be infinite).</p>
</li>
</ul>
<a class="dashAnchor" name="//apple_ref/Section/Model%20Definition"></a><h2 id="model-definition">Model Definition</h2>
<a class="dashAnchor" name="//apple_ref/Section/predicates"></a><h3 id="predicates">predicates</h3>
<p>As a first step of the integration of the BDI agents in our model, we define a set of global predicate that will represent all the information that will be manipulated by the miner agents:</p>
<ul>
<li><em>mine_location</em>: represents the information about the location of a gold mine.</li>
<li><em>choose_goldmine</em>: represents the information that the miner wants to choose a gold mine.</li>
<li><em>has_gold</em>: represents the information that the miner has a gold nugget.</li>
<li><em>find_gold</em>: represents the information that the miner wants to find gold.</li>
<li><em>sell_gold</em>: represents the information that the miner wants to sell gold.</li>
</ul>
<p>We define as well two global string (<em>mine_at_location</em> and <em>empty_mine_location</em>) for simplification purpose and to avoid misspellings.</p>
<pre><code class="hljs mipsasm">global {
        ...
    string mine_at_location &lt;- <span class="hljs-string"><span class="hljs-string">"mine_at_location"</span></span><span class="hljs-comment"><span class="hljs-comment">;</span></span>
    string empty_mine_location &lt;- <span class="hljs-string"><span class="hljs-string">"empty_mine_location"</span></span><span class="hljs-comment"><span class="hljs-comment">;</span></span>
    
    predicate mine_location &lt;- new_predicate(mine_at_location) <span class="hljs-comment"><span class="hljs-comment">;</span></span>
    predicate choose_goldmine &lt;- new_predicate(<span class="hljs-string"><span class="hljs-string">"choose a gold mine"</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span>
    predicate has_gold &lt;- new_predicate(<span class="hljs-string"><span class="hljs-string">"extract gold"</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span>
    predicate find_gold &lt;- new_predicate(<span class="hljs-string"><span class="hljs-string">"find gold"</span></span>) <span class="hljs-comment"><span class="hljs-comment">;</span></span>
    predicate sell_gold &lt;- new_predicate(<span class="hljs-string"><span class="hljs-string">"sell gold"</span></span>) <span class="hljs-comment"><span class="hljs-comment">;</span></span>
        ...
}
</code></pre>
<a class="dashAnchor" name="//apple_ref/Section/skeleton%20of%20the%20miner%20species"></a><h3 id="skeleton-of-the-miner-species">skeleton of the miner species</h3>
<p>We then define a miner species with the <em>moving</em> skill and the <em>simple_bdi</em> control architecture. The miner agents have 5 variables:</p>
<ul>
<li><em>viewdist</em>: distance of perception of the miner agent</li>
<li><em>speed</em>: speed of the agent</li>
<li><em>mycolor</em>: the color of the agent (random color)</li>
<li><em>target</em>: where the agent wants to go</li>
<li><em>gold_sold</em>: the number of gold nuggets sold by the agent</li>
</ul>
<p>We define the init block of the species such as to add at the creation of the agent the desire to find gold nuggets (<em>find_gold</em> predicate). we use for that the <em>add_desire</em> action provides with the BDI architecture.</p>
<p>At last, we define an aspect in which we draw the agent with its <em>mycolor</em> color and with a depth that depends on the number of gold nuggets collected.</p>
<pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">species</span></span> miner skills: [moving] control:simple_bdi {
    <span class="hljs-attribute"><span class="hljs-attribute">float</span></span> viewdist&lt;-<span class="hljs-number"><span class="hljs-number">1000</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>;
    <span class="hljs-attribute"><span class="hljs-attribute">float</span></span> speed &lt;- <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-comment"><span class="hljs-comment">#km/#h;</span></span>
    rgb mycolor&lt;-rnd_color(<span class="hljs-number"><span class="hljs-number">255</span></span>);
    <span class="hljs-attribute"><span class="hljs-attribute">point</span></span> target;
    <span class="hljs-attribute"><span class="hljs-attribute">int</span></span> gold_sold;
    
    <span class="hljs-section"><span class="hljs-section">init</span></span>
    {
        <span class="hljs-attribute"><span class="hljs-attribute">do</span></span> add_desire(find_gold);
    }
    <span class="hljs-attribute"><span class="hljs-attribute">aspect</span></span> default {
            <span class="hljs-attribute"><span class="hljs-attribute">draw</span></span> circle(<span class="hljs-number"><span class="hljs-number">200</span></span>) color: mycolor border: <span class="hljs-comment"><span class="hljs-comment">#black depth: gold_sold;</span></span>
    }
}
</code></pre>
<a class="dashAnchor" name="//apple_ref/Section/perception"></a><h3 id="perception">perception</h3>
<p>We add a <em>perceive</em> statement for the miner agents. This perceive will allow to detect the gold mine that are not empty (i.e. the quantity of gold is higher than 0) at a distance lower or equal to "viewdist". The use of the <em>focus</em> statement allows to add for each detected goldmine a belief corresponding to the location of this goldmine. The name of the belief will be "mine_at_location" and the location value of the goldmine will be stored in the <em>values</em> (a map) variable of the belief at the key "location_value". 
In addition, we ask the miner agent to remove the intention to find gold, allowing the agent to choose a new intention. The boolean value of the <em>remove_intention</em> action is used to specify if the agent should or not remove the given intention from the desire base as well. In our case, we choose to keep the desire to find golds.</p>
<pre><code class="hljs groovy">species miner <span class="hljs-string"><span class="hljs-string">skills:</span></span> [moving] <span class="hljs-string"><span class="hljs-string">control:</span></span>simple_bdi {
    ... 
    perceive <span class="hljs-string"><span class="hljs-string">target:</span></span>goldmine where (each.quantity &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-string"><span class="hljs-string">in:</span></span>viewdist {
        focus <span class="hljs-string"><span class="hljs-string">id:</span></span>mine_at_location <span class="hljs-string"><span class="hljs-string">var:</span></span>location;
        ask myself {
            do remove_intention(find_gold, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);
        }
    }
}
</code></pre>
<p>Note that the perceive statement works as the ask statement: the instructions written in the statement are executed in the context of the perceive agents. It is for that that we have to use the <em>myself</em> keyword to ask the miner agent to execute the <em>remove_intention</em> action.</p>
<a class="dashAnchor" name="//apple_ref/Section/rules"></a><h3 id="rules">rules</h3>
<p>We define two rules for the miner agents:</p>
<ul>
<li>if the agent believes that there is somewhere at least one gold mine with gold nuggets, the agent gets the new desire to has a gold nugget with a strength of 2. </li>
<li>if the agent believes that it has a gold nugget, the agent gets the new desire to sell the gold nugget with a strength of 3. </li>
</ul>
<pre><code class="hljs groovy">species miner <span class="hljs-string"><span class="hljs-string">skills:</span></span> [moving] <span class="hljs-string"><span class="hljs-string">control:</span></span>simple_bdi {
    ...
    rule <span class="hljs-string"><span class="hljs-string">belief:</span></span> mine_location <span class="hljs-string"><span class="hljs-string">new_desire:</span></span> has_gold <span class="hljs-string"><span class="hljs-string">strength:</span></span> <span class="hljs-number"><span class="hljs-number">2.0</span></span>;
    rule <span class="hljs-string"><span class="hljs-string">belief:</span></span> has_gold <span class="hljs-string"><span class="hljs-string">new_desire:</span></span> sell_gold <span class="hljs-string"><span class="hljs-string">strength:</span></span> <span class="hljs-number"><span class="hljs-number">3.0</span></span>;
}
</code></pre>
<p>The strength of a desire will be used when selecting a desire as a new intention: the agent will choose as new intention the one with the highest strength. In our model, if the agent has the desires to find gold, to has gold and to sell gold, it will choose as intention to sell gold as it is the one with the highest strength. It is possible to replace this deterministic choice by a probabilistic one by setting the <em>probabilistic_choice</em> built-in varibale of the BDI agent to true (false by default).</p>
<a class="dashAnchor" name="//apple_ref/Section/plans"></a><h3 id="plans">plans</h3>
<p>The last (and most important) part of the definition of BDI agents consist in defining the plans that the agents can carry out to acheive its intention. </p>
<p>The first plan called <em>letsWander</em> is defined to achieve the <em>find_gold</em> intention. This plan will just consists in executing the <em>wander</em> action of the <em>moving</em> skill (random move).</p>
<pre><code class="hljs less"><span class="hljs-selector-tag"><span class="hljs-selector-tag">species</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">miner</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">skills</span></span>: <span class="hljs-selector-attr"><span class="hljs-selector-attr">[moving]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">control</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:simple_bdi</span></span> {
        ...
        <span class="hljs-selector-tag"><span class="hljs-selector-tag">plan</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">letsWander</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">intention</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:find_gold</span></span> 
    {
        do wander;
    }
       ...
}
</code></pre>
<p>The second plan called <em>getGold</em> is defined to achieve the <em>has_gold</em> intention. if the agent has no target (it does not know where to go), it adds a new sub-intention to choose a goldmine and put the current intention on hold (the agent will wait to select a gold mine to go before executing again this plan). The <em>add_subintention</em> has 3 arguments: the sub-intention (choose_goldmine), the super intention (extract_gold) and a boolean that defines if the sub-intention should or not be added as well as a desire.
If the agent has already a target, it moves toward this target using the <em>goto</em> action of the <em>moving</em> skill. If the agent reaches its target - goldmine - (target = location), the agent tries to extract gold nuggets from it. If the corresponding goldmine (that one located at the target location) is not empty, the agent extract a gold nugget from it: the agent adds the belief that it has a gold nugget, then the quantity of golds in the gold mine is reduced. Otherwise, if the gold mine is empty, the agent adds the belief that this gold mine is empty. then the target is set to nil.</p>
<pre><code class="hljs irpf90">species miner skills: [moving] control:simple_bdi {
        ...
        plan getGold intention:has_gold
    {
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">target</span></span> = nil) {
            <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> add_subintention(has_gold,choose_goldmine, true);
            <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> current_intention_on_hold();
        } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {
            <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">target</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">target</span></span> ;
            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">target</span></span> = location)  {
                goldmine current_mine&lt;- goldmine first_with (<span class="hljs-keyword"><span class="hljs-keyword">target</span></span> = each.location);
                <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current_mine.quantity &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> {
                    <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> add_belief(has_gold);
                    ask current_mine {quantity &lt;- quantity - <span class="hljs-number"><span class="hljs-number">1</span></span>;}    
                } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {
                    <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> add_belief(new_predicate(empty_mine_location, [<span class="hljs-string"><span class="hljs-string">"location_value"</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">target</span></span>]));
                }
                <span class="hljs-keyword"><span class="hljs-keyword">target</span></span> &lt;- nil;
            }
        }   
    }
       ...
}
</code></pre>
<p>The third plan called <em>choose_closest_goldmine</em> is defined to achieve the <em>choose_goldmine</em> intention that is instantaneous. First, the agent defines the list of all the gold mines it knows (<em>mine_at_location</em> beliefs), then removes the gold mines that it knows that they are empty (<em>empty_mine_location</em> beliefs). If the list of the possible mines is empty, the agent removes the desire and the intention to <em>extract_gold</em>. We use for that the <em>remove_intention</em> action, that removes an intention from the intention base; the second argument allows to define if the intention should be removed as well from the desire base. If the agent knows at least one gold mine that is not empty, it defines as its new target the closest gold mine.</p>
<pre><code class="hljs cpp">species miner skills: [moving] control:simple_bdi {
        ...
        plan choose_closest_goldmine intention: choose_goldmine instantaneous: <span class="hljs-literal"><span class="hljs-literal">true</span></span>{
        <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;point&gt; possible_mines &lt;- get_beliefs_with_name(mine_at_location) collect (point(get_predicate(mental_state (each)).values[<span class="hljs-string"><span class="hljs-string">"location_value"</span></span>]));
        <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;point&gt; empty_mines &lt;- get_beliefs_with_name(empty_mine_location) collect (point(get_predicate(mental_state (each)).values[<span class="hljs-string"><span class="hljs-string">"location_value"</span></span>]));
        possible_mines &lt;- possible_mines - empty_mines;
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (empty(possible_mines)) {
            <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove_intention</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(extract_gold, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; 
        } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {
            target &lt;- (possible_mines with_min_of (each distance_to self)).location;
        }
        <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove_intention</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(choose_goldmine, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; 
    }
       ...
}
</code></pre>
<p>The last plan called <em>return_to_base</em> is defined to achieve the <em>sell_gold</em> intention. The agent moves in direction of the market using the <em>goto</em> action. if the agent reaches the market, it sells its gold nugget to it: first, it removes the belief that it has a gold nugget, then it removes the intention and the desire to sell golds, at last it increments its <em>gold_sold</em> variable. </p>
<pre><code class="hljs sqf">species miner skills: [moving] control:simple_bdi {
        ...
        plan return_to_base intention: sell_gold {
        <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">goto</span></span> target: the_market ;
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (the_market.<span class="hljs-built_in"><span class="hljs-built_in">location</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">location</span></span>)  {
            <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> remove_belief(has_gold);
            <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> remove_intention(sell_gold, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);
            gold_sold &lt;- gold_sold + <span class="hljs-number"><span class="hljs-number">1</span></span>;
        }
    }
       ...
}
</code></pre>
<a class="dashAnchor" name="//apple_ref/Section/Gobal%20section"></a><h2 id="gobal-section">Gobal section</h2>
<p>We define two new global variables:</p>
<ul>
<li><em>nbminer</em>: number of gold miners</li>
<li><em>inequality</em>: recomputed at each simulation step: standard deviation of the number of gold nuggets extracted per miners.</li>
</ul>
<p>In the global init, after creating the gold mines and the market, we create the gold miner agents.</p>
<p>At last, we define a global reflex <em>end_simulation</em> that is activated when all the gold mines are empty and no more miner has a gold nuggets and that pauses the simulation.</p>
<pre><code class="hljs x86asm"><span class="hljs-meta"><span class="hljs-meta">global</span></span> {
    ...
    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nbminer&lt;-<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-comment"><span class="hljs-comment">;</span></span>
    <span class="hljs-meta"><span class="hljs-meta">float</span></span> inequality &lt;- <span class="hljs-number"><span class="hljs-number">0.0</span></span> update:standard_deviation(miner collect <span class="hljs-number"><span class="hljs-number">each</span></span>.gold_sold)<span class="hljs-comment"><span class="hljs-comment">;</span></span>
    ...
        init
    {
        ...
        create miner number:nbminer<span class="hljs-comment"><span class="hljs-comment">;</span></span>
    }
    
    reflex end_simulation when: sum(goldmine collect <span class="hljs-number"><span class="hljs-number">each</span></span>.quantity) = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> empty(miner where <span class="hljs-number"><span class="hljs-number">each</span></span>.has_belief(has_gold)){
        <span class="hljs-built_in"><span class="hljs-built_in">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pause</span></span><span class="hljs-comment"><span class="hljs-comment">;</span></span>
    }
}
</code></pre>
<a class="dashAnchor" name="//apple_ref/Section/Map%20display"></a><h2 id="map-display">Map display</h2>
<p>We add to the map display the miner species.</p>
<pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">experiment</span></span> GoldBdi type: gui {

    <span class="hljs-section"><span class="hljs-section">output</span></span> {
        <span class="hljs-attribute"><span class="hljs-attribute">display</span></span> map type: opengl
        {
            <span class="hljs-attribute"><span class="hljs-attribute">species</span></span> market ;
            <span class="hljs-attribute"><span class="hljs-attribute">species</span></span> goldmine ;
            <span class="hljs-attribute"><span class="hljs-attribute">species</span></span> miner;
        }
    }
}
</code></pre>
<a class="dashAnchor" name="//apple_ref/Section/Complete%20Model"></a><h2 id="complete-model">Complete Model</h2>
<pre><code class="hljs cs">model GoldBdi

global {
    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nb_mines &lt;- <span class="hljs-number"><span class="hljs-number">10</span></span>; 
    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nbminer&lt;<span class="hljs-number"><span class="hljs-number">-5</span></span>;
    market the_market;
    
    <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> mine_at_location &lt;- <span class="hljs-string"><span class="hljs-string">"mine_at_location"</span></span>;
    <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> empty_mine_location &lt;- <span class="hljs-string"><span class="hljs-string">"empty_mine_location"</span></span>;
    
    <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> step &lt;- <span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-meta"><span class="hljs-meta">#mn;</span></span>
    
    <span class="hljs-comment"><span class="hljs-comment">//possible predicates concerning miners</span></span>
    predicate mine_location &lt;- new_predicate(mine_at_location) ;
    predicate choose_goldmine &lt;- new_predicate(<span class="hljs-string"><span class="hljs-string">"choose a gold mine"</span></span>);
    predicate has_gold &lt;- new_predicate(<span class="hljs-string"><span class="hljs-string">"extract gold"</span></span>);
    predicate find_gold &lt;- new_predicate(<span class="hljs-string"><span class="hljs-string">"find gold"</span></span>) ;
    predicate sell_gold &lt;- new_predicate(<span class="hljs-string"><span class="hljs-string">"sell gold"</span></span>) ;
    
    
    
    <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> inequality &lt;- <span class="hljs-number"><span class="hljs-number">0.0</span></span> update:standard_deviation(miner collect each.gold_sold);
    
    geometry shape &lt;- square(<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-meta"><span class="hljs-meta">#km);</span></span>
    
    init
    {
        create market {
            the_market &lt;- self; 
        }
        create goldmine number:nb_mines;
        create miner number:nbminer;
    }
    
    reflex end_simulation <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>: sum(goldmine collect each.quantity) = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-function">and </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">miner </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">where</span></span></span></span><span class="hljs-function"><span class="hljs-params"> each.has_belief(has_gold</span></span></span><span class="hljs-function">))</span></span>{
        <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> pause;
    }
}

species goldmine {
    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> quantity &lt;- rnd(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>);
    aspect <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>
    {
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (quantity = <span class="hljs-number"><span class="hljs-number">0</span></span>) {
            <span class="hljs-function"><span class="hljs-function">draw </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">triangle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">200</span></span></span></span></span><span class="hljs-function">) color: #gray border: #black</span></span>; 
        } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {
            <span class="hljs-function"><span class="hljs-function">draw </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">triangle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">200</span></span></span></span><span class="hljs-function"><span class="hljs-params"> + quantity*</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">50</span></span></span></span></span><span class="hljs-function">) color: #yellow border: #black</span></span>; 
        }
     
    }
}

species market {
    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> golds;
    aspect <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>
    {
      <span class="hljs-function"><span class="hljs-function">draw </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">square</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1000</span></span></span></span></span><span class="hljs-function">) color: #black </span></span>;
    }
}

species miner skills: [moving] control:simple_bdi {
    
    <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> viewdist&lt;<span class="hljs-number"><span class="hljs-number">-1000.0</span></span>;
    <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed &lt;- <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-meta"><span class="hljs-meta">#km/#h;</span></span>
    rgb mycolor&lt;-rnd_color(<span class="hljs-number"><span class="hljs-number">255</span></span>);
    point target;
    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> gold_sold;
    
    init
    {
        <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_desire</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">find_gold</span></span></span><span class="hljs-function">)</span></span>;
    }
        
    perceive target:<span class="hljs-function"><span class="hljs-function">goldmine </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">where</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">each.quantity &gt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function">:viewdist </span></span>{
        focus id:mine_at_location <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>:location;
        ask myself {
            <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove_intention</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">find_gold, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span>;
        }
    }
    rule belief: mine_location new_desire: has_gold strength: <span class="hljs-number"><span class="hljs-number">2.0</span></span>;
    rule belief: has_gold new_desire: sell_gold strength: <span class="hljs-number"><span class="hljs-number">3.0</span></span>;
    
        
    plan letsWander intention:find_gold 
    {
        <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> wander;
    }
    
    plan getGold intention:has_gold 
    {
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target = nil) {
            <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_subintention</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">has_gold,choose_goldmine, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span></span><span class="hljs-function">)</span></span>;
            <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">current_intention_on_hold</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>;
        } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {
            <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> target: target ;
            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target = location)  {
                goldmine current_mine&lt;- <span class="hljs-function"><span class="hljs-function">goldmine </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first_with</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target = each.location</span></span></span><span class="hljs-function">)</span></span>;
                <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current_mine.quantity &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> {
                    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_belief</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">has_gold</span></span></span><span class="hljs-function">)</span></span>;
                    ask current_mine {quantity &lt;- quantity - <span class="hljs-number"><span class="hljs-number">1</span></span>;}    
                } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {
                    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_belief</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new_predicate(empty_mine_location, [</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"location_value"</span></span></span></span><span class="hljs-function"><span class="hljs-params">::target]</span></span></span><span class="hljs-function">))</span></span>;
                }
                target &lt;- nil;
            }
        }   
    }
    
    plan choose_closest_goldmine intention: choose_goldmine instantaneous: <span class="hljs-literal"><span class="hljs-literal">true</span></span>{
        list&lt;point&gt; possible_mines &lt;- get_beliefs_with_name(mine_at_location) collect (point(get_predicate(mental_state (each)).values[<span class="hljs-string"><span class="hljs-string">"location_value"</span></span>]));
        list&lt;point&gt; empty_mines &lt;- get_beliefs_with_name(empty_mine_location) collect (point(get_predicate(mental_state (each)).values[<span class="hljs-string"><span class="hljs-string">"location_value"</span></span>]));
        possible_mines &lt;- possible_mines - empty_mines;
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (empty(possible_mines)) {
            <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove_intention</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">has_gold, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span></span><span class="hljs-function">)</span></span>; 
        } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {
            target &lt;- (<span class="hljs-function"><span class="hljs-function">possible_mines </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">with_min_of</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">each distance_to self</span></span></span><span class="hljs-function">)).location</span></span>;
        }
        <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove_intention</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">choose_goldmine, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span></span><span class="hljs-function">)</span></span>; 
    }
    
    plan return_to_base intention: sell_gold {
        <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> target: the_market ;
        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (the_market.location = location)  {
            <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove_belief</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">has_gold</span></span></span><span class="hljs-function">)</span></span>;
            <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove_intention</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sell_gold, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span></span><span class="hljs-function">)</span></span>;
            gold_sold &lt;- gold_sold + <span class="hljs-number"><span class="hljs-number">1</span></span>;
        }
    }

    aspect <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {
      <span class="hljs-function"><span class="hljs-function">draw </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">circle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">200</span></span></span></span></span><span class="hljs-function">) color: mycolor border: #black depth: gold_sold</span></span>;
    }
}

experiment GoldBdi type: gui {

    output {
        display map type: opengl
        {
            species market ;
            species goldmine ;
            species miner;
        }
    }
}
</code></pre>
<p><a href="BDIAgents.html">Back to the start of the tutorial</a></p>
<ol>
<li><a href="GoldMinerModel_step1.html">Creation of the basic model: gold mines and market</a>
<ol>
<li><a href="GoldMinerModel_step3.html">Definition of social relations between miners</a></li>
<li><a href="GoldMinerModel_step4.html">Use of emotions and personality for the miners</a></li>
<li><a href="GoldMinerModel_step5.html">Adding norms, obligations and enforcement</a></li>
</ol>
</li>
</ol>
<script>hljs.initHighlightingOnLoad();</script></body></html>